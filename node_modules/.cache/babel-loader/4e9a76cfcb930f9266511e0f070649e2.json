{"ast":null,"code":"/*! @azure/msal-common v4.5.0 2021-07-22 */\n'use strict';\n\nimport { AADAuthorityConstants, Constants as Constants$1 } from '../utils/Constants.js';\nimport { ClientAuthError as ClientAuthError$1 } from '../error/ClientAuthError.js';\nimport { StringUtils as StringUtils$1 } from '../utils/StringUtils.js';\nimport { ClientConfigurationError as ClientConfigurationError$1 } from '../error/ClientConfigurationError.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Url object class which can perform various transformations on url strings.\r\n */\n\nvar UrlString =\n/** @class */\nfunction () {\n  function UrlString(url) {\n    this._urlString = url;\n\n    if (StringUtils$1.isEmpty(this._urlString)) {\n      // Throws error if url is empty\n      throw ClientConfigurationError$1.createUrlEmptyError();\n    }\n\n    if (StringUtils$1.isEmpty(this.getHash())) {\n      this._urlString = UrlString.canonicalizeUri(url);\n    }\n  }\n\n  Object.defineProperty(UrlString.prototype, \"urlString\", {\n    get: function () {\n      return this._urlString;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Ensure urls are lower case and end with a / character.\r\n   * @param url\r\n   */\n\n  UrlString.canonicalizeUri = function (url) {\n    if (url) {\n      var lowerCaseUrl = url.toLowerCase();\n\n      if (StringUtils$1.endsWith(lowerCaseUrl, \"?\")) {\n        lowerCaseUrl = lowerCaseUrl.slice(0, -1);\n      } else if (StringUtils$1.endsWith(lowerCaseUrl, \"?/\")) {\n        lowerCaseUrl = lowerCaseUrl.slice(0, -2);\n      }\n\n      if (!StringUtils$1.endsWith(lowerCaseUrl, \"/\")) {\n        lowerCaseUrl += \"/\";\n      }\n\n      return lowerCaseUrl;\n    }\n\n    return url;\n  };\n  /**\r\n   * Throws if urlString passed is not a valid authority URI string.\r\n   */\n\n\n  UrlString.prototype.validateAsUri = function () {\n    // Attempts to parse url for uri components\n    var components;\n\n    try {\n      components = this.getUrlComponents();\n    } catch (e) {\n      throw ClientConfigurationError$1.createUrlParseError(e);\n    } // Throw error if URI or path segments are not parseable.\n\n\n    if (!components.HostNameAndPort || !components.PathSegments) {\n      throw ClientConfigurationError$1.createUrlParseError(\"Given url string: \" + this.urlString);\n    } // Throw error if uri is insecure.\n\n\n    if (!components.Protocol || components.Protocol.toLowerCase() !== \"https:\") {\n      throw ClientConfigurationError$1.createInsecureAuthorityUriError(this.urlString);\n    }\n  };\n  /**\r\n   * Function to remove query string params from url. Returns the new url.\r\n   * @param url\r\n   * @param name\r\n   */\n\n\n  UrlString.prototype.urlRemoveQueryStringParameter = function (name) {\n    var regex = new RegExp(\"(\\\\&\" + name + \"=)[^\\&]+\");\n    this._urlString = this.urlString.replace(regex, \"\"); // name=value&\n\n    regex = new RegExp(\"(\" + name + \"=)[^\\&]+&\");\n    this._urlString = this.urlString.replace(regex, \"\"); // name=value\n\n    regex = new RegExp(\"(\" + name + \"=)[^\\&]+\");\n    this._urlString = this.urlString.replace(regex, \"\");\n    return this.urlString;\n  };\n  /**\r\n   * Given a url and a query string return the url with provided query string appended\r\n   * @param url\r\n   * @param queryString\r\n   */\n\n\n  UrlString.appendQueryString = function (url, queryString) {\n    if (StringUtils$1.isEmpty(queryString)) {\n      return url;\n    }\n\n    return url.indexOf(\"?\") < 0 ? url + \"?\" + queryString : url + \"&\" + queryString;\n  };\n  /**\r\n   * Returns a url with the hash removed\r\n   * @param url\r\n   */\n\n\n  UrlString.removeHashFromUrl = function (url) {\n    return UrlString.canonicalizeUri(url.split(\"#\")[0]);\n  };\n  /**\r\n   * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d\r\n   * @param href The url\r\n   * @param tenantId The tenant id to replace\r\n   */\n\n\n  UrlString.prototype.replaceTenantPath = function (tenantId) {\n    var urlObject = this.getUrlComponents();\n    var pathArray = urlObject.PathSegments;\n\n    if (tenantId && pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)) {\n      pathArray[0] = tenantId;\n    }\n\n    return UrlString.constructAuthorityUriFromObject(urlObject);\n  };\n  /**\r\n   * Returns the anchor part(#) of the URL\r\n   */\n\n\n  UrlString.prototype.getHash = function () {\n    return UrlString.parseHash(this.urlString);\n  };\n  /**\r\n   * Parses out the components from a url string.\r\n   * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.\r\n   */\n\n\n  UrlString.prototype.getUrlComponents = function () {\n    // https://gist.github.com/curtisz/11139b2cfcaef4a261e0\n    var regEx = RegExp(\"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\"); // If url string does not match regEx, we throw an error\n\n    var match = this.urlString.match(regEx);\n\n    if (!match) {\n      throw ClientConfigurationError$1.createUrlParseError(\"Given url string: \" + this.urlString);\n    } // Url component object\n\n\n    var urlComponents = {\n      Protocol: match[1],\n      HostNameAndPort: match[4],\n      AbsolutePath: match[5],\n      QueryString: match[7]\n    };\n    var pathSegments = urlComponents.AbsolutePath.split(\"/\");\n    pathSegments = pathSegments.filter(function (val) {\n      return val && val.length > 0;\n    }); // remove empty elements\n\n    urlComponents.PathSegments = pathSegments;\n\n    if (!StringUtils$1.isEmpty(urlComponents.QueryString) && urlComponents.QueryString.endsWith(\"/\")) {\n      urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);\n    }\n\n    return urlComponents;\n  };\n\n  UrlString.getDomainFromUrl = function (url) {\n    var regEx = RegExp(\"^([^:/?#]+://)?([^/?#]*)\");\n    var match = url.match(regEx);\n\n    if (!match) {\n      throw ClientConfigurationError$1.createUrlParseError(\"Given url string: \" + url);\n    }\n\n    return match[2];\n  };\n\n  UrlString.getAbsoluteUrl = function (relativeUrl, baseUrl) {\n    if (relativeUrl[0] === Constants$1.FORWARD_SLASH) {\n      var url = new UrlString(baseUrl);\n      var baseComponents = url.getUrlComponents();\n      return baseComponents.Protocol + \"//\" + baseComponents.HostNameAndPort + relativeUrl;\n    }\n\n    return relativeUrl;\n  };\n  /**\r\n   * Parses hash string from given string. Returns empty string if no hash symbol is found.\r\n   * @param hashString\r\n   */\n\n\n  UrlString.parseHash = function (hashString) {\n    var hashIndex1 = hashString.indexOf(\"#\");\n    var hashIndex2 = hashString.indexOf(\"#/\");\n\n    if (hashIndex2 > -1) {\n      return hashString.substring(hashIndex2 + 2);\n    } else if (hashIndex1 > -1) {\n      return hashString.substring(hashIndex1 + 1);\n    }\n\n    return \"\";\n  };\n\n  UrlString.constructAuthorityUriFromObject = function (urlObject) {\n    return new UrlString(urlObject.Protocol + \"//\" + urlObject.HostNameAndPort + \"/\" + urlObject.PathSegments.join(\"/\"));\n  };\n  /**\r\n   * Returns URL hash as server auth code response object.\r\n   */\n\n\n  UrlString.getDeserializedHash = function (hash) {\n    // Check if given hash is empty\n    if (StringUtils$1.isEmpty(hash)) {\n      return {};\n    } // Strip the # symbol if present\n\n\n    var parsedHash = UrlString.parseHash(hash); // If # symbol was not present, above will return empty string, so give original hash value\n\n    var deserializedHash = StringUtils$1.queryStringToObject(StringUtils$1.isEmpty(parsedHash) ? hash : parsedHash); // Check if deserialization didn't work\n\n    if (!deserializedHash) {\n      throw ClientAuthError$1.createHashNotDeserializedError(JSON.stringify(deserializedHash));\n    }\n\n    return deserializedHash;\n  };\n  /**\r\n   * Check if the hash of the URL string contains known properties\r\n   */\n\n\n  UrlString.hashContainsKnownProperties = function (hash) {\n    if (StringUtils$1.isEmpty(hash)) {\n      return false;\n    }\n\n    var parameters = UrlString.getDeserializedHash(hash);\n    return !!(parameters.code || parameters.error_description || parameters.error || parameters.state);\n  };\n\n  return UrlString;\n}();\n\nexport { UrlString };","map":{"version":3,"mappings":"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","names":["url","_urlString","StringUtils","isEmpty","ClientConfigurationError","createUrlEmptyError","getHash","UrlString","canonicalizeUri","Object","lowerCaseUrl","toLowerCase","endsWith","slice","components","getUrlComponents","e","createUrlParseError","HostNameAndPort","PathSegments","urlString","Protocol","createInsecureAuthorityUriError","name","regex","RegExp","replace","queryString","indexOf","split","tenantId","urlObject","pathArray","length","AADAuthorityConstants","COMMON","ORGANIZATIONS","constructAuthorityUriFromObject","parseHash","regEx","match","urlComponents","AbsolutePath","QueryString","pathSegments","filter","val","substring","relativeUrl","baseUrl","Constants","FORWARD_SLASH","baseComponents","hashString","hashIndex1","hashIndex2","join","hash","parsedHash","deserializedHash","queryStringToObject","ClientAuthError","createHashNotDeserializedError","JSON","stringify","parameters","getDeserializedHash","code","error_description","error","state"],"sources":["../../src/url/UrlString.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ServerAuthorizationCodeResponse } from \"../response/ServerAuthorizationCodeResponse\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { IUri } from \"./IUri\";\r\nimport { AADAuthorityConstants, Constants } from \"../utils/Constants\";\r\n\r\n/**\r\n * Url object class which can perform various transformations on url strings.\r\n */\r\nexport class UrlString {\r\n\r\n    // internal url string field\r\n    private _urlString: string;\r\n    public get urlString(): string {\r\n        return this._urlString;\r\n    }\r\n    \r\n    constructor(url: string) {\r\n        this._urlString = url;\r\n        if (StringUtils.isEmpty(this._urlString)) {\r\n            // Throws error if url is empty\r\n            throw ClientConfigurationError.createUrlEmptyError();\r\n        }\r\n\r\n        if (StringUtils.isEmpty(this.getHash())) {\r\n            this._urlString = UrlString.canonicalizeUri(url);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Ensure urls are lower case and end with a / character.\r\n     * @param url \r\n     */\r\n    static canonicalizeUri(url: string): string {\r\n        if (url) {\r\n            let lowerCaseUrl = url.toLowerCase();\r\n\r\n            if (StringUtils.endsWith(lowerCaseUrl, \"?\")) {\r\n                lowerCaseUrl = lowerCaseUrl.slice(0, -1);\r\n            } else if (StringUtils.endsWith(lowerCaseUrl, \"?/\")) {\r\n                lowerCaseUrl = lowerCaseUrl.slice(0, -2);\r\n            }\r\n\r\n            if (!StringUtils.endsWith(lowerCaseUrl, \"/\")) {\r\n                lowerCaseUrl += \"/\";\r\n            }\r\n\r\n            return lowerCaseUrl;\r\n        }\r\n\r\n        return url;\r\n    }\r\n\r\n    /**\r\n     * Throws if urlString passed is not a valid authority URI string.\r\n     */\r\n    validateAsUri(): void {\r\n        // Attempts to parse url for uri components\r\n        let components;\r\n        try {\r\n            components = this.getUrlComponents();\r\n        } catch (e) {\r\n            throw ClientConfigurationError.createUrlParseError(e);\r\n        }\r\n\r\n        // Throw error if URI or path segments are not parseable.\r\n        if (!components.HostNameAndPort || !components.PathSegments) {\r\n            throw ClientConfigurationError.createUrlParseError(`Given url string: ${this.urlString}`);\r\n        }\r\n\r\n        // Throw error if uri is insecure.\r\n        if(!components.Protocol || components.Protocol.toLowerCase() !== \"https:\") {\r\n            throw ClientConfigurationError.createInsecureAuthorityUriError(this.urlString);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function to remove query string params from url. Returns the new url.\r\n     * @param url\r\n     * @param name\r\n     */\r\n    urlRemoveQueryStringParameter(name: string): string {\r\n        let regex = new RegExp(\"(\\\\&\" + name + \"=)[^\\&]+\");\r\n        this._urlString = this.urlString.replace(regex, \"\");\r\n        // name=value&\r\n        regex = new RegExp(\"(\" + name + \"=)[^\\&]+&\");\r\n        this._urlString = this.urlString.replace(regex, \"\");\r\n        // name=value\r\n        regex = new RegExp(\"(\" + name + \"=)[^\\&]+\");\r\n        this._urlString = this.urlString.replace(regex, \"\");\r\n        return this.urlString;\r\n    }\r\n\r\n    /**\r\n     * Given a url and a query string return the url with provided query string appended\r\n     * @param url \r\n     * @param queryString \r\n     */\r\n    static appendQueryString(url: string, queryString: string): string {\r\n        if (StringUtils.isEmpty(queryString)) {\r\n            return url;\r\n        }\r\n\r\n        return url.indexOf(\"?\") < 0 ? `${url}?${queryString}` : `${url}&${queryString}`;\r\n    }\r\n\r\n    /**\r\n     * Returns a url with the hash removed\r\n     * @param url \r\n     */\r\n    static removeHashFromUrl(url: string): string {\r\n        return UrlString.canonicalizeUri(url.split(\"#\")[0]);\r\n    }\r\n\r\n    /**\r\n     * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d\r\n     * @param href The url\r\n     * @param tenantId The tenant id to replace\r\n     */\r\n    replaceTenantPath(tenantId: string): UrlString {\r\n        const urlObject = this.getUrlComponents();\r\n        const pathArray = urlObject.PathSegments;\r\n        if (tenantId && (pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS))) {\r\n            pathArray[0] = tenantId;\r\n        }\r\n        return UrlString.constructAuthorityUriFromObject(urlObject);\r\n    }\r\n\r\n    /**\r\n     * Returns the anchor part(#) of the URL\r\n     */\r\n    getHash(): string {\r\n        return UrlString.parseHash(this.urlString);\r\n    }\r\n\r\n    /**\r\n     * Parses out the components from a url string.\r\n     * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.\r\n     */\r\n    getUrlComponents(): IUri {\r\n        // https://gist.github.com/curtisz/11139b2cfcaef4a261e0\r\n        const regEx = RegExp(\"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\");\r\n\r\n        // If url string does not match regEx, we throw an error\r\n        const match = this.urlString.match(regEx);\r\n        if (!match) {\r\n            throw ClientConfigurationError.createUrlParseError(`Given url string: ${this.urlString}`);\r\n        }\r\n\r\n        // Url component object\r\n        const urlComponents = {\r\n            Protocol: match[1],\r\n            HostNameAndPort: match[4],\r\n            AbsolutePath: match[5],\r\n            QueryString: match[7]\r\n        } as IUri;\r\n\r\n        let pathSegments = urlComponents.AbsolutePath.split(\"/\");\r\n        pathSegments = pathSegments.filter((val) => val && val.length > 0); // remove empty elements\r\n        urlComponents.PathSegments = pathSegments;\r\n\r\n        if (!StringUtils.isEmpty(urlComponents.QueryString) && urlComponents.QueryString.endsWith(\"/\")) {\r\n            urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length-1);\r\n        }\r\n        return urlComponents;\r\n    }\r\n\r\n    static getDomainFromUrl(url: string): string {\r\n        const regEx = RegExp(\"^([^:/?#]+://)?([^/?#]*)\");\r\n\r\n        const match = url.match(regEx);\r\n\r\n        if (!match) {\r\n            throw ClientConfigurationError.createUrlParseError(`Given url string: ${url}`);\r\n        }\r\n\r\n        return match[2];\r\n    }\r\n\r\n    static getAbsoluteUrl(relativeUrl: string, baseUrl: string): string {\r\n        if (relativeUrl[0] === Constants.FORWARD_SLASH) {\r\n            const url = new UrlString(baseUrl);\r\n            const baseComponents = url.getUrlComponents();\r\n\r\n            return baseComponents.Protocol + \"//\" + baseComponents.HostNameAndPort + relativeUrl;\r\n        }\r\n        \r\n        return relativeUrl;\r\n    }\r\n    \r\n    /**\r\n     * Parses hash string from given string. Returns empty string if no hash symbol is found.\r\n     * @param hashString \r\n     */\r\n    static parseHash(hashString: string): string {\r\n        const hashIndex1 = hashString.indexOf(\"#\");\r\n        const hashIndex2 = hashString.indexOf(\"#/\");\r\n        if (hashIndex2 > -1) {\r\n            return hashString.substring(hashIndex2 + 2);\r\n        } else if (hashIndex1 > -1) {\r\n            return hashString.substring(hashIndex1 + 1);\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    static constructAuthorityUriFromObject(urlObject: IUri): UrlString {\r\n        return new UrlString(urlObject.Protocol + \"//\" + urlObject.HostNameAndPort + \"/\" + urlObject.PathSegments.join(\"/\"));\r\n    }\r\n\r\n    /**\r\n     * Returns URL hash as server auth code response object.\r\n     */\r\n    static getDeserializedHash(hash: string): ServerAuthorizationCodeResponse {\r\n        // Check if given hash is empty\r\n        if (StringUtils.isEmpty(hash)) {\r\n            return {};\r\n        }\r\n        // Strip the # symbol if present\r\n        const parsedHash = UrlString.parseHash(hash);\r\n        // If # symbol was not present, above will return empty string, so give original hash value\r\n        const deserializedHash: ServerAuthorizationCodeResponse = StringUtils.queryStringToObject<ServerAuthorizationCodeResponse>(StringUtils.isEmpty(parsedHash) ? hash : parsedHash);\r\n        // Check if deserialization didn't work\r\n        if (!deserializedHash) {\r\n            throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedHash));\r\n        }\r\n        return deserializedHash;\r\n    }\r\n\r\n    /**\r\n     * Check if the hash of the URL string contains known properties\r\n     */\r\n    static hashContainsKnownProperties(hash: string): boolean {\r\n        if (StringUtils.isEmpty(hash)) {\r\n            return false;\r\n        }\r\n\r\n        const parameters: ServerAuthorizationCodeResponse = UrlString.getDeserializedHash(hash);\r\n        return !!(\r\n            parameters.code ||\r\n            parameters.error_description ||\r\n            parameters.error ||\r\n            parameters.state\r\n        );\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}