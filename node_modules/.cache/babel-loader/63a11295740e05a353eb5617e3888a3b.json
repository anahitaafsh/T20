{"ast":null,"code":"/*! @azure/msal-browser v2.29.0 2022-10-03 */\n'use strict';\n\nimport { __spread, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { KEY_FORMAT_JWK } from '../utils/BrowserConstants.js';\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nvar MsrBrowserCrypto =\n/** @class */\nfunction () {\n  function MsrBrowserCrypto() {}\n\n  MsrBrowserCrypto.prototype.initPrng = function (entropy) {\n    // Turn into array, as initPrng seems to not always like Uint8Array (even though it should support both)\n    return window.msrCrypto.initPrng(__spread(entropy));\n  };\n\n  MsrBrowserCrypto.prototype.getRandomValues = function (dataBuffer) {\n    return window.msrCrypto.getRandomValues(dataBuffer);\n  };\n\n  MsrBrowserCrypto.prototype.generateKey = function (algorithm, extractable, keyUsages) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , window.msrCrypto.subtle.generateKey(algorithm, extractable, keyUsages)];\n      });\n    });\n  };\n\n  MsrBrowserCrypto.prototype.exportKey = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , window.msrCrypto.subtle.exportKey(KEY_FORMAT_JWK, key)];\n      });\n    });\n  };\n\n  MsrBrowserCrypto.prototype.importKey = function (keyData, algorithm, extractable, keyUsages) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , window.msrCrypto.subtle.importKey(KEY_FORMAT_JWK, keyData, algorithm, extractable, keyUsages)];\n      });\n    });\n  };\n\n  MsrBrowserCrypto.prototype.sign = function (algorithm, key, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , window.msrCrypto.subtle.sign(algorithm, key, data)];\n      });\n    });\n  };\n\n  MsrBrowserCrypto.prototype.digest = function (algorithm, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , window.msrCrypto.subtle.digest(algorithm, data)];\n      });\n    });\n  };\n\n  return MsrBrowserCrypto;\n}();\n\nexport { MsrBrowserCrypto };","map":{"version":3,"mappings":";;;;;AAAA;;;;;;;;EAgBA,6BA6BC;;EA5BGA,gDAASC,OAAT,EAA6B;;IAEzB,OAAOC,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAAyBC,SAAKJ,OAAL,CAAzB,CAAP;EACH,CAHD;;EAKAD,uDAAgBM,UAAhB,EAAsC;IAClC,OAAOJ,MAAM,CAACC,SAAP,CAAiBI,eAAjB,CAAiCD,UAAjC,CAAP;EACH,CAFD;;EAIMN,yCAAN,UAAkBQ,SAAlB,EAAoDC,WAApD,EAA0EC,SAA1E,EAA+F;;;QAC3F;QAAA;QAAA,EAAOR,MAAM,CAACC,SAAP,CAAiBQ,MAAjB,CAAwBC,WAAxB,CAAoCJ,SAApC,EAA+CC,WAA/C,EAA4DC,SAA5D,CAAP;;;EACH,CAFK;;EAIAV,uCAAN,UAAgBa,GAAhB,EAA8B;;;QAC1B;QAAA;QAAA,EAAOX,MAAM,CAACC,SAAP,CAAiBQ,MAAjB,CAAwBG,SAAxB,CAAkCC,cAAlC,EAAkDF,GAAlD,CAAP;;;EACH,CAFK;;EAIAb,uCAAN,UAAgBgB,OAAhB,EAAqCR,SAArC,EAAuEC,WAAvE,EAA6FC,SAA7F,EAAkH;;;QAC9G;QAAA;QAAA,EAAOR,MAAM,CAACC,SAAP,CAAiBQ,MAAjB,CAAwBM,SAAxB,CAAkCF,cAAlC,EAAkDC,OAAlD,EAA2DR,SAA3D,EAAsEC,WAAtE,EAAmFC,SAAnF,CAAP;;;EACH,CAFK;;EAIAV,kCAAN,UAAWQ,SAAX,EAA2CK,GAA3C,EAA2DK,IAA3D,EAA4E;;;QACxE;QAAA;QAAA,EAAOhB,MAAM,CAACC,SAAP,CAAiBQ,MAAjB,CAAwBQ,IAAxB,CAA6BX,SAA7B,EAAwCK,GAAxC,EAA6CK,IAA7C,CAAP;;;EACH,CAFK;;EAIAlB,oCAAN,UAAaQ,SAAb,EAA6CU,IAA7C,EAA6D;;;QACzD;QAAA;QAAA,EAAOhB,MAAM,CAACC,SAAP,CAAiBQ,MAAjB,CAAwBS,MAAxB,CAA+BZ,SAA/B,EAA0CU,IAA1C,CAAP;;;EACH,CAFK;;EAGV;AAAC","names":["MsrBrowserCrypto","entropy","window","msrCrypto","initPrng","__spread","dataBuffer","getRandomValues","algorithm","extractable","keyUsages","subtle","generateKey","key","exportKey","KEY_FORMAT_JWK","keyData","importKey","data","sign","digest"],"sources":["../../src/crypto/MsrBrowserCrypto.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { KEY_FORMAT_JWK } from \"../utils/BrowserConstants\";\nimport { ISubtleCrypto } from \"./ISubtleCrypto\";\n\ndeclare global {\n    interface Window {\n        msrCrypto: Crypto & {\n            initPrng: (entropy: Uint8Array | number[]) => void\n        }\n    }\n}\n\nexport class MsrBrowserCrypto implements ISubtleCrypto {\n    initPrng(entropy : Uint8Array): void {\n        // Turn into array, as initPrng seems to not always like Uint8Array (even though it should support both)\n        return window.msrCrypto.initPrng([...entropy]);\n    }\n\n    getRandomValues(dataBuffer: Uint8Array): Uint8Array {\n        return window.msrCrypto.getRandomValues(dataBuffer);\n    }\n\n    async generateKey(algorithm: RsaHashedKeyGenParams, extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKeyPair> {\n        return window.msrCrypto.subtle.generateKey(algorithm, extractable, keyUsages) as Promise<CryptoKeyPair>;\n    }\n\n    async exportKey(key: CryptoKey): Promise<JsonWebKey> {\n        return window.msrCrypto.subtle.exportKey(KEY_FORMAT_JWK, key) as Promise<JsonWebKey> as Promise<JsonWebKey>;\n    }\n\n    async importKey(keyData: JsonWebKey, algorithm: RsaHashedImportParams, extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKey> {\n        return window.msrCrypto.subtle.importKey(KEY_FORMAT_JWK, keyData, algorithm, extractable, keyUsages) as Promise<CryptoKey>;\n    }\n\n    async sign(algorithm: AlgorithmIdentifier, key: CryptoKey, data: ArrayBuffer): Promise<ArrayBuffer> {\n        return window.msrCrypto.subtle.sign(algorithm, key, data) as Promise<ArrayBuffer>;\n    }\n\n    async digest(algorithm: AlgorithmIdentifier, data: Uint8Array): Promise<ArrayBuffer> {\n        return window.msrCrypto.subtle.digest(algorithm, data) as Promise<ArrayBuffer>; \n    }\n}\n"]},"metadata":{},"sourceType":"module"}