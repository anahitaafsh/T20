{"ast":null,"code":"/*! @azure/msal-browser v2.29.0 2022-10-03 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { Constants } from '@azure/msal-common';\nimport { KEY_FORMAT_JWK } from '../utils/BrowserConstants.js';\nimport { BrowserStringUtils } from '../utils/BrowserStringUtils.js';\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nvar MsBrowserCrypto =\n/** @class */\nfunction () {\n  function MsBrowserCrypto() {}\n\n  MsBrowserCrypto.prototype.getRandomValues = function (dataBuffer) {\n    return window[\"msCrypto\"].getRandomValues(dataBuffer);\n  };\n\n  MsBrowserCrypto.prototype.generateKey = function (algorithm, extractable, keyUsages) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msGenerateKey = window[\"msCrypto\"].subtle.generateKey(algorithm, extractable, keyUsages);\n          msGenerateKey.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msGenerateKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n\n  MsBrowserCrypto.prototype.exportKey = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msExportKey = window[\"msCrypto\"].subtle.exportKey(KEY_FORMAT_JWK, key);\n          msExportKey.addEventListener(\"complete\", function (e) {\n            var resultBuffer = e.target.result;\n            var resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer)).replace(/\\r/g, Constants.EMPTY_STRING).replace(/\\n/g, Constants.EMPTY_STRING).replace(/\\t/g, Constants.EMPTY_STRING).split(\" \").join(Constants.EMPTY_STRING).replace(\"\\0\", Constants.EMPTY_STRING);\n\n            try {\n              resolve(JSON.parse(resultString));\n            } catch (e) {\n              reject(e);\n            }\n          });\n          msExportKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n\n  MsBrowserCrypto.prototype.importKey = function (keyData, algorithm, extractable, keyUsages) {\n    return __awaiter(this, void 0, void 0, function () {\n      var keyString, keyBuffer;\n      return __generator(this, function (_a) {\n        keyString = BrowserStringUtils.getSortedObjectString(keyData);\n        keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msImportKey = window[\"msCrypto\"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, algorithm, extractable, keyUsages);\n          msImportKey.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msImportKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n\n  MsBrowserCrypto.prototype.sign = function (algorithm, key, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msSign = window[\"msCrypto\"].subtle.sign(algorithm, key, data);\n          msSign.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msSign.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n\n  MsBrowserCrypto.prototype.digest = function (algorithm, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var digestOperation = window[\"msCrypto\"].subtle.digest(algorithm, data.buffer);\n          digestOperation.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          digestOperation.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n\n  return MsBrowserCrypto;\n}();\n\nexport { MsBrowserCrypto };","map":{"version":3,"mappings":"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","names":["MsBrowserCrypto","dataBuffer","window","getRandomValues","algorithm","extractable","keyUsages","Promise","resolve","reject","msGenerateKey","subtle","generateKey","addEventListener","e","target","result","error","key","msExportKey","exportKey","KEY_FORMAT_JWK","resultBuffer","resultString","BrowserStringUtils","utf8ArrToString","Uint8Array","replace","Constants","EMPTY_STRING","split","join","JSON","parse","keyData","keyString","getSortedObjectString","keyBuffer","stringToArrayBuffer","msImportKey","importKey","data","msSign","sign","digestOperation","digest","buffer"],"sources":["../../src/crypto/MsBrowserCrypto.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Constants } from \"@azure/msal-common\";\nimport { KEY_FORMAT_JWK } from \"../utils/BrowserConstants\";\nimport { BrowserStringUtils } from \"../utils/BrowserStringUtils\";\nimport { ISubtleCrypto } from \"./ISubtleCrypto\";\n\nexport class MsBrowserCrypto implements ISubtleCrypto {\n    getRandomValues(dataBuffer: Uint8Array): Uint8Array {\n        return window[\"msCrypto\"].getRandomValues(dataBuffer);\n    }\n\n    async generateKey(algorithm: RsaHashedKeyGenParams, extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKeyPair> {\n        return new Promise((resolve: Function, reject: Function) => {\n            const msGenerateKey = window[\"msCrypto\"].subtle.generateKey(algorithm, extractable, keyUsages);\n            msGenerateKey.addEventListener(\"complete\", (e: { target: { result: CryptoKeyPair | PromiseLike<CryptoKeyPair>; }; }) => {\n                resolve(e.target.result);\n            });\n\n            msGenerateKey.addEventListener(\"error\", (error: string) => {\n                reject(error);\n            });\n        });\n    }\n\n    async exportKey(key: CryptoKey): Promise<JsonWebKey> {\n        return new Promise((resolve: Function, reject: Function) => {\n            const msExportKey = window[\"msCrypto\"].subtle.exportKey(KEY_FORMAT_JWK, key);\n            msExportKey.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer; }; }) => {\n                const resultBuffer: ArrayBuffer = e.target.result;\n\n                const resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer))\n                    .replace(/\\r/g, Constants.EMPTY_STRING)\n                    .replace(/\\n/g, Constants.EMPTY_STRING)\n                    .replace(/\\t/g, Constants.EMPTY_STRING)\n                    .split(\" \").join(Constants.EMPTY_STRING)\n                    .replace(\"\\u0000\", Constants.EMPTY_STRING);\n\n                try {\n                    resolve(JSON.parse(resultString));\n                } catch (e) {\n                    reject(e);\n                }\n            });\n\n            msExportKey.addEventListener(\"error\", (error: string) => {\n                reject(error);\n            });\n        });\n    }\n\n    async importKey(keyData: JsonWebKey, algorithm: RsaHashedImportParams, extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKey> {\n        const keyString = BrowserStringUtils.getSortedObjectString(keyData);\n        const keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);\n\n        return new Promise((resolve: Function, reject: Function) => {\n            const msImportKey = window[\"msCrypto\"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, algorithm, extractable, keyUsages);\n            msImportKey.addEventListener(\"complete\", (e: { target: { result: CryptoKey | PromiseLike<CryptoKey>; }; }) => {\n                resolve(e.target.result);\n            });\n\n            msImportKey.addEventListener(\"error\", (error: string) => {\n                reject(error);\n            });\n        });\n    }\n\n    async sign(algorithm: AlgorithmIdentifier, key: CryptoKey, data: ArrayBuffer): Promise<ArrayBuffer> {\n        return new Promise((resolve: Function, reject: Function) => {\n            const msSign = window[\"msCrypto\"].subtle.sign(algorithm, key, data);\n            msSign.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer | PromiseLike<ArrayBuffer>; }; }) => {\n                resolve(e.target.result);\n            });\n\n            msSign.addEventListener(\"error\", (error: string) => {\n                reject(error);\n            });\n        });\n    }\n    \n    async digest(algorithm: AlgorithmIdentifier, data: Uint8Array): Promise<ArrayBuffer> {\n        return new Promise((resolve, reject) => {\n            const digestOperation = window[\"msCrypto\"].subtle.digest(algorithm, data.buffer);\n            digestOperation.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer | PromiseLike<ArrayBuffer>; }; }) => {\n                resolve(e.target.result);\n            });\n            digestOperation.addEventListener(\"error\", (error: string) => {\n                reject(error);\n            });\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}