{"ast":null,"code":"/*! @azure/msal-common v4.5.0 2021-07-22 */\n'use strict';\n\nimport { __extends, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { CacheOutcome, AuthenticationScheme } from '../utils/Constants.js';\nimport { ClientAuthError as ClientAuthError$1, ClientAuthErrorMessage } from '../error/ClientAuthError.js';\nimport { StringUtils as StringUtils$1 } from '../utils/StringUtils.js';\nimport { ClientConfigurationError as ClientConfigurationError$1 } from '../error/ClientConfigurationError.js';\nimport { ScopeSet as ScopeSet$1 } from '../request/ScopeSet.js';\nimport { AuthToken as AuthToken$1 } from '../account/AuthToken.js';\nimport { BaseClient as BaseClient$1 } from './BaseClient.js';\nimport { TimeUtils as TimeUtils$1 } from '../utils/TimeUtils.js';\nimport { ResponseHandler as ResponseHandler$1 } from '../response/ResponseHandler.js';\nimport { RefreshTokenClient as RefreshTokenClient$1 } from './RefreshTokenClient.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar SilentFlowClient =\n/** @class */\nfunction (_super) {\n  __extends(SilentFlowClient, _super);\n\n  function SilentFlowClient(configuration) {\n    return _super.call(this, configuration) || this;\n  }\n  /**\r\n   * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew\r\n   * the given token and returns the renewed token\r\n   * @param request\r\n   */\n\n\n  SilentFlowClient.prototype.acquireToken = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1, refreshTokenClient;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.acquireCachedToken(request)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 2:\n            e_1 = _a.sent();\n\n            if (e_1 instanceof ClientAuthError$1 && e_1.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {\n              refreshTokenClient = new RefreshTokenClient$1(this.config);\n              return [2\n              /*return*/\n              , refreshTokenClient.acquireTokenByRefreshToken(request)];\n            } else {\n              throw e_1;\n            }\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Retrieves token from cache or throws an error if it must be refreshed.\r\n   * @param request\r\n   */\n\n\n  SilentFlowClient.prototype.acquireCachedToken = function (request) {\n    var _a, _b, _c, _d;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var requestScopes, environment, authScheme, cacheRecord;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            // Cannot renew token if no request object is given.\n            if (!request) {\n              throw ClientConfigurationError$1.createEmptyTokenRequestError();\n            } // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n\n\n            if (!request.account) {\n              throw ClientAuthError$1.createNoAccountInSilentRequestError();\n            }\n\n            requestScopes = new ScopeSet$1(request.scopes || []);\n            environment = request.authority || this.authority.getPreferredCache();\n            authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n            cacheRecord = this.cacheManager.readCacheRecord(request.account, this.config.authOptions.clientId, requestScopes, environment, authScheme);\n\n            if (request.forceRefresh) {\n              // Must refresh due to present force_refresh flag.\n              (_a = this.serverTelemetryManager) === null || _a === void 0 ? void 0 : _a.setCacheOutcome(CacheOutcome.FORCE_REFRESH);\n              throw ClientAuthError$1.createRefreshRequiredError();\n            } else if (!cacheRecord.accessToken) {\n              // Must refresh due to non-existent access_token.\n              (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);\n              throw ClientAuthError$1.createRefreshRequiredError();\n            } else if (TimeUtils$1.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) || TimeUtils$1.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {\n              // Must refresh due to expired access_token.\n              (_c = this.serverTelemetryManager) === null || _c === void 0 ? void 0 : _c.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);\n              throw ClientAuthError$1.createRefreshRequiredError();\n            } else if (cacheRecord.accessToken.refreshOn && TimeUtils$1.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {\n              // Must refresh due to the refresh_in value.\n              (_d = this.serverTelemetryManager) === null || _d === void 0 ? void 0 : _d.setCacheOutcome(CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN);\n              throw ClientAuthError$1.createRefreshRequiredError();\n            } else if (!StringUtils$1.isEmptyObj(request.claims)) {\n              // Must refresh due to request parameters.\n              throw ClientAuthError$1.createRefreshRequiredError();\n            }\n\n            if (this.config.serverTelemetryManager) {\n              this.config.serverTelemetryManager.incrementCacheHits();\n            }\n\n            return [4\n            /*yield*/\n            , this.generateResultFromCacheRecord(cacheRecord, request)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _e.sent()];\n        }\n      });\n    });\n  };\n  /**\r\n   * Helper function to build response object from the CacheRecord\r\n   * @param cacheRecord\r\n   */\n\n\n  SilentFlowClient.prototype.generateResultFromCacheRecord = function (cacheRecord, request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var idTokenObj;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (cacheRecord.idToken) {\n              idTokenObj = new AuthToken$1(cacheRecord.idToken.secret, this.config.cryptoInterface);\n            }\n\n            return [4\n            /*yield*/\n            , ResponseHandler$1.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenObj)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n\n  return SilentFlowClient;\n}(BaseClient$1);\n\nexport { SilentFlowClient };","map":{"version":3,"mappings":"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","names":["__extends","configuration","_super","SilentFlowClient","request","acquireCachedToken","_a","e_1","ClientAuthError","errorCode","ClientAuthErrorMessage","tokenRefreshRequired","code","refreshTokenClient","RefreshTokenClient","config","acquireTokenByRefreshToken","ClientConfigurationError","createEmptyTokenRequestError","account","createNoAccountInSilentRequestError","requestScopes","ScopeSet","scopes","environment","authority","getPreferredCache","authScheme","authenticationScheme","AuthenticationScheme","BEARER","cacheRecord","cacheManager","readCacheRecord","authOptions","clientId","forceRefresh","serverTelemetryManager","setCacheOutcome","CacheOutcome","FORCE_REFRESH","createRefreshRequiredError","accessToken","_b","NO_CACHED_ACCESS_TOKEN","TimeUtils","wasClockTurnedBack","cachedAt","isTokenExpired","expiresOn","systemOptions","tokenRenewalOffsetSeconds","_c","CACHED_ACCESS_TOKEN_EXPIRED","refreshOn","_d","REFRESH_CACHED_ACCESS_TOKEN","StringUtils","isEmptyObj","claims","incrementCacheHits","generateResultFromCacheRecord","_e","idToken","idTokenObj","AuthToken","secret","cryptoInterface","ResponseHandler","generateAuthenticationResult","cryptoUtils","BaseClient"],"sources":["../../src/client/SilentFlowClient.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { BaseClient } from \"./BaseClient\";\r\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\r\nimport { CommonSilentFlowRequest } from \"../request/CommonSilentFlowRequest\";\r\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\nimport { AuthToken } from \"../account/AuthToken\";\r\nimport { TimeUtils } from \"../utils/TimeUtils\";\r\nimport { RefreshTokenClient } from \"./RefreshTokenClient\";\r\nimport { ClientAuthError, ClientAuthErrorMessage } from \"../error/ClientAuthError\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\nimport { ResponseHandler } from \"../response/ResponseHandler\";\r\nimport { CacheRecord } from \"../cache/entities/CacheRecord\";\r\nimport { AuthenticationScheme, CacheOutcome } from \"../utils/Constants\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\n\r\nexport class SilentFlowClient extends BaseClient {\r\n\r\n    constructor(configuration: ClientConfiguration) {\r\n        super(configuration);\r\n    }\r\n\r\n    /**\r\n     * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew\r\n     * the given token and returns the renewed token\r\n     * @param request\r\n     */\r\n    async acquireToken(request: CommonSilentFlowRequest): Promise<AuthenticationResult> {\r\n        try {\r\n            return await this.acquireCachedToken(request);\r\n        } catch (e) {\r\n            if (e instanceof ClientAuthError && e.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {\r\n                const refreshTokenClient = new RefreshTokenClient(this.config);\r\n                return refreshTokenClient.acquireTokenByRefreshToken(request);\r\n            } else {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves token from cache or throws an error if it must be refreshed.\r\n     * @param request\r\n     */\r\n    async acquireCachedToken(request: CommonSilentFlowRequest): Promise<AuthenticationResult> {\r\n        // Cannot renew token if no request object is given.\r\n        if (!request) {\r\n            throw ClientConfigurationError.createEmptyTokenRequestError();\r\n        }\r\n\r\n        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\r\n        if (!request.account) {\r\n            throw ClientAuthError.createNoAccountInSilentRequestError();\r\n        }\r\n        const requestScopes = new ScopeSet(request.scopes || []);\r\n        const environment = request.authority || this.authority.getPreferredCache();\r\n        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\r\n        const cacheRecord = this.cacheManager.readCacheRecord(request.account, this.config.authOptions.clientId, requestScopes, environment, authScheme);\r\n       \r\n        if (request.forceRefresh) {\r\n            // Must refresh due to present force_refresh flag.\r\n            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.FORCE_REFRESH);\r\n            throw ClientAuthError.createRefreshRequiredError();\r\n        } else if (!cacheRecord.accessToken) {\r\n            // Must refresh due to non-existent access_token.\r\n            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);\r\n            throw ClientAuthError.createRefreshRequiredError();\r\n        } else if (\r\n            TimeUtils.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) ||\r\n            TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)\r\n        ) {\r\n            // Must refresh due to expired access_token.\r\n            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);\r\n            throw ClientAuthError.createRefreshRequiredError();\r\n        } else if (cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {\r\n            // Must refresh due to the refresh_in value.\r\n            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN);\r\n            throw ClientAuthError.createRefreshRequiredError();\r\n        } else if (!StringUtils.isEmptyObj(request.claims)) {\r\n            // Must refresh due to request parameters.\r\n            throw ClientAuthError.createRefreshRequiredError();\r\n        }\r\n\r\n        if (this.config.serverTelemetryManager) {\r\n            this.config.serverTelemetryManager.incrementCacheHits();\r\n        }\r\n\r\n        return await this.generateResultFromCacheRecord(cacheRecord, request);\r\n    }\r\n\r\n    /**\r\n     * Helper function to build response object from the CacheRecord\r\n     * @param cacheRecord\r\n     */\r\n    private async generateResultFromCacheRecord(cacheRecord: CacheRecord, request: CommonSilentFlowRequest): Promise<AuthenticationResult> {\r\n        let idTokenObj: AuthToken | undefined;\r\n        if (cacheRecord.idToken) {\r\n            idTokenObj = new AuthToken(cacheRecord.idToken.secret, this.config.cryptoInterface);\r\n        }\r\n        return await ResponseHandler.generateAuthenticationResult(\r\n            this.cryptoUtils,\r\n            this.authority,\r\n            cacheRecord,\r\n            true,\r\n            request,\r\n            idTokenObj\r\n        );\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}