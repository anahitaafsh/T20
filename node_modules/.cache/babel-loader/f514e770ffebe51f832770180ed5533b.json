{"ast":null,"code":"/*! @azure/msal-common v4.5.0 2021-07-22 */\n'use strict';\n\nimport { __extends } from '../../_virtual/_tslib.js';\nimport { CredentialType, AuthenticationScheme } from '../../utils/Constants.js';\nimport { ClientAuthError as ClientAuthError$1 } from '../../error/ClientAuthError.js';\nimport { StringUtils as StringUtils$1 } from '../../utils/StringUtils.js';\nimport { CredentialEntity as CredentialEntity$1 } from './CredentialEntity.js';\nimport { AuthToken as AuthToken$1 } from '../../account/AuthToken.js';\nimport { TimeUtils as TimeUtils$1 } from '../../utils/TimeUtils.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * ACCESS_TOKEN Credential Type\r\n *\r\n * Key:Value Schema:\r\n *\r\n * Key Example: uid.utid-login.microsoftonline.com-accesstoken-clientId-contoso.com-user.read\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\r\n *      clientId: client ID of the application\r\n *      secret: Actual credential as a string\r\n *      familyId: Family ID identifier, usually only used for refresh tokens\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\r\n *      cachedAt: Absolute device time when entry was created in the cache.\r\n *      expiresOn: Token expiry time, calculated based on current UTC time in seconds. Represented as a string.\r\n *      extendedExpiresOn: Additional extended expiry time until when token is valid in case of server-side outage. Represented as string in UTC seconds.\r\n *      keyId: used for POP and SSH tokenTypes\r\n *      tokenType: Type of the token issued. Usually \"Bearer\"\r\n * }\r\n */\n\nvar AccessTokenEntity =\n/** @class */\nfunction (_super) {\n  __extends(AccessTokenEntity, _super);\n\n  function AccessTokenEntity() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Create AccessTokenEntity\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param accessToken\r\n   * @param clientId\r\n   * @param tenantId\r\n   * @param scopes\r\n   * @param expiresOn\r\n   * @param extExpiresOn\r\n   */\n\n\n  AccessTokenEntity.createAccessTokenEntity = function (homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, cryptoUtils, refreshOn, tokenType, oboAssertion) {\n    var _a;\n\n    var atEntity = new AccessTokenEntity();\n    atEntity.homeAccountId = homeAccountId;\n    atEntity.credentialType = CredentialType.ACCESS_TOKEN;\n    atEntity.secret = accessToken;\n    var currentTime = TimeUtils$1.nowSeconds();\n    atEntity.cachedAt = currentTime.toString();\n    /*\r\n     * Token expiry time.\r\n     * This value should be  calculated based on the current UTC time measured locally and the value  expires_in Represented as a string in JSON.\r\n     */\n\n    atEntity.expiresOn = expiresOn.toString();\n    atEntity.extendedExpiresOn = extExpiresOn.toString();\n\n    if (refreshOn) {\n      atEntity.refreshOn = refreshOn.toString();\n    }\n\n    atEntity.environment = environment;\n    atEntity.clientId = clientId;\n    atEntity.realm = tenantId;\n    atEntity.target = scopes;\n    atEntity.oboAssertion = oboAssertion;\n    atEntity.tokenType = StringUtils$1.isEmpty(tokenType) ? AuthenticationScheme.BEARER : tokenType; // Create Access Token With AuthScheme instead of regular access token\n\n    if (atEntity.tokenType === AuthenticationScheme.POP) {\n      atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME; // Make sure keyId is present and add it to credential\n\n      var tokenClaims = AuthToken$1.extractTokenClaims(accessToken, cryptoUtils);\n\n      if (!((_a = tokenClaims === null || tokenClaims === void 0 ? void 0 : tokenClaims.cnf) === null || _a === void 0 ? void 0 : _a.kid)) {\n        throw ClientAuthError$1.createTokenClaimsRequiredError();\n      }\n\n      atEntity.keyId = tokenClaims.cnf.kid;\n    }\n\n    return atEntity;\n  };\n  /**\r\n   * Validates an entity: checks for all expected params\r\n   * @param entity\r\n   */\n\n\n  AccessTokenEntity.isAccessTokenEntity = function (entity) {\n    if (!entity) {\n      return false;\n    }\n\n    return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"credentialType\") && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"clientId\") && entity.hasOwnProperty(\"secret\") && entity.hasOwnProperty(\"target\") && (entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN || entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\n  };\n\n  return AccessTokenEntity;\n}(CredentialEntity$1);\n\nexport { AccessTokenEntity };","map":{"version":3,"mappings":";;;;;;;;;;AAAA;;;;;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAwBuCA;;EAAvC;;EAiGC;;;;;;;;;;;;;;EA5EUC,4CAAP,UACIC,aADJ,EAEIC,WAFJ,EAGIC,WAHJ,EAIIC,QAJJ,EAKIC,QALJ,EAMIC,MANJ,EAOIC,SAPJ,EAQIC,YARJ,EASIC,WATJ,EAUIC,SAVJ,EAWIC,SAXJ,EAYIC,YAZJ,EAYyB;;;IAErB,IAAMC,QAAQ,GAAsB,IAAIb,iBAAJ,EAApC;IAEAa,QAAQ,CAACZ,aAAT,GAAyBA,aAAzB;IACAY,QAAQ,CAACC,cAAT,GAA0BC,cAAc,CAACC,YAAzC;IACAH,QAAQ,CAACI,MAAT,GAAkBd,WAAlB;IAEA,IAAMe,WAAW,GAAGC,WAAS,CAACC,UAAVD,EAApB;IACAN,QAAQ,CAACQ,QAAT,GAAoBH,WAAW,CAACI,QAAZ,EAApB;;;;;;IAMAT,QAAQ,CAACN,SAAT,GAAqBA,SAAS,CAACe,QAAV,EAArB;IACAT,QAAQ,CAACU,iBAAT,GAA6Bf,YAAY,CAACc,QAAb,EAA7B;;IACA,IAAIZ,SAAJ,EAAe;MACXG,QAAQ,CAACH,SAAT,GAAqBA,SAAS,CAACY,QAAV,EAArB;IACH;;IAEDT,QAAQ,CAACX,WAAT,GAAuBA,WAAvB;IACAW,QAAQ,CAACT,QAAT,GAAoBA,QAApB;IACAS,QAAQ,CAACW,KAAT,GAAiBnB,QAAjB;IACAQ,QAAQ,CAACY,MAAT,GAAkBnB,MAAlB;IACAO,QAAQ,CAACD,YAAT,GAAwBA,YAAxB;IAEAC,QAAQ,CAACF,SAAT,GAAqBe,aAAW,CAACC,OAAZD,CAAoBf,SAApBe,IAAiCE,oBAAoB,CAACC,MAAtDH,GAA+Df,SAApF,CA3BqB;;IA8BrB,IAAIE,QAAQ,CAACF,SAAT,KAAuBiB,oBAAoB,CAACE,GAAhD,EAAqD;MACjDjB,QAAQ,CAACC,cAAT,GAA0BC,cAAc,CAACgB,6BAAzC,CADiD;;MAGjD,IAAMC,WAAW,GAAuBC,WAAS,CAACC,kBAAVD,CAA6B9B,WAA7B8B,EAA0CxB,WAA1CwB,CAAxC;;MACA,IAAI,QAACD,WAAW,SAAX,eAAW,WAAX,GAAW,MAAX,cAAW,CAAEG,GAAd,MAAiB,IAAjB,IAAiBC,aAAjB,GAAiB,MAAjB,GAAiBA,GAAEC,GAAnB,CAAJ,EAA4B;QACxB,MAAMC,iBAAe,CAACC,8BAAhBD,EAAN;MACH;;MACDzB,QAAQ,CAAC2B,KAAT,GAAiBR,WAAW,CAACG,GAAZ,CAAgBE,GAAjC;IACH;;IAED,OAAOxB,QAAP;EACH,CArDM;;;;;;;EA2DAb,wCAAP,UAA2ByC,MAA3B,EAAyC;IAErC,IAAI,CAACA,MAAL,EAAa;MACT,OAAO,KAAP;IACH;;IAED,OACIA,MAAM,CAACC,cAAP,CAAsB,eAAtB,KACAD,MAAM,CAACC,cAAP,CAAsB,aAAtB,CADA,IAEAD,MAAM,CAACC,cAAP,CAAsB,gBAAtB,CAFA,IAGAD,MAAM,CAACC,cAAP,CAAsB,OAAtB,CAHA,IAIAD,MAAM,CAACC,cAAP,CAAsB,UAAtB,CAJA,IAKAD,MAAM,CAACC,cAAP,CAAsB,QAAtB,CALA,IAMAD,MAAM,CAACC,cAAP,CAAsB,QAAtB,CANA,KAOCD,MAAM,CAAC,gBAAD,CAAN,KAA6B1B,cAAc,CAACC,YAA5C,IAA4DyB,MAAM,CAAC,gBAAD,CAAN,KAA6B1B,cAAc,CAACgB,6BAPzG,CADJ;EAUH,CAhBM;;EAiBX;AAjGA,EAAuCY","names":["__extends","AccessTokenEntity","homeAccountId","environment","accessToken","clientId","tenantId","scopes","expiresOn","extExpiresOn","cryptoUtils","refreshOn","tokenType","oboAssertion","atEntity","credentialType","CredentialType","ACCESS_TOKEN","secret","currentTime","TimeUtils","nowSeconds","cachedAt","toString","extendedExpiresOn","realm","target","StringUtils","isEmpty","AuthenticationScheme","BEARER","POP","ACCESS_TOKEN_WITH_AUTH_SCHEME","tokenClaims","AuthToken","extractTokenClaims","cnf","_a","kid","ClientAuthError","createTokenClaimsRequiredError","keyId","entity","hasOwnProperty","CredentialEntity"],"sources":["../../../src/cache/entities/AccessTokenEntity.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { CredentialEntity } from \"./CredentialEntity\";\r\nimport { CredentialType, AuthenticationScheme } from \"../../utils/Constants\";\r\nimport { TimeUtils } from \"../../utils/TimeUtils\";\r\nimport { StringUtils } from \"../../utils/StringUtils\";\r\nimport { ICrypto } from \"../../crypto/ICrypto\";\r\nimport { TokenClaims } from \"../../account/TokenClaims\";\r\nimport { AuthToken } from \"../../account/AuthToken\";\r\nimport { ClientAuthError } from \"../../error/ClientAuthError\";\r\n\r\n/**\r\n * ACCESS_TOKEN Credential Type\r\n *\r\n * Key:Value Schema:\r\n *\r\n * Key Example: uid.utid-login.microsoftonline.com-accesstoken-clientId-contoso.com-user.read\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\r\n *      clientId: client ID of the application\r\n *      secret: Actual credential as a string\r\n *      familyId: Family ID identifier, usually only used for refresh tokens\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\r\n *      cachedAt: Absolute device time when entry was created in the cache.\r\n *      expiresOn: Token expiry time, calculated based on current UTC time in seconds. Represented as a string.\r\n *      extendedExpiresOn: Additional extended expiry time until when token is valid in case of server-side outage. Represented as string in UTC seconds.\r\n *      keyId: used for POP and SSH tokenTypes\r\n *      tokenType: Type of the token issued. Usually \"Bearer\"\r\n * }\r\n */\r\nexport class AccessTokenEntity extends CredentialEntity {\r\n    realm: string;\r\n    target: string;\r\n    cachedAt: string;\r\n    expiresOn: string;\r\n    extendedExpiresOn?: string;\r\n    refreshOn?: string;\r\n    keyId?: string; // for POP and SSH tokenTypes\r\n    tokenType?: string;\r\n\r\n    /**\r\n     * Create AccessTokenEntity\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param accessToken\r\n     * @param clientId\r\n     * @param tenantId\r\n     * @param scopes\r\n     * @param expiresOn\r\n     * @param extExpiresOn\r\n     */\r\n    static createAccessTokenEntity(\r\n        homeAccountId: string,\r\n        environment: string,\r\n        accessToken: string,\r\n        clientId: string,\r\n        tenantId: string,\r\n        scopes: string,\r\n        expiresOn: number,\r\n        extExpiresOn: number,\r\n        cryptoUtils: ICrypto,\r\n        refreshOn?: number,\r\n        tokenType?: string,\r\n        oboAssertion?: string\r\n    ): AccessTokenEntity {\r\n        const atEntity: AccessTokenEntity = new AccessTokenEntity();\r\n\r\n        atEntity.homeAccountId = homeAccountId;\r\n        atEntity.credentialType = CredentialType.ACCESS_TOKEN;\r\n        atEntity.secret = accessToken;\r\n\r\n        const currentTime = TimeUtils.nowSeconds();\r\n        atEntity.cachedAt = currentTime.toString();\r\n\r\n        /*\r\n         * Token expiry time.\r\n         * This value should be  calculated based on the current UTC time measured locally and the value  expires_in Represented as a string in JSON.\r\n         */\r\n        atEntity.expiresOn = expiresOn.toString();\r\n        atEntity.extendedExpiresOn = extExpiresOn.toString();\r\n        if (refreshOn) {\r\n            atEntity.refreshOn = refreshOn.toString();\r\n        }\r\n\r\n        atEntity.environment = environment;\r\n        atEntity.clientId = clientId;\r\n        atEntity.realm = tenantId;\r\n        atEntity.target = scopes;\r\n        atEntity.oboAssertion = oboAssertion;\r\n\r\n        atEntity.tokenType = StringUtils.isEmpty(tokenType) ? AuthenticationScheme.BEARER : tokenType;\r\n\r\n        // Create Access Token With AuthScheme instead of regular access token\r\n        if (atEntity.tokenType === AuthenticationScheme.POP) {\r\n            atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\r\n            // Make sure keyId is present and add it to credential\r\n            const tokenClaims: TokenClaims | null = AuthToken.extractTokenClaims(accessToken, cryptoUtils);\r\n            if (!tokenClaims?.cnf?.kid) {\r\n                throw ClientAuthError.createTokenClaimsRequiredError();\r\n            }\r\n            atEntity.keyId = tokenClaims.cnf.kid;\r\n        }\r\n\r\n        return atEntity;\r\n    }\r\n\r\n    /**\r\n     * Validates an entity: checks for all expected params\r\n     * @param entity\r\n     */\r\n    static isAccessTokenEntity(entity: object): boolean {\r\n\r\n        if (!entity) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            entity.hasOwnProperty(\"homeAccountId\") &&\r\n            entity.hasOwnProperty(\"environment\") &&\r\n            entity.hasOwnProperty(\"credentialType\") &&\r\n            entity.hasOwnProperty(\"realm\") &&\r\n            entity.hasOwnProperty(\"clientId\") &&\r\n            entity.hasOwnProperty(\"secret\") &&\r\n            entity.hasOwnProperty(\"target\") &&\r\n            (entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN || entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME)\r\n        );\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}