{"ast":null,"code":"/*! @azure/msal-common v4.5.0 2021-07-22 */\n'use strict';\n\nimport { __extends, __awaiter, __generator, __assign, __spreadArrays } from '../_virtual/_tslib.js';\nimport { PromptValue, Separators, GrantType, AuthenticationScheme } from '../utils/Constants.js';\nimport { ClientAuthError as ClientAuthError$1 } from '../error/ClientAuthError.js';\nimport { StringUtils as StringUtils$1 } from '../utils/StringUtils.js';\nimport { ClientConfigurationError as ClientConfigurationError$1 } from '../error/ClientConfigurationError.js';\nimport { buildClientInfoFromHomeAccountId, buildClientInfo } from '../account/ClientInfo.js';\nimport { AccountEntity as AccountEntity$1 } from '../cache/entities/AccountEntity.js';\nimport { CcsCredentialType } from '../account/CcsCredential.js';\nimport { BaseClient as BaseClient$1 } from './BaseClient.js';\nimport { RequestParameterBuilder as RequestParameterBuilder$1 } from '../request/RequestParameterBuilder.js';\nimport { TimeUtils as TimeUtils$1 } from '../utils/TimeUtils.js';\nimport { UrlString as UrlString$1 } from '../url/UrlString.js';\nimport { PopTokenGenerator as PopTokenGenerator$1 } from '../crypto/PopTokenGenerator.js';\nimport { ResponseHandler as ResponseHandler$1 } from '../response/ResponseHandler.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Oauth2.0 Authorization Code client\r\n */\n\nvar AuthorizationCodeClient =\n/** @class */\nfunction (_super) {\n  __extends(AuthorizationCodeClient, _super);\n\n  function AuthorizationCodeClient(configuration) {\n    return _super.call(this, configuration) || this;\n  }\n  /**\r\n   * Creates the URL of the authorization request letting the user input credentials and consent to the\r\n   * application. The URL target the /authorize endpoint of the authority configured in the\r\n   * application object.\r\n   *\r\n   * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n   * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n   * acquireToken(AuthorizationCodeRequest)\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.getAuthCodeUrl = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var queryString;\n      return __generator(this, function (_a) {\n        queryString = this.createAuthCodeUrlQueryString(request);\n        return [2\n        /*return*/\n        , UrlString$1.appendQueryString(this.authority.authorizationEndpoint, queryString)];\n      });\n    });\n  };\n  /**\r\n   * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\r\n   * authorization_code_grant\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.acquireToken = function (request, authCodePayload) {\n    return __awaiter(this, void 0, void 0, function () {\n      var reqTimestamp, response, responseHandler;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.info(\"in acquireToken call\");\n\n            if (!request || StringUtils$1.isEmpty(request.code)) {\n              throw ClientAuthError$1.createTokenRequestCannotBeMadeError();\n            }\n\n            reqTimestamp = TimeUtils$1.nowSeconds();\n            return [4\n            /*yield*/\n            , this.executeTokenRequest(this.authority, request)];\n\n          case 1:\n            response = _a.sent();\n            responseHandler = new ResponseHandler$1(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin); // Validate response. This function throws a server error if an error is returned by the server.\n\n            responseHandler.validateTokenResponse(response.body);\n            return [4\n            /*yield*/\n            , responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, authCodePayload)];\n\n          case 2:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n  /**\r\n   * Handles the hash fragment response from public client code request. Returns a code response used by\r\n   * the client to exchange for a token in acquireToken.\r\n   * @param hashFragment\r\n   */\n\n\n  AuthorizationCodeClient.prototype.handleFragmentResponse = function (hashFragment, cachedState) {\n    // Handle responses.\n    var responseHandler = new ResponseHandler$1(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null); // Deserialize hash fragment response parameters.\n\n    var hashUrlString = new UrlString$1(hashFragment); // Deserialize hash fragment response parameters.\n\n    var serverParams = UrlString$1.getDeserializedHash(hashUrlString.getHash()); // Get code response\n\n    responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils); // throw when there is no auth code in the response\n\n    if (!serverParams.code) {\n      throw ClientAuthError$1.createNoAuthCodeInServerResponseError();\n    }\n\n    return __assign(__assign({}, serverParams), {\n      // Code param is optional in ServerAuthorizationCodeResponse but required in AuthorizationCodePaylod\n      code: serverParams.code\n    });\n  };\n  /**\r\n   * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n   * Default behaviour is to redirect the user to `window.location.href`.\r\n   * @param authorityUri\r\n   */\n\n\n  AuthorizationCodeClient.prototype.getLogoutUri = function (logoutRequest) {\n    // Throw error if logoutRequest is null/undefined\n    if (!logoutRequest) {\n      throw ClientConfigurationError$1.createEmptyLogoutRequestError();\n    }\n\n    if (logoutRequest.account) {\n      // Clear given account.\n      this.cacheManager.removeAccount(AccountEntity$1.generateAccountCacheKey(logoutRequest.account));\n    } else {\n      // Clear all accounts and tokens\n      this.cacheManager.clear();\n    }\n\n    var queryString = this.createLogoutUrlQueryString(logoutRequest); // Construct logout URI.\n\n    return UrlString$1.appendQueryString(this.authority.endSessionEndpoint, queryString);\n  };\n  /**\r\n   * Executes POST request to token endpoint\r\n   * @param authority\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.executeTokenRequest = function (authority, request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var thumbprint, requestBody, queryParameters, ccsCredential, clientInfo, headers, endpoint;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            thumbprint = {\n              clientId: this.config.authOptions.clientId,\n              authority: authority.canonicalAuthority,\n              scopes: request.scopes\n            };\n            return [4\n            /*yield*/\n            , this.createTokenRequestBody(request)];\n\n          case 1:\n            requestBody = _a.sent();\n            queryParameters = this.createTokenQueryParameters(request);\n            ccsCredential = undefined;\n\n            if (request.clientInfo) {\n              try {\n                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\n                ccsCredential = {\n                  credential: \"\" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,\n                  type: CcsCredentialType.HOME_ACCOUNT_ID\n                };\n              } catch (e) {\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n              }\n            }\n\n            headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);\n            endpoint = StringUtils$1.isEmpty(queryParameters) ? authority.tokenEndpoint : authority.tokenEndpoint + \"?\" + queryParameters;\n            return [2\n            /*return*/\n            , this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Creates query string for the /token request\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createTokenQueryParameters = function (request) {\n    var parameterBuilder = new RequestParameterBuilder$1();\n\n    if (request.tokenQueryParameters) {\n      parameterBuilder.addExtraQueryParameters(request.tokenQueryParameters);\n    }\n\n    return parameterBuilder.createQueryString();\n  };\n  /**\r\n   * Generates a map for all the params to be sent to the service\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createTokenRequestBody = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var parameterBuilder, clientAssertion, popTokenGenerator, cnfString, correlationId, ccsCred, clientInfo, clientInfo;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            parameterBuilder = new RequestParameterBuilder$1();\n            parameterBuilder.addClientId(this.config.authOptions.clientId); // validate the redirectUri (to be a non null value)\n\n            parameterBuilder.addRedirectUri(request.redirectUri); // Add scope array, parameter builder will add default scopes and dedupe\n\n            parameterBuilder.addScopes(request.scopes); // add code: user set, not validated\n\n            parameterBuilder.addAuthorizationCode(request.code); // Add library metadata\n\n            parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n            parameterBuilder.addThrottling();\n\n            if (this.serverTelemetryManager) {\n              parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n            } // add code_verifier if passed\n\n\n            if (request.codeVerifier) {\n              parameterBuilder.addCodeVerifier(request.codeVerifier);\n            }\n\n            if (this.config.clientCredentials.clientSecret) {\n              parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\n            }\n\n            if (this.config.clientCredentials.clientAssertion) {\n              clientAssertion = this.config.clientCredentials.clientAssertion;\n              parameterBuilder.addClientAssertion(clientAssertion.assertion);\n              parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\n            }\n\n            parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\n            parameterBuilder.addClientInfo();\n            if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 2];\n            popTokenGenerator = new PopTokenGenerator$1(this.cryptoUtils);\n            return [4\n            /*yield*/\n            , popTokenGenerator.generateCnf(request)];\n\n          case 1:\n            cnfString = _a.sent();\n            parameterBuilder.addPopToken(cnfString);\n            _a.label = 2;\n\n          case 2:\n            correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n            parameterBuilder.addCorrelationId(correlationId);\n\n            if (!StringUtils$1.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n              parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n            }\n\n            ccsCred = undefined;\n\n            if (request.clientInfo) {\n              try {\n                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\n                ccsCred = {\n                  credential: \"\" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,\n                  type: CcsCredentialType.HOME_ACCOUNT_ID\n                };\n              } catch (e) {\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n              }\n            } else {\n              ccsCred = request.ccsCredential;\n            } // Adds these as parameters in the request instead of headers to prevent CORS preflight request\n\n\n            if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\n              switch (ccsCred.type) {\n                case CcsCredentialType.HOME_ACCOUNT_ID:\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n                  }\n\n                  break;\n\n                case CcsCredentialType.UPN:\n                  parameterBuilder.addCcsUpn(ccsCred.credential);\n                  break;\n              }\n            }\n\n            return [2\n            /*return*/\n            , parameterBuilder.createQueryString()];\n        }\n      });\n    });\n  };\n  /**\r\n   * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createAuthCodeUrlQueryString = function (request) {\n    var parameterBuilder = new RequestParameterBuilder$1();\n    parameterBuilder.addClientId(this.config.authOptions.clientId);\n\n    var requestScopes = __spreadArrays(request.scopes || [], request.extraScopesToConsent || []);\n\n    parameterBuilder.addScopes(requestScopes); // validate the redirectUri (to be a non null value)\n\n    parameterBuilder.addRedirectUri(request.redirectUri); // generate the correlationId if not set by the user and add\n\n    var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n    parameterBuilder.addCorrelationId(correlationId); // add response_mode. If not passed in it defaults to query.\n\n    parameterBuilder.addResponseMode(request.responseMode); // add response_type = code\n\n    parameterBuilder.addResponseTypeCode(); // add library info parameters\n\n    parameterBuilder.addLibraryInfo(this.config.libraryInfo); // add client_info=1\n\n    parameterBuilder.addClientInfo();\n\n    if (request.codeChallenge && request.codeChallengeMethod) {\n      parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);\n    }\n\n    if (request.prompt) {\n      parameterBuilder.addPrompt(request.prompt);\n    }\n\n    if (request.domainHint) {\n      parameterBuilder.addDomainHint(request.domainHint);\n    } // Add sid or loginHint with preference for sid -> loginHint -> username of AccountInfo object\n\n\n    if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\n      // AAD will throw if prompt=select_account is passed with an account hint\n      if (request.sid && request.prompt === PromptValue.NONE) {\n        // SessionID is only used in silent calls\n        this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\");\n        parameterBuilder.addSid(request.sid);\n      } else if (request.account) {\n        var accountSid = this.extractAccountSid(request.account); // If account and loginHint are provided, we will check account first for sid before adding loginHint\n\n        if (accountSid && request.prompt === PromptValue.NONE) {\n          // SessionId is only used in silent calls\n          this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\");\n          parameterBuilder.addSid(accountSid);\n\n          try {\n            var clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n            parameterBuilder.addCcsOid(clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n          }\n        } else if (request.loginHint) {\n          this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from request\");\n          parameterBuilder.addLoginHint(request.loginHint);\n          parameterBuilder.addCcsUpn(request.loginHint);\n        } else if (request.account.username) {\n          // Fallback to account username if provided\n          this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from account\");\n          parameterBuilder.addLoginHint(request.account.username);\n\n          try {\n            var clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n            parameterBuilder.addCcsOid(clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n          }\n        }\n      } else if (request.loginHint) {\n        this.logger.verbose(\"createAuthCodeUrlQueryString: No account, adding login_hint from request\");\n        parameterBuilder.addLoginHint(request.loginHint);\n        parameterBuilder.addCcsUpn(request.loginHint);\n      }\n    } else {\n      this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\");\n    }\n\n    if (request.nonce) {\n      parameterBuilder.addNonce(request.nonce);\n    }\n\n    if (request.state) {\n      parameterBuilder.addState(request.state);\n    }\n\n    if (!StringUtils$1.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n      parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n    }\n\n    if (request.extraQueryParameters) {\n      parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n    }\n\n    return parameterBuilder.createQueryString();\n  };\n  /**\r\n   * This API validates the `EndSessionRequest` and creates a URL\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createLogoutUrlQueryString = function (request) {\n    var parameterBuilder = new RequestParameterBuilder$1();\n\n    if (request.postLogoutRedirectUri) {\n      parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);\n    }\n\n    if (request.correlationId) {\n      parameterBuilder.addCorrelationId(request.correlationId);\n    }\n\n    if (request.idTokenHint) {\n      parameterBuilder.addIdTokenHint(request.idTokenHint);\n    }\n\n    return parameterBuilder.createQueryString();\n  };\n  /**\r\n   * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\r\n   * @param account\r\n   */\n\n\n  AuthorizationCodeClient.prototype.extractAccountSid = function (account) {\n    if (account.idTokenClaims) {\n      var tokenClaims = account.idTokenClaims;\n      return tokenClaims.sid || null;\n    }\n\n    return null;\n  };\n\n  return AuthorizationCodeClient;\n}(BaseClient$1);\n\nexport { AuthorizationCodeClient };","map":{"version":3,"mappings":"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","names":["__extends","configuration","_super","AuthorizationCodeClient","request","queryString","createAuthCodeUrlQueryString","UrlString","appendQueryString","authority","authorizationEndpoint","authCodePayload","logger","info","StringUtils","isEmpty","code","ClientAuthError","createTokenRequestCannotBeMadeError","reqTimestamp","TimeUtils","nowSeconds","executeTokenRequest","response","_a","responseHandler","ResponseHandler","config","authOptions","clientId","cacheManager","cryptoUtils","serializableCache","persistencePlugin","validateTokenResponse","body","handleServerTokenResponse","hashFragment","cachedState","hashUrlString","serverParams","getDeserializedHash","getHash","validateServerAuthorizationCodeResponse","createNoAuthCodeInServerResponseError","logoutRequest","ClientConfigurationError","createEmptyLogoutRequestError","account","removeAccount","AccountEntity","generateAccountCacheKey","clear","createLogoutUrlQueryString","endSessionEndpoint","thumbprint","canonicalAuthority","scopes","createTokenRequestBody","requestBody","queryParameters","createTokenQueryParameters","ccsCredential","undefined","clientInfo","buildClientInfo","credential","uid","Separators","CLIENT_INFO_SEPARATOR","utid","type","CcsCredentialType","HOME_ACCOUNT_ID","e","verbose","headers","createTokenRequestHeaders","endpoint","tokenEndpoint","executePostToTokenEndpoint","parameterBuilder","RequestParameterBuilder","tokenQueryParameters","addExtraQueryParameters","createQueryString","addClientId","addRedirectUri","redirectUri","addScopes","addAuthorizationCode","addLibraryInfo","libraryInfo","addThrottling","serverTelemetryManager","addServerTelemetry","codeVerifier","addCodeVerifier","clientCredentials","clientSecret","addClientSecret","clientAssertion","addClientAssertion","assertion","addClientAssertionType","assertionType","addGrantType","GrantType","AUTHORIZATION_CODE_GRANT","addClientInfo","authenticationScheme","AuthenticationScheme","POP","popTokenGenerator","PopTokenGenerator","generateCnf","cnfString","addPopToken","correlationId","cryptoInterface","createNewGuid","addCorrelationId","isEmptyObj","claims","clientCapabilities","length","addClaims","ccsCred","systemOptions","preventCorsPreflight","buildClientInfoFromHomeAccountId","addCcsOid","UPN","addCcsUpn","requestScopes","extraScopesToConsent","addResponseMode","responseMode","addResponseTypeCode","codeChallenge","codeChallengeMethod","addCodeChallengeParams","prompt","addPrompt","domainHint","addDomainHint","PromptValue","SELECT_ACCOUNT","sid","NONE","addSid","accountSid","extractAccountSid","homeAccountId","loginHint","addLoginHint","username","nonce","addNonce","state","addState","extraQueryParameters","postLogoutRedirectUri","addPostLogoutRedirectUri","idTokenHint","addIdTokenHint","idTokenClaims","tokenClaims","BaseClient"],"sources":["../../src/client/AuthorizationCodeClient.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { BaseClient } from \"./BaseClient\";\r\nimport { CommonAuthorizationUrlRequest } from \"../request/CommonAuthorizationUrlRequest\";\r\nimport { CommonAuthorizationCodeRequest } from \"../request/CommonAuthorizationCodeRequest\";\r\nimport { Authority } from \"../authority/Authority\";\r\nimport { RequestParameterBuilder } from \"../request/RequestParameterBuilder\";\r\nimport { GrantType, AuthenticationScheme, PromptValue, Separators } from \"../utils/Constants\";\r\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\r\nimport { ServerAuthorizationTokenResponse } from \"../response/ServerAuthorizationTokenResponse\";\r\nimport { NetworkResponse } from \"../network/NetworkManager\";\r\nimport { ResponseHandler } from \"../response/ResponseHandler\";\r\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { UrlString } from \"../url/UrlString\";\r\nimport { ServerAuthorizationCodeResponse } from \"../response/ServerAuthorizationCodeResponse\";\r\nimport { AccountEntity } from \"../cache/entities/AccountEntity\";\r\nimport { CommonEndSessionRequest } from \"../request/CommonEndSessionRequest\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator\";\r\nimport { RequestThumbprint } from \"../network/RequestThumbprint\";\r\nimport { AuthorizationCodePayload } from \"../response/AuthorizationCodePayload\";\r\nimport { TimeUtils } from \"../utils/TimeUtils\";\r\nimport { TokenClaims } from \"../account/TokenClaims\";\r\nimport { AccountInfo } from \"../account/AccountInfo\";\r\nimport { buildClientInfoFromHomeAccountId, buildClientInfo } from \"../account/ClientInfo\";\r\nimport { CcsCredentialType, CcsCredential } from \"../account/CcsCredential\";\r\n\r\n/**\r\n * Oauth2.0 Authorization Code client\r\n */\r\nexport class AuthorizationCodeClient extends BaseClient {\r\n\r\n    constructor(configuration: ClientConfiguration) {\r\n        super(configuration);\r\n    }\r\n\r\n    /**\r\n     * Creates the URL of the authorization request letting the user input credentials and consent to the\r\n     * application. The URL target the /authorize endpoint of the authority configured in the\r\n     * application object.\r\n     *\r\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n     * acquireToken(AuthorizationCodeRequest)\r\n     * @param request\r\n     */\r\n    async getAuthCodeUrl(request: CommonAuthorizationUrlRequest): Promise<string> {\r\n        const queryString = this.createAuthCodeUrlQueryString(request);\r\n\r\n        return UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString);\r\n    }\r\n\r\n    /**\r\n     * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\r\n     * authorization_code_grant\r\n     * @param request\r\n     */\r\n    async acquireToken(request: CommonAuthorizationCodeRequest, authCodePayload?: AuthorizationCodePayload): Promise<AuthenticationResult> {\r\n        this.logger.info(\"in acquireToken call\");\r\n        if (!request || StringUtils.isEmpty(request.code)) {\r\n            throw ClientAuthError.createTokenRequestCannotBeMadeError();\r\n        }\r\n\r\n        const reqTimestamp = TimeUtils.nowSeconds();\r\n        const response = await this.executeTokenRequest(this.authority, request);\r\n\r\n        const responseHandler = new ResponseHandler(\r\n            this.config.authOptions.clientId,\r\n            this.cacheManager,\r\n            this.cryptoUtils,\r\n            this.logger,\r\n            this.config.serializableCache,\r\n            this.config.persistencePlugin\r\n        );\r\n\r\n        // Validate response. This function throws a server error if an error is returned by the server.\r\n        responseHandler.validateTokenResponse(response.body);\r\n        return await responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, authCodePayload);\r\n    }\r\n\r\n    /**\r\n     * Handles the hash fragment response from public client code request. Returns a code response used by\r\n     * the client to exchange for a token in acquireToken.\r\n     * @param hashFragment\r\n     */\r\n    handleFragmentResponse(hashFragment: string, cachedState: string): AuthorizationCodePayload {\r\n        // Handle responses.\r\n        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);\r\n\r\n        // Deserialize hash fragment response parameters.\r\n        const hashUrlString = new UrlString(hashFragment);\r\n        // Deserialize hash fragment response parameters.\r\n        const serverParams: ServerAuthorizationCodeResponse = UrlString.getDeserializedHash(hashUrlString.getHash());\r\n\r\n        // Get code response\r\n        responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils);\r\n\r\n        // throw when there is no auth code in the response\r\n        if (!serverParams.code) {\r\n            throw ClientAuthError.createNoAuthCodeInServerResponseError();\r\n        }\r\n        return {\r\n            ...serverParams,\r\n            // Code param is optional in ServerAuthorizationCodeResponse but required in AuthorizationCodePaylod\r\n            code: serverParams.code\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n     * Default behaviour is to redirect the user to `window.location.href`.\r\n     * @param authorityUri\r\n     */\r\n    getLogoutUri(logoutRequest: CommonEndSessionRequest): string {\r\n        // Throw error if logoutRequest is null/undefined\r\n        if (!logoutRequest) {\r\n            throw ClientConfigurationError.createEmptyLogoutRequestError();\r\n        }\r\n\r\n        if (logoutRequest.account) {\r\n            // Clear given account.\r\n            this.cacheManager.removeAccount(AccountEntity.generateAccountCacheKey(logoutRequest.account));\r\n        } else {\r\n            // Clear all accounts and tokens\r\n            this.cacheManager.clear();\r\n        }\r\n\r\n        const queryString = this.createLogoutUrlQueryString(logoutRequest);\r\n\r\n        // Construct logout URI.\r\n        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);\r\n    }\r\n\r\n    /**\r\n     * Executes POST request to token endpoint\r\n     * @param authority\r\n     * @param request\r\n     */\r\n    private async executeTokenRequest(authority: Authority, request: CommonAuthorizationCodeRequest): Promise<NetworkResponse<ServerAuthorizationTokenResponse>> {\r\n        const thumbprint: RequestThumbprint = {\r\n            clientId: this.config.authOptions.clientId,\r\n            authority: authority.canonicalAuthority,\r\n            scopes: request.scopes\r\n        };\r\n\r\n        const requestBody = await this.createTokenRequestBody(request);\r\n        const queryParameters = this.createTokenQueryParameters(request);\r\n        let ccsCredential: CcsCredential | undefined = undefined;\r\n        if (request.clientInfo) {\r\n            try {\r\n                const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\r\n                ccsCredential = {\r\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\r\n                    type: CcsCredentialType.HOME_ACCOUNT_ID\r\n                };\r\n            } catch (e) {\r\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\r\n            }\r\n        }\r\n        const headers: Record<string, string> = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);\r\n        const endpoint = StringUtils.isEmpty(queryParameters) ? authority.tokenEndpoint : `${authority.tokenEndpoint}?${queryParameters}`;\r\n\r\n        return this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint);\r\n    }\r\n\r\n    /**\r\n     * Creates query string for the /token request\r\n     * @param request \r\n     */\r\n    private createTokenQueryParameters(request: CommonAuthorizationCodeRequest): string {\r\n        const parameterBuilder = new RequestParameterBuilder();\r\n\r\n        if (request.tokenQueryParameters) {\r\n            parameterBuilder.addExtraQueryParameters(request.tokenQueryParameters);\r\n        }\r\n\r\n        return parameterBuilder.createQueryString();\r\n    }\r\n\r\n    /**\r\n     * Generates a map for all the params to be sent to the service\r\n     * @param request\r\n     */\r\n    private async createTokenRequestBody(request: CommonAuthorizationCodeRequest): Promise<string> {\r\n        const parameterBuilder = new RequestParameterBuilder();\r\n\r\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\r\n\r\n        // validate the redirectUri (to be a non null value)\r\n        parameterBuilder.addRedirectUri(request.redirectUri);\r\n\r\n        // Add scope array, parameter builder will add default scopes and dedupe\r\n        parameterBuilder.addScopes(request.scopes);\r\n\r\n        // add code: user set, not validated\r\n        parameterBuilder.addAuthorizationCode(request.code);\r\n\r\n        // Add library metadata\r\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\r\n\r\n        parameterBuilder.addThrottling();\r\n        \r\n        if (this.serverTelemetryManager) {\r\n            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\r\n        }\r\n\r\n        // add code_verifier if passed\r\n        if (request.codeVerifier) {\r\n            parameterBuilder.addCodeVerifier(request.codeVerifier);\r\n        }\r\n\r\n        if (this.config.clientCredentials.clientSecret) {\r\n            parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\r\n        }\r\n\r\n        if (this.config.clientCredentials.clientAssertion) {\r\n            const clientAssertion = this.config.clientCredentials.clientAssertion;\r\n            parameterBuilder.addClientAssertion(clientAssertion.assertion);\r\n            parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\r\n        }\r\n\r\n        parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\r\n        parameterBuilder.addClientInfo();\r\n\r\n        if (request.authenticationScheme === AuthenticationScheme.POP) {\r\n            const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);\r\n            const cnfString = await popTokenGenerator.generateCnf(request);\r\n            parameterBuilder.addPopToken(cnfString);\r\n        }\r\n\r\n        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\r\n        parameterBuilder.addCorrelationId(correlationId);\r\n\r\n        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\r\n            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\r\n        }\r\n        \r\n        let ccsCred: CcsCredential | undefined = undefined;\r\n        if (request.clientInfo) {\r\n            try {\r\n                const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\r\n                ccsCred = {\r\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\r\n                    type: CcsCredentialType.HOME_ACCOUNT_ID\r\n                };\r\n            } catch (e) {\r\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\r\n            }\r\n        } else {\r\n            ccsCred = request.ccsCredential;\r\n        }\r\n\r\n        // Adds these as parameters in the request instead of headers to prevent CORS preflight request\r\n        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\r\n            switch (ccsCred.type) {\r\n                case CcsCredentialType.HOME_ACCOUNT_ID:\r\n                    try {\r\n                        const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\r\n                        parameterBuilder.addCcsOid(clientInfo);\r\n                    } catch (e) {\r\n                        this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\r\n                    }\r\n                    break;\r\n                case CcsCredentialType.UPN:\r\n                    parameterBuilder.addCcsUpn(ccsCred.credential);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return parameterBuilder.createQueryString();\r\n    }\r\n\r\n    /**\r\n     * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\r\n     * @param request\r\n     */\r\n    private createAuthCodeUrlQueryString(request: CommonAuthorizationUrlRequest): string {\r\n        const parameterBuilder = new RequestParameterBuilder();\r\n\r\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\r\n\r\n        const requestScopes = [...request.scopes || [], ...request.extraScopesToConsent || []];\r\n        parameterBuilder.addScopes(requestScopes);\r\n\r\n        // validate the redirectUri (to be a non null value)\r\n        parameterBuilder.addRedirectUri(request.redirectUri);\r\n\r\n        // generate the correlationId if not set by the user and add\r\n        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\r\n        parameterBuilder.addCorrelationId(correlationId);\r\n\r\n        // add response_mode. If not passed in it defaults to query.\r\n        parameterBuilder.addResponseMode(request.responseMode);\r\n\r\n        // add response_type = code\r\n        parameterBuilder.addResponseTypeCode();\r\n\r\n        // add library info parameters\r\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\r\n\r\n        // add client_info=1\r\n        parameterBuilder.addClientInfo();\r\n\r\n        if (request.codeChallenge && request.codeChallengeMethod) {\r\n            parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);\r\n        }\r\n\r\n        if (request.prompt) {\r\n            parameterBuilder.addPrompt(request.prompt);\r\n        }\r\n\r\n        if (request.domainHint) {\r\n            parameterBuilder.addDomainHint(request.domainHint);\r\n        }\r\n\r\n        // Add sid or loginHint with preference for sid -> loginHint -> username of AccountInfo object\r\n        if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\r\n            // AAD will throw if prompt=select_account is passed with an account hint\r\n            if (request.sid && request.prompt === PromptValue.NONE) {\r\n                // SessionID is only used in silent calls\r\n                this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\");\r\n                parameterBuilder.addSid(request.sid);\r\n            } else if (request.account) {\r\n                const accountSid = this.extractAccountSid(request.account);\r\n                // If account and loginHint are provided, we will check account first for sid before adding loginHint\r\n                if (accountSid && request.prompt === PromptValue.NONE) {\r\n                    // SessionId is only used in silent calls\r\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\");\r\n                    parameterBuilder.addSid(accountSid);\r\n                    try {\r\n                        const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\r\n                        parameterBuilder.addCcsOid(clientInfo);\r\n                    } catch (e) {\r\n                        this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\r\n                    }\r\n                } else if (request.loginHint) {\r\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from request\");\r\n                    parameterBuilder.addLoginHint(request.loginHint);\r\n                    parameterBuilder.addCcsUpn(request.loginHint);\r\n                } else if (request.account.username) {\r\n                    // Fallback to account username if provided\r\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from account\");\r\n                    parameterBuilder.addLoginHint(request.account.username);\r\n                    try {\r\n                        const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\r\n                        parameterBuilder.addCcsOid(clientInfo);\r\n                    } catch (e) {\r\n                        this.logger.verbose(\"Could not parse home account ID for CCS Header: \" +  e);\r\n                    }\r\n                }\r\n            } else if (request.loginHint) {\r\n                this.logger.verbose(\"createAuthCodeUrlQueryString: No account, adding login_hint from request\");\r\n                parameterBuilder.addLoginHint(request.loginHint);\r\n                parameterBuilder.addCcsUpn(request.loginHint);\r\n            }\r\n        } else {\r\n            this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\");\r\n        }\r\n\r\n        if (request.nonce) {\r\n            parameterBuilder.addNonce(request.nonce);\r\n        }\r\n\r\n        if (request.state) {\r\n            parameterBuilder.addState(request.state);\r\n        }\r\n\r\n        if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\r\n            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\r\n        }\r\n\r\n        if (request.extraQueryParameters) {\r\n            parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\r\n        }\r\n\r\n        return parameterBuilder.createQueryString();\r\n    }\r\n\r\n    /**\r\n     * This API validates the `EndSessionRequest` and creates a URL\r\n     * @param request\r\n     */\r\n    private createLogoutUrlQueryString(request: CommonEndSessionRequest): string {\r\n        const parameterBuilder = new RequestParameterBuilder();\r\n\r\n        if (request.postLogoutRedirectUri) {\r\n            parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);\r\n        }\r\n\r\n        if (request.correlationId) {\r\n            parameterBuilder.addCorrelationId(request.correlationId);\r\n        }\r\n\r\n        if (request.idTokenHint) {\r\n            parameterBuilder.addIdTokenHint(request.idTokenHint);\r\n        }\r\n\r\n        return parameterBuilder.createQueryString();\r\n    }\r\n\r\n    /**\r\n     * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\r\n     * @param account \r\n     */\r\n    private extractAccountSid(account: AccountInfo): string | null {\r\n        if (account.idTokenClaims) {\r\n            const tokenClaims = account.idTokenClaims as TokenClaims;\r\n            return tokenClaims.sid || null;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}