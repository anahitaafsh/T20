{"ast":null,"code":"/*! @azure/msal-common v4.5.0 2021-07-22 */\n'use strict';\n\nimport { Separators, CacheAccountType, CacheType, Constants as Constants$1 } from '../../utils/Constants.js';\nimport { ClientAuthError as ClientAuthError$1 } from '../../error/ClientAuthError.js';\nimport { StringUtils as StringUtils$1 } from '../../utils/StringUtils.js';\nimport { buildClientInfo } from '../../account/ClientInfo.js';\nimport { AuthorityType as AuthorityType$1 } from '../../authority/AuthorityType.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\r\n *\r\n * Key : Value Schema\r\n *\r\n * Key: <home_account_id>-<environment>-<realm*>\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\r\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\r\n *      authorityType: Accounts authority type as a string\r\n *      name: Full name for the account, including given name and family name,\r\n *      clientInfo: Full base64 encoded client info received from ESTS\r\n *      lastModificationTime: last time this entity was modified in the cache\r\n *      lastModificationApp:\r\n *      oboAssertion: access token passed in as part of OBO request\r\n *      idTokenClaims: Object containing claims parsed from ID token\r\n * }\r\n */\n\nvar AccountEntity =\n/** @class */\nfunction () {\n  function AccountEntity() {}\n  /**\r\n   * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n   */\n\n\n  AccountEntity.prototype.generateAccountId = function () {\n    var accountId = [this.homeAccountId, this.environment];\n    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>\r\n   */\n\n\n  AccountEntity.prototype.generateAccountKey = function () {\n    return AccountEntity.generateAccountCacheKey({\n      homeAccountId: this.homeAccountId,\n      environment: this.environment,\n      tenantId: this.realm,\n      username: this.username,\n      localAccountId: this.localAccountId\n    });\n  };\n  /**\r\n   * returns the type of the cache (in this case account)\r\n   */\n\n\n  AccountEntity.prototype.generateType = function () {\n    switch (this.authorityType) {\n      case CacheAccountType.ADFS_ACCOUNT_TYPE:\n        return CacheType.ADFS;\n\n      case CacheAccountType.MSAV1_ACCOUNT_TYPE:\n        return CacheType.MSA;\n\n      case CacheAccountType.MSSTS_ACCOUNT_TYPE:\n        return CacheType.MSSTS;\n\n      case CacheAccountType.GENERIC_ACCOUNT_TYPE:\n        return CacheType.GENERIC;\n\n      default:\n        {\n          throw ClientAuthError$1.createUnexpectedAccountTypeError();\n        }\n    }\n  };\n  /**\r\n   * Returns the AccountInfo interface for this account.\r\n   */\n\n\n  AccountEntity.prototype.getAccountInfo = function () {\n    return {\n      homeAccountId: this.homeAccountId,\n      environment: this.environment,\n      tenantId: this.realm,\n      username: this.username,\n      localAccountId: this.localAccountId,\n      name: this.name,\n      idTokenClaims: this.idTokenClaims\n    };\n  };\n  /**\r\n   * Generates account key from interface\r\n   * @param accountInterface\r\n   */\n\n\n  AccountEntity.generateAccountCacheKey = function (accountInterface) {\n    var accountKey = [accountInterface.homeAccountId, accountInterface.environment || \"\", accountInterface.tenantId || \"\"];\n    return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.\r\n   * @param clientInfo\r\n   * @param authority\r\n   * @param idToken\r\n   * @param policy\r\n   */\n\n\n  AccountEntity.createAccount = function (clientInfo, homeAccountId, authority, idToken, oboAssertion, cloudGraphHostName, msGraphHost) {\n    var _a, _b, _c, _d, _e, _f;\n\n    var account = new AccountEntity();\n    account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\n    account.clientInfo = clientInfo;\n    account.homeAccountId = homeAccountId;\n    var env = authority.getPreferredCache();\n\n    if (StringUtils$1.isEmpty(env)) {\n      throw ClientAuthError$1.createInvalidCacheEnvironmentError();\n    }\n\n    account.environment = env; // non AAD scenarios can have empty realm\n\n    account.realm = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.tid) || \"\";\n    account.oboAssertion = oboAssertion;\n\n    if (idToken) {\n      account.idTokenClaims = idToken.claims; // How do you account for MSA CID here?\n\n      account.localAccountId = ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.oid) || ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.sub) || \"\";\n      /*\r\n       * In B2C scenarios the emails claim is used instead of preferred_username and it is an array. In most cases it will contain a single email.\r\n       * This field should not be relied upon if a custom policy is configured to return more than 1 email.\r\n       */\n\n      account.username = ((_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.preferred_username) || (((_e = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _e === void 0 ? void 0 : _e.emails) ? idToken.claims.emails[0] : \"\");\n      account.name = (_f = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _f === void 0 ? void 0 : _f.name;\n    }\n\n    account.cloudGraphHostName = cloudGraphHostName;\n    account.msGraphHost = msGraphHost;\n    return account;\n  };\n  /**\r\n   * Builds non-AAD/ADFS account.\r\n   * @param authority\r\n   * @param idToken\r\n   */\n\n\n  AccountEntity.createGenericAccount = function (authority, homeAccountId, idToken, oboAssertion, cloudGraphHostName, msGraphHost) {\n    var _a, _b, _c, _d;\n\n    var account = new AccountEntity();\n    account.authorityType = authority.authorityType === AuthorityType$1.Adfs ? CacheAccountType.ADFS_ACCOUNT_TYPE : CacheAccountType.GENERIC_ACCOUNT_TYPE;\n    account.homeAccountId = homeAccountId; // non AAD scenarios can have empty realm\n\n    account.realm = \"\";\n    account.oboAssertion = oboAssertion;\n    var env = authority.getPreferredCache();\n\n    if (StringUtils$1.isEmpty(env)) {\n      throw ClientAuthError$1.createInvalidCacheEnvironmentError();\n    }\n\n    if (idToken) {\n      // How do you account for MSA CID here?\n      account.localAccountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.oid) || ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.sub) || \"\"; // upn claim for most ADFS scenarios\n\n      account.username = ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.upn) || \"\";\n      account.name = ((_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.name) || \"\";\n      account.idTokenClaims = idToken === null || idToken === void 0 ? void 0 : idToken.claims;\n    }\n\n    account.environment = env;\n    account.cloudGraphHostName = cloudGraphHostName;\n    account.msGraphHost = msGraphHost;\n    /*\r\n     * add uniqueName to claims\r\n     * account.name = idToken.claims.uniqueName;\r\n     */\n\n    return account;\n  };\n  /**\r\n   * Generate HomeAccountId from server response\r\n   * @param serverClientInfo\r\n   * @param authType\r\n   */\n\n\n  AccountEntity.generateHomeAccountId = function (serverClientInfo, authType, logger, cryptoObj, idToken) {\n    var _a;\n\n    var accountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.sub) ? idToken.claims.sub : Constants$1.EMPTY_STRING; // since ADFS does not have tid and does not set client_info\n\n    if (authType === AuthorityType$1.Adfs) {\n      return accountId;\n    } // for cases where there is clientInfo\n\n\n    if (serverClientInfo) {\n      try {\n        var clientInfo = buildClientInfo(serverClientInfo, cryptoObj);\n\n        if (!StringUtils$1.isEmpty(clientInfo.uid) && !StringUtils$1.isEmpty(clientInfo.utid)) {\n          return \"\" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid;\n        }\n      } catch (e) {}\n    } // default to \"sub\" claim\n\n\n    logger.verbose(\"No client info in response\");\n    return accountId;\n  };\n  /**\r\n   * Validates an entity: checks for all expected params\r\n   * @param entity\r\n   */\n\n\n  AccountEntity.isAccountEntity = function (entity) {\n    if (!entity) {\n      return false;\n    }\n\n    return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"localAccountId\") && entity.hasOwnProperty(\"username\") && entity.hasOwnProperty(\"authorityType\");\n  };\n  /**\r\n   * Helper function to determine whether 2 accountInfo objects represent the same account\r\n   * @param accountA\r\n   * @param accountB\r\n   * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality\r\n   */\n\n\n  AccountEntity.accountInfoIsEqual = function (accountA, accountB, compareClaims) {\n    if (!accountA || !accountB) {\n      return false;\n    }\n\n    var claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false\n\n    if (compareClaims) {\n      var accountAClaims = accountA.idTokenClaims || {};\n      var accountBClaims = accountB.idTokenClaims || {}; // issued at timestamp and nonce are expected to change each time a new id token is acquired\n\n      claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;\n    }\n\n    return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.environment === accountB.environment && claimsMatch;\n  };\n\n  return AccountEntity;\n}();\n\nexport { AccountEntity };","map":{"version":3,"mappings":"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","names":["AccountEntity","accountId","homeAccountId","environment","join","Separators","CACHE_KEY_SEPARATOR","toLowerCase","generateAccountCacheKey","tenantId","realm","username","localAccountId","authorityType","CacheAccountType","ADFS_ACCOUNT_TYPE","CacheType","ADFS","MSAV1_ACCOUNT_TYPE","MSA","MSSTS_ACCOUNT_TYPE","MSSTS","GENERIC_ACCOUNT_TYPE","GENERIC","ClientAuthError","createUnexpectedAccountTypeError","name","idTokenClaims","accountInterface","accountKey","clientInfo","authority","idToken","oboAssertion","cloudGraphHostName","msGraphHost","account","env","getPreferredCache","StringUtils","isEmpty","createInvalidCacheEnvironmentError","claims","_a","tid","_b","oid","_c","sub","_d","preferred_username","_e","emails","_f","AuthorityType","Adfs","upn","serverClientInfo","authType","logger","cryptoObj","Constants","EMPTY_STRING","buildClientInfo","uid","utid","CLIENT_INFO_SEPARATOR","e","verbose","entity","hasOwnProperty","accountA","accountB","compareClaims","claimsMatch","accountAClaims","accountBClaims","iat","nonce"],"sources":["../../../src/cache/entities/AccountEntity.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    Separators,\r\n    CacheAccountType,\r\n    CacheType,\r\n    Constants,\r\n} from \"../../utils/Constants\";\r\nimport { Authority } from \"../../authority/Authority\";\r\nimport { AuthToken } from \"../../account/AuthToken\";\r\nimport { ICrypto } from \"../../crypto/ICrypto\";\r\nimport { buildClientInfo } from \"../../account/ClientInfo\";\r\nimport { StringUtils } from \"../../utils/StringUtils\";\r\nimport { AccountInfo } from \"../../account/AccountInfo\";\r\nimport { ClientAuthError } from \"../../error/ClientAuthError\";\r\nimport { AuthorityType } from \"../../authority/AuthorityType\";\r\nimport { Logger } from \"../../logger/Logger\";\r\nimport { TokenClaims } from \"../../account/TokenClaims\";\r\n\r\n/**\r\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\r\n *\r\n * Key : Value Schema\r\n *\r\n * Key: <home_account_id>-<environment>-<realm*>\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\r\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\r\n *      authorityType: Accounts authority type as a string\r\n *      name: Full name for the account, including given name and family name,\r\n *      clientInfo: Full base64 encoded client info received from ESTS\r\n *      lastModificationTime: last time this entity was modified in the cache\r\n *      lastModificationApp:\r\n *      oboAssertion: access token passed in as part of OBO request\r\n *      idTokenClaims: Object containing claims parsed from ID token\r\n * }\r\n */\r\nexport class AccountEntity {\r\n    homeAccountId: string;\r\n    environment: string;\r\n    realm: string;\r\n    localAccountId: string;\r\n    username: string;\r\n    authorityType: string;\r\n    name?: string;\r\n    clientInfo?: string;\r\n    lastModificationTime?: string;\r\n    lastModificationApp?: string;\r\n    oboAssertion?: string;\r\n    cloudGraphHostName?: string;\r\n    msGraphHost?: string; \r\n    idTokenClaims?: TokenClaims;\r\n\r\n    /**\r\n     * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n     */\r\n    generateAccountId(): string {\r\n        const accountId: Array<string> = [this.homeAccountId, this.environment];\r\n        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>\r\n     */\r\n    generateAccountKey(): string {\r\n        return AccountEntity.generateAccountCacheKey({\r\n            homeAccountId: this.homeAccountId,\r\n            environment: this.environment,\r\n            tenantId: this.realm,\r\n            username: this.username,\r\n            localAccountId: this.localAccountId\r\n        });\r\n    }\r\n\r\n    /**\r\n     * returns the type of the cache (in this case account)\r\n     */\r\n    generateType(): number {\r\n        switch (this.authorityType) {\r\n            case CacheAccountType.ADFS_ACCOUNT_TYPE:\r\n                return CacheType.ADFS;\r\n            case CacheAccountType.MSAV1_ACCOUNT_TYPE:\r\n                return CacheType.MSA;\r\n            case CacheAccountType.MSSTS_ACCOUNT_TYPE:\r\n                return CacheType.MSSTS;\r\n            case CacheAccountType.GENERIC_ACCOUNT_TYPE:\r\n                return CacheType.GENERIC;\r\n            default: {\r\n                throw ClientAuthError.createUnexpectedAccountTypeError();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the AccountInfo interface for this account.\r\n     */\r\n    getAccountInfo(): AccountInfo {\r\n        return {\r\n            homeAccountId: this.homeAccountId,\r\n            environment: this.environment,\r\n            tenantId: this.realm,\r\n            username: this.username,\r\n            localAccountId: this.localAccountId,\r\n            name: this.name,\r\n            idTokenClaims: this.idTokenClaims\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Generates account key from interface\r\n     * @param accountInterface\r\n     */\r\n    static generateAccountCacheKey(accountInterface: AccountInfo): string {\r\n        const accountKey = [\r\n            accountInterface.homeAccountId,\r\n            accountInterface.environment || \"\",\r\n            accountInterface.tenantId || \"\",\r\n        ];\r\n\r\n        return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.\r\n     * @param clientInfo\r\n     * @param authority\r\n     * @param idToken\r\n     * @param policy\r\n     */\r\n    static createAccount(\r\n        clientInfo: string,\r\n        homeAccountId: string,\r\n        authority: Authority,\r\n        idToken: AuthToken,\r\n        oboAssertion?: string,\r\n        cloudGraphHostName?: string,\r\n        msGraphHost?: string\r\n    ): AccountEntity {\r\n        const account: AccountEntity = new AccountEntity();\r\n\r\n        account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\r\n        account.clientInfo = clientInfo;\r\n        account.homeAccountId = homeAccountId;\r\n\r\n        const env = authority.getPreferredCache();\r\n        if (StringUtils.isEmpty(env)) {\r\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\r\n        }\r\n\r\n        account.environment = env;\r\n        // non AAD scenarios can have empty realm\r\n        account.realm = idToken?.claims?.tid || \"\";\r\n        account.oboAssertion = oboAssertion;\r\n        \r\n        if (idToken) {\r\n            account.idTokenClaims = idToken.claims;\r\n\r\n            // How do you account for MSA CID here?\r\n            account.localAccountId = idToken?.claims?.oid || idToken?.claims?.sub || \"\";\r\n\r\n            /*\r\n             * In B2C scenarios the emails claim is used instead of preferred_username and it is an array. In most cases it will contain a single email.\r\n             * This field should not be relied upon if a custom policy is configured to return more than 1 email.\r\n             */\r\n            account.username = idToken?.claims?.preferred_username || (idToken?.claims?.emails? idToken.claims.emails[0]: \"\");\r\n            account.name = idToken?.claims?.name;\r\n        }\r\n\r\n        account.cloudGraphHostName = cloudGraphHostName;\r\n        account.msGraphHost = msGraphHost;\r\n\r\n        return account;\r\n    }\r\n\r\n    /**\r\n     * Builds non-AAD/ADFS account.\r\n     * @param authority\r\n     * @param idToken\r\n     */\r\n    static createGenericAccount(\r\n        authority: Authority,\r\n        homeAccountId: string,\r\n        idToken: AuthToken,\r\n        oboAssertion?: string,\r\n        cloudGraphHostName?: string,\r\n        msGraphHost?: string\r\n    ): AccountEntity {\r\n        const account: AccountEntity = new AccountEntity();\r\n\r\n        account.authorityType = (authority.authorityType === AuthorityType.Adfs) ? CacheAccountType.ADFS_ACCOUNT_TYPE : CacheAccountType.GENERIC_ACCOUNT_TYPE;\r\n        account.homeAccountId = homeAccountId;\r\n        // non AAD scenarios can have empty realm\r\n        account.realm = \"\";\r\n        account.oboAssertion = oboAssertion;\r\n\r\n        const env = authority.getPreferredCache();\r\n\r\n        if (StringUtils.isEmpty(env)) {\r\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\r\n        }\r\n\r\n        if (idToken) {\r\n            // How do you account for MSA CID here?\r\n            account.localAccountId = idToken?.claims?.oid || idToken?.claims?.sub || \"\";\r\n            // upn claim for most ADFS scenarios\r\n            account.username = idToken?.claims?.upn || \"\";\r\n            account.name = idToken?.claims?.name || \"\";\r\n            account.idTokenClaims = idToken?.claims;\r\n        }\r\n\r\n        account.environment = env;\r\n\r\n        account.cloudGraphHostName = cloudGraphHostName;\r\n        account.msGraphHost = msGraphHost;\r\n\r\n        /*\r\n         * add uniqueName to claims\r\n         * account.name = idToken.claims.uniqueName;\r\n         */\r\n\r\n        return account;\r\n    }\r\n\r\n    /**\r\n     * Generate HomeAccountId from server response\r\n     * @param serverClientInfo\r\n     * @param authType\r\n     */\r\n    static generateHomeAccountId(serverClientInfo: string, authType: AuthorityType, logger: Logger, cryptoObj: ICrypto, idToken?: AuthToken): string {\r\n\r\n        const accountId = idToken?.claims?.sub ? idToken.claims.sub : Constants.EMPTY_STRING;\r\n\r\n        // since ADFS does not have tid and does not set client_info\r\n        if (authType === AuthorityType.Adfs) {\r\n            return accountId;\r\n        }\r\n\r\n        // for cases where there is clientInfo\r\n        if (serverClientInfo) {\r\n            try {\r\n                const clientInfo = buildClientInfo(serverClientInfo, cryptoObj);\r\n                if (!StringUtils.isEmpty(clientInfo.uid) && !StringUtils.isEmpty(clientInfo.utid)) {\r\n                    return `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`;\r\n                }\r\n            } catch (e) {}\r\n        }\r\n\r\n        // default to \"sub\" claim\r\n        logger.verbose(\"No client info in response\");\r\n        return accountId;\r\n    }\r\n\r\n    /**\r\n     * Validates an entity: checks for all expected params\r\n     * @param entity\r\n     */\r\n    static isAccountEntity(entity: object): boolean {\r\n\r\n        if (!entity) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            entity.hasOwnProperty(\"homeAccountId\") &&\r\n            entity.hasOwnProperty(\"environment\") &&\r\n            entity.hasOwnProperty(\"realm\") &&\r\n            entity.hasOwnProperty(\"localAccountId\") &&\r\n            entity.hasOwnProperty(\"username\") &&\r\n            entity.hasOwnProperty(\"authorityType\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Helper function to determine whether 2 accountInfo objects represent the same account\r\n     * @param accountA \r\n     * @param accountB \r\n     * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality\r\n     */\r\n    static accountInfoIsEqual(accountA: AccountInfo | null, accountB: AccountInfo | null, compareClaims?: boolean): boolean {\r\n        if (!accountA || !accountB) {\r\n            return false;\r\n        }\r\n\r\n        let claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false\r\n        if (compareClaims) {\r\n            const accountAClaims = (accountA.idTokenClaims || {}) as TokenClaims;\r\n            const accountBClaims = (accountB.idTokenClaims || {}) as TokenClaims;\r\n\r\n            // issued at timestamp and nonce are expected to change each time a new id token is acquired\r\n            claimsMatch = (accountAClaims.iat === accountBClaims.iat) &&\r\n            (accountAClaims.nonce === accountBClaims.nonce);\r\n        }\r\n\r\n        return (accountA.homeAccountId === accountB.homeAccountId) && \r\n            (accountA.localAccountId === accountB.localAccountId) &&\r\n            (accountA.username === accountB.username) &&\r\n            (accountA.tenantId === accountB.tenantId) &&\r\n            (accountA.environment === accountB.environment) &&\r\n            claimsMatch;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}