{"ast":null,"code":"/*! @azure/msal-browser v2.29.0 2022-10-03 */\n'use strict';\n\nimport { __awaiter, __generator, __assign } from '../_virtual/_tslib.js';\nimport { CryptoOps } from '../crypto/CryptoOps.js';\nimport { Constants, InteractionRequiredAuthError, PerformanceEvents, AuthError, ClientAuthError, StringUtils, PromptValue, Logger, StubPerformanceClient, DEFAULT_CRYPTO_IMPLEMENTATION } from '@azure/msal-common';\nimport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER } from '../cache/BrowserCacheManager.js';\nimport { buildConfiguration } from '../config/Configuration.js';\nimport { InteractionType, ApiId, TemporaryCacheKeys, CacheLookupPolicy, BrowserCacheLocation } from '../utils/BrowserConstants.js';\nimport { BrowserUtils } from '../utils/BrowserUtils.js';\nimport { name, version } from '../packageMetadata.js';\nimport { EventType } from '../event/EventType.js';\nimport { BrowserConfigurationAuthError } from '../error/BrowserConfigurationAuthError.js';\nimport { EventHandler } from '../event/EventHandler.js';\nimport { PopupClient } from '../interaction_client/PopupClient.js';\nimport { RedirectClient } from '../interaction_client/RedirectClient.js';\nimport { SilentIframeClient } from '../interaction_client/SilentIframeClient.js';\nimport { SilentRefreshClient } from '../interaction_client/SilentRefreshClient.js';\nimport { TokenCache } from '../cache/TokenCache.js';\nimport { NativeInteractionClient } from '../interaction_client/NativeInteractionClient.js';\nimport { NativeMessageHandler } from '../broker/nativeBroker/NativeMessageHandler.js';\nimport { NativeAuthError } from '../error/NativeAuthError.js';\nimport { SilentCacheClient } from '../interaction_client/SilentCacheClient.js';\nimport { SilentAuthCodeClient } from '../interaction_client/SilentAuthCodeClient.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { BrowserPerformanceClient } from '../telemetry/BrowserPerformanceClient.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar ClientApplication =\n/** @class */\nfunction () {\n  /**\r\n   * @constructor\r\n   * Constructor for the PublicClientApplication used to instantiate the PublicClientApplication object\r\n   *\r\n   * Important attributes in the Configuration object for auth are:\r\n   * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview\r\n   * - authority: the authority URL for your application.\r\n   * - redirect_uri: the uri of your application registered in the portal.\r\n   *\r\n   * In Azure AD, authority is a URL indicating the Azure active directory that MSAL uses to obtain tokens.\r\n   * It is of the form https://login.microsoftonline.com/{Enter_the_Tenant_Info_Here}\r\n   * If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\r\n   * If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\r\n   * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\r\n   * To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\r\n   *\r\n   * In Azure B2C, authority is of the form https://{instance}/tfp/{tenant}/{policyName}/\r\n   * Full B2C functionality will be available in this library in future versions.\r\n   *\r\n   * @param configuration Object for the MSAL PublicClientApplication instance\r\n   */\n  function ClientApplication(configuration) {\n    /*\r\n     * If loaded in an environment where window is not available,\r\n     * set internal flag to false so that further requests fail.\r\n     * This is to support server-side rendering environments.\r\n     */\n    this.isBrowserEnvironment = typeof window !== \"undefined\"; // Set the configuration.\n\n    this.config = buildConfiguration(configuration, this.isBrowserEnvironment);\n    this.initialized = false; // Initialize logger\n\n    this.logger = new Logger(this.config.system.loggerOptions, name, version); // Initialize the network module class.\n\n    this.networkClient = this.config.system.networkClient; // Initialize the navigation client class.\n\n    this.navigationClient = this.config.system.navigationClient; // Initialize redirectResponse Map\n\n    this.redirectResponse = new Map(); // Initial hybrid spa map\n\n    this.hybridAuthCodeResponses = new Map(); // Initialize performance client\n\n    this.performanceClient = this.isBrowserEnvironment ? new BrowserPerformanceClient(this.config.auth.clientId, this.config.auth.authority, this.logger, name, version, this.config.telemetry.application, this.config.system.cryptoOptions) : new StubPerformanceClient(this.config.auth.clientId, this.config.auth.authority, this.logger, name, version, this.config.telemetry.application); // Initialize the crypto class.\n\n    this.browserCrypto = this.isBrowserEnvironment ? new CryptoOps(this.logger, this.performanceClient, this.config.system.cryptoOptions) : DEFAULT_CRYPTO_IMPLEMENTATION;\n    this.eventHandler = new EventHandler(this.logger, this.browserCrypto); // Initialize the browser storage class.\n\n    this.browserStorage = this.isBrowserEnvironment ? new BrowserCacheManager(this.config.auth.clientId, this.config.cache, this.browserCrypto, this.logger) : DEFAULT_BROWSER_CACHE_MANAGER(this.config.auth.clientId, this.logger); // initialize in memory storage for native flows\n\n    var nativeCacheOptions = {\n      cacheLocation: BrowserCacheLocation.MemoryStorage,\n      storeAuthStateInCookie: false,\n      secureCookies: false\n    };\n    this.nativeInternalStorage = new BrowserCacheManager(this.config.auth.clientId, nativeCacheOptions, this.browserCrypto, this.logger); // Initialize the token cache\n\n    this.tokenCache = new TokenCache(this.config, this.browserStorage, this.logger, this.browserCrypto);\n  }\n  /**\r\n   * Initializer function to perform async startup tasks such as connecting to WAM extension\r\n   */\n\n\n  ClientApplication.prototype.initialize = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, e_1;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this.logger.trace(\"initialize called\");\n\n            if (this.initialized) {\n              this.logger.info(\"initialize has already been called, exiting early.\");\n              return [2\n              /*return*/\n              ];\n            }\n\n            this.eventHandler.emitEvent(EventType.INITIALIZE_START);\n            if (!this.config.system.allowNativeBroker) return [3\n            /*break*/\n            , 4];\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n\n            _a = this;\n            return [4\n            /*yield*/\n            , NativeMessageHandler.createProvider(this.logger, this.config.system.nativeBrokerHandshakeTimeout)];\n\n          case 2:\n            _a.nativeExtensionProvider = _b.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_1 = _b.sent();\n            this.logger.verbose(e_1);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            this.initialized = true;\n            this.eventHandler.emitEvent(EventType.INITIALIZE_END);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // #region Redirect Flow\n\n  /**\r\n   * Event handler function which allows users to fire events after the PublicClientApplication object\r\n   * has loaded during redirect flows. This should be invoked on all page loads involved in redirect\r\n   * auth flows.\r\n   * @param hash Hash to process. Defaults to the current value of window.location.hash. Only needs to be provided explicitly if the response to be handled is not contained in the current value.\r\n   * @returns Token response or null. If the return value is null, then no auth redirect was detected.\r\n   */\n\n\n  ClientApplication.prototype.handleRedirectPromise = function (hash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var loggedInAccounts, redirectResponseKey, response, request, redirectResponse, nativeClient, correlationId, redirectClient;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        this.logger.verbose(\"handleRedirectPromise called\"); // Block token acquisition before initialize has been called if native brokering is enabled\n\n        BrowserUtils.blockNativeBrokerCalledBeforeInitialized(this.config.system.allowNativeBroker, this.initialized);\n        loggedInAccounts = this.getAllAccounts();\n\n        if (this.isBrowserEnvironment) {\n          redirectResponseKey = hash || Constants.EMPTY_STRING;\n          response = this.redirectResponse.get(redirectResponseKey);\n\n          if (typeof response === \"undefined\") {\n            this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_START, InteractionType.Redirect);\n            this.logger.verbose(\"handleRedirectPromise has been called for the first time, storing the promise\");\n            request = this.browserStorage.getCachedNativeRequest();\n            redirectResponse = void 0;\n\n            if (request && NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeExtensionProvider) && this.nativeExtensionProvider && !hash) {\n              this.logger.trace(\"handleRedirectPromise - acquiring token from native platform\");\n              nativeClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.handleRedirectPromise, this.performanceClient, this.nativeExtensionProvider, request.accountId, this.nativeInternalStorage, request.correlationId);\n              redirectResponse = nativeClient.handleRedirectPromise();\n            } else {\n              this.logger.trace(\"handleRedirectPromise - acquiring token from web flow\");\n              correlationId = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.CORRELATION_ID, true) || Constants.EMPTY_STRING;\n              redirectClient = this.createRedirectClient(correlationId);\n              redirectResponse = redirectClient.handleRedirectPromise(hash);\n            }\n\n            response = redirectResponse.then(function (result) {\n              if (result) {\n                // Emit login event if number of accounts change\n                var isLoggingIn = loggedInAccounts.length < _this.getAllAccounts().length;\n\n                if (isLoggingIn) {\n                  _this.eventHandler.emitEvent(EventType.LOGIN_SUCCESS, InteractionType.Redirect, result);\n\n                  _this.logger.verbose(\"handleRedirectResponse returned result, login success\");\n                } else {\n                  _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Redirect, result);\n\n                  _this.logger.verbose(\"handleRedirectResponse returned result, acquire token success\");\n                }\n              }\n\n              _this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_END, InteractionType.Redirect);\n\n              return result;\n            }).catch(function (e) {\n              // Emit login event if there is an account\n              if (loggedInAccounts.length > 0) {\n                _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Redirect, null, e);\n              } else {\n                _this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Redirect, null, e);\n              }\n\n              _this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_END, InteractionType.Redirect);\n\n              throw e;\n            });\n            this.redirectResponse.set(redirectResponseKey, response);\n          } else {\n            this.logger.verbose(\"handleRedirectPromise has been called previously, returning the result from the first call\");\n          }\n\n          return [2\n          /*return*/\n          , response];\n        }\n\n        this.logger.verbose(\"handleRedirectPromise returns null, not browser environment\");\n        return [2\n        /*return*/\n        , null];\n      });\n    });\n  };\n  /**\r\n   * Use when you want to obtain an access_token for your API by redirecting the user's browser window to the authorization endpoint. This function redirects\r\n   * the page, so any code that follows this function will not execute.\r\n   *\r\n   * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current\r\n   * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.\r\n   *\r\n   * @param request\r\n   */\n\n\n  ClientApplication.prototype.acquireTokenRedirect = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var correlationId, isLoggedIn, result, nativeClient, redirectClient;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        correlationId = this.getRequestCorrelationId(request);\n        this.logger.verbose(\"acquireTokenRedirect called\", correlationId);\n        this.preflightBrowserEnvironmentCheck(InteractionType.Redirect);\n        isLoggedIn = this.getAllAccounts().length > 0;\n\n        if (isLoggedIn) {\n          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Redirect, request);\n        } else {\n          this.eventHandler.emitEvent(EventType.LOGIN_START, InteractionType.Redirect, request);\n        }\n\n        if (this.nativeExtensionProvider && this.canUseNative(request)) {\n          nativeClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenRedirect, this.performanceClient, this.nativeExtensionProvider, this.getNativeAccountId(request), this.nativeInternalStorage, request.correlationId);\n          result = nativeClient.acquireTokenRedirect(request).catch(function (e) {\n            if (e instanceof NativeAuthError && e.isFatal()) {\n              _this.nativeExtensionProvider = undefined; // If extension gets uninstalled during session prevent future requests from continuing to attempt\n\n              var redirectClient = _this.createRedirectClient(request.correlationId);\n\n              return redirectClient.acquireToken(request);\n            } else if (e instanceof InteractionRequiredAuthError) {\n              _this.logger.verbose(\"acquireTokenRedirect - Resolving interaction required error thrown by native broker by falling back to web flow\");\n\n              var redirectClient = _this.createRedirectClient(request.correlationId);\n\n              return redirectClient.acquireToken(request);\n            }\n\n            _this.browserStorage.setInteractionInProgress(false);\n\n            throw e;\n          });\n        } else {\n          redirectClient = this.createRedirectClient(request.correlationId);\n          result = redirectClient.acquireToken(request);\n        }\n\n        return [2\n        /*return*/\n        , result.catch(function (e) {\n          // If logged in, emit acquire token events\n          if (isLoggedIn) {\n            _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Redirect, null, e);\n          } else {\n            _this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Redirect, null, e);\n          }\n\n          throw e;\n        })];\n      });\n    });\n  }; // #endregion\n  // #region Popup Flow\n\n  /**\r\n   * Use when you want to obtain an access_token for your API via opening a popup window in the user's browser\r\n   *\r\n   * @param request\r\n   *\r\n   * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\r\n   */\n\n\n  ClientApplication.prototype.acquireTokenPopup = function (request) {\n    var _this = this;\n\n    var correlationId = this.getRequestCorrelationId(request);\n    var atPopupMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenPopup, correlationId);\n\n    try {\n      this.logger.verbose(\"acquireTokenPopup called\", correlationId);\n      this.preflightBrowserEnvironmentCheck(InteractionType.Popup);\n    } catch (e) {\n      // Since this function is syncronous we need to reject\n      return Promise.reject(e);\n    } // If logged in, emit acquire token events\n\n\n    var loggedInAccounts = this.getAllAccounts();\n\n    if (loggedInAccounts.length > 0) {\n      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Popup, request);\n    } else {\n      this.eventHandler.emitEvent(EventType.LOGIN_START, InteractionType.Popup, request);\n    }\n\n    var result;\n\n    if (this.canUseNative(request)) {\n      result = this.acquireTokenNative(request, ApiId.acquireTokenPopup).then(function (response) {\n        _this.browserStorage.setInteractionInProgress(false);\n\n        atPopupMeasurement.endMeasurement({\n          success: true,\n          isNativeBroker: true,\n          accessTokenSize: response.accessToken.length,\n          idTokenSize: response.idToken.length,\n          requestId: response.requestId\n        });\n        atPopupMeasurement.flushMeasurement();\n        return response;\n      }).catch(function (e) {\n        if (e instanceof NativeAuthError && e.isFatal()) {\n          _this.nativeExtensionProvider = undefined; // If extension gets uninstalled during session prevent future requests from continuing to attempt\n\n          var popupClient = _this.createPopupClient(request.correlationId);\n\n          return popupClient.acquireToken(request);\n        } else if (e instanceof InteractionRequiredAuthError) {\n          _this.logger.verbose(\"acquireTokenPopup - Resolving interaction required error thrown by native broker by falling back to web flow\");\n\n          var popupClient = _this.createPopupClient(request.correlationId);\n\n          return popupClient.acquireToken(request);\n        }\n\n        _this.browserStorage.setInteractionInProgress(false);\n\n        throw e;\n      });\n    } else {\n      var popupClient = this.createPopupClient(request.correlationId);\n      result = popupClient.acquireToken(request);\n    }\n\n    return result.then(function (result) {\n      /*\r\n       *  If logged in, emit acquire token events\r\n       */\n      var isLoggingIn = loggedInAccounts.length < _this.getAllAccounts().length;\n\n      if (isLoggingIn) {\n        _this.eventHandler.emitEvent(EventType.LOGIN_SUCCESS, InteractionType.Popup, result);\n      } else {\n        _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Popup, result);\n      }\n\n      atPopupMeasurement.endMeasurement({\n        success: true,\n        accessTokenSize: result.accessToken.length,\n        idTokenSize: result.idToken.length,\n        requestId: result.requestId\n      });\n      atPopupMeasurement.flushMeasurement();\n      return result;\n    }).catch(function (e) {\n      if (loggedInAccounts.length > 0) {\n        _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Popup, null, e);\n      } else {\n        _this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Popup, null, e);\n      }\n\n      atPopupMeasurement.endMeasurement({\n        errorCode: e.errorCode,\n        subErrorCode: e.subError,\n        success: false\n      });\n      atPopupMeasurement.flushMeasurement(); // Since this function is syncronous we need to reject\n\n      return Promise.reject(e);\n    });\n  }; // #endregion\n  // #region Silent Flow\n\n  /**\r\n   * This function uses a hidden iframe to fetch an authorization code from the eSTS. There are cases where this may not work:\r\n   * - Any browser using a form of Intelligent Tracking Prevention\r\n   * - If there is not an established session with the service\r\n   *\r\n   * In these cases, the request must be done inside a popup or full frame redirect.\r\n   *\r\n   * For the cases where interaction is required, you cannot send a request with prompt=none.\r\n   *\r\n   * If your refresh token has expired, you can use this function to fetch a new set of tokens silently as long as\r\n   * you session on the server still exists.\r\n   * @param request {@link SsoSilentRequest}\r\n   *\r\n   * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\r\n   */\n\n\n  ClientApplication.prototype.ssoSilent = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var correlationId, validRequest, ssoSilentMeasurement, result, silentIframeClient;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        correlationId = this.getRequestCorrelationId(request);\n        validRequest = __assign(__assign({}, request), {\n          // will be PromptValue.NONE or PromptValue.NO_SESSION\n          prompt: request.prompt,\n          correlationId: correlationId\n        });\n        this.preflightBrowserEnvironmentCheck(InteractionType.Silent);\n        ssoSilentMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.SsoSilent, correlationId);\n        this.logger.verbose(\"ssoSilent called\", correlationId);\n        this.eventHandler.emitEvent(EventType.SSO_SILENT_START, InteractionType.Silent, validRequest);\n\n        if (this.canUseNative(validRequest)) {\n          result = this.acquireTokenNative(validRequest, ApiId.ssoSilent).catch(function (e) {\n            // If native token acquisition fails for availability reasons fallback to standard flow\n            if (e instanceof NativeAuthError && e.isFatal()) {\n              _this.nativeExtensionProvider = undefined; // If extension gets uninstalled during session prevent future requests from continuing to attempt\n\n              var silentIframeClient = _this.createSilentIframeClient(validRequest.correlationId);\n\n              return silentIframeClient.acquireToken(validRequest);\n            }\n\n            throw e;\n          });\n        } else {\n          silentIframeClient = this.createSilentIframeClient(validRequest.correlationId);\n          result = silentIframeClient.acquireToken(validRequest);\n        }\n\n        return [2\n        /*return*/\n        , result.then(function (response) {\n          _this.eventHandler.emitEvent(EventType.SSO_SILENT_SUCCESS, InteractionType.Silent, response);\n\n          ssoSilentMeasurement.endMeasurement({\n            success: true,\n            isNativeBroker: response.fromNativeBroker,\n            accessTokenSize: response.accessToken.length,\n            idTokenSize: response.idToken.length,\n            requestId: response.requestId\n          });\n          ssoSilentMeasurement.flushMeasurement();\n          return response;\n        }).catch(function (e) {\n          _this.eventHandler.emitEvent(EventType.SSO_SILENT_FAILURE, InteractionType.Silent, null, e);\n\n          ssoSilentMeasurement.endMeasurement({\n            errorCode: e.errorCode,\n            subErrorCode: e.subError,\n            success: false\n          });\n          ssoSilentMeasurement.flushMeasurement();\n          throw e;\n        })];\n      });\n    });\n  };\n  /**\r\n   * This function redeems an authorization code (passed as code) from the eSTS token endpoint.\r\n   * This authorization code should be acquired server-side using a confidential client to acquire a spa_code.\r\n   * This API is not indended for normal authorization code acquisition and redemption.\r\n   *\r\n   * Redemption of this authorization code will not require PKCE, as it was acquired by a confidential client.\r\n   *\r\n   * @param request {@link AuthorizationCodeRequest}\r\n   * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\r\n   */\n\n\n  ClientApplication.prototype.acquireTokenByCode = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var correlationId, atbcMeasurement, hybridAuthCode_1, response;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        correlationId = this.getRequestCorrelationId(request);\n        this.preflightBrowserEnvironmentCheck(InteractionType.Silent);\n        this.logger.trace(\"acquireTokenByCode called\", correlationId);\n        this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_START, InteractionType.Silent, request);\n        atbcMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenByCode, request.correlationId);\n\n        try {\n          if (request.code) {\n            hybridAuthCode_1 = request.code;\n            response = this.hybridAuthCodeResponses.get(hybridAuthCode_1);\n\n            if (!response) {\n              this.logger.verbose(\"Initiating new acquireTokenByCode request\", correlationId);\n              response = this.acquireTokenByCodeAsync(__assign(__assign({}, request), {\n                correlationId: correlationId\n              })).then(function (result) {\n                _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_SUCCESS, InteractionType.Silent, result);\n\n                _this.hybridAuthCodeResponses.delete(hybridAuthCode_1);\n\n                atbcMeasurement.endMeasurement({\n                  success: true,\n                  accessTokenSize: result.accessToken.length,\n                  idTokenSize: result.idToken.length,\n                  isNativeBroker: result.fromNativeBroker,\n                  requestId: result.requestId\n                });\n                atbcMeasurement.flushMeasurement();\n                return result;\n              }).catch(function (error) {\n                _this.hybridAuthCodeResponses.delete(hybridAuthCode_1);\n\n                _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_FAILURE, InteractionType.Silent, null, error);\n\n                atbcMeasurement.endMeasurement({\n                  errorCode: error.errorCode,\n                  subErrorCode: error.subError,\n                  success: false\n                });\n                atbcMeasurement.flushMeasurement();\n                throw error;\n              });\n              this.hybridAuthCodeResponses.set(hybridAuthCode_1, response);\n            } else {\n              this.logger.verbose(\"Existing acquireTokenByCode request found\", request.correlationId);\n              atbcMeasurement.endMeasurement({\n                success: true\n              });\n              atbcMeasurement.discardMeasurement();\n            }\n\n            return [2\n            /*return*/\n            , response];\n          } else if (request.nativeAccountId) {\n            if (this.canUseNative(request, request.nativeAccountId)) {\n              return [2\n              /*return*/\n              , this.acquireTokenNative(request, ApiId.acquireTokenByCode, request.nativeAccountId).catch(function (e) {\n                // If native token acquisition fails for availability reasons fallback to standard flow\n                if (e instanceof NativeAuthError && e.isFatal()) {\n                  _this.nativeExtensionProvider = undefined; // If extension gets uninstalled during session prevent future requests from continuing to attempt\n                }\n\n                throw e;\n              })];\n            } else {\n              throw BrowserAuthError.createUnableToAcquireTokenFromNativePlatformError();\n            }\n          } else {\n            throw BrowserAuthError.createAuthCodeOrNativeAccountIdRequiredError();\n          }\n        } catch (e) {\n          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_FAILURE, InteractionType.Silent, null, e);\n          atbcMeasurement.endMeasurement({\n            errorCode: e instanceof AuthError && e.errorCode || undefined,\n            subErrorCode: e instanceof AuthError && e.subError || undefined,\n            success: false\n          });\n          throw e;\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\r\n   * Creates a SilentAuthCodeClient to redeem an authorization code.\r\n   * @param request\r\n   * @returns Result of the operation to redeem the authorization code\r\n   */\n\n\n  ClientApplication.prototype.acquireTokenByCodeAsync = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var silentAuthCodeClient, silentTokenResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.trace(\"acquireTokenByCodeAsync called\", request.correlationId);\n            silentAuthCodeClient = this.createSilentAuthCodeClient(request.correlationId);\n            return [4\n            /*yield*/\n            , silentAuthCodeClient.acquireToken(request)];\n\n          case 1:\n            silentTokenResult = _a.sent();\n            return [2\n            /*return*/\n            , silentTokenResult];\n        }\n      });\n    });\n  };\n  /**\r\n   * Attempt to acquire an access token from the cache\r\n   * @param silentCacheClient SilentCacheClient\r\n   * @param commonRequest CommonSilentFlowRequest\r\n   * @param silentRequest SilentRequest\r\n   * @returns A promise that, when resolved, returns the access token\r\n   */\n\n\n  ClientApplication.prototype.acquireTokenFromCache = function (silentCacheClient, commonRequest, silentRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (silentRequest.cacheLookupPolicy) {\n          case CacheLookupPolicy.Default:\n          case CacheLookupPolicy.AccessToken:\n          case CacheLookupPolicy.AccessTokenAndRefreshToken:\n            return [2\n            /*return*/\n            , silentCacheClient.acquireToken(commonRequest)];\n\n          default:\n            throw ClientAuthError.createRefreshRequiredError();\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\r\n   * Attempt to acquire an access token via a refresh token\r\n   * @param commonRequest CommonSilentFlowRequest\r\n   * @param silentRequest SilentRequest\r\n   * @returns A promise that, when resolved, returns the access token\r\n   */\n\n\n  ClientApplication.prototype.acquireTokenByRefreshToken = function (commonRequest, silentRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var silentRefreshClient;\n      return __generator(this, function (_a) {\n        switch (silentRequest.cacheLookupPolicy) {\n          case CacheLookupPolicy.Default:\n          case CacheLookupPolicy.AccessTokenAndRefreshToken:\n          case CacheLookupPolicy.RefreshToken:\n          case CacheLookupPolicy.RefreshTokenAndNetwork:\n            silentRefreshClient = this.createSilentRefreshClient(commonRequest.correlationId);\n            return [2\n            /*return*/\n            , silentRefreshClient.acquireToken(commonRequest)];\n\n          default:\n            throw ClientAuthError.createRefreshRequiredError();\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\r\n   * Attempt to acquire an access token via an iframe\r\n   * @param request CommonSilentFlowRequest\r\n   * @returns A promise that, when resolved, returns the access token\r\n   */\n\n\n  ClientApplication.prototype.acquireTokenBySilentIframe = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var silentIframeClient;\n      return __generator(this, function (_a) {\n        silentIframeClient = this.createSilentIframeClient(request.correlationId);\n        return [2\n        /*return*/\n        , silentIframeClient.acquireToken(request)];\n      });\n    });\n  }; // #endregion\n  // #region Logout\n\n  /**\r\n   * Deprecated logout function. Use logoutRedirect or logoutPopup instead\r\n   * @param logoutRequest\r\n   * @deprecated\r\n   */\n\n\n  ClientApplication.prototype.logout = function (logoutRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var correlationId;\n      return __generator(this, function (_a) {\n        correlationId = this.getRequestCorrelationId(logoutRequest);\n        this.logger.warning(\"logout API is deprecated and will be removed in msal-browser v3.0.0. Use logoutRedirect instead.\", correlationId);\n        return [2\n        /*return*/\n        , this.logoutRedirect(__assign({\n          correlationId: correlationId\n        }, logoutRequest))];\n      });\n    });\n  };\n  /**\r\n   * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n   * Default behaviour is to redirect the user to `window.location.href`.\r\n   * @param logoutRequest\r\n   */\n\n\n  ClientApplication.prototype.logoutRedirect = function (logoutRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var correlationId, redirectClient;\n      return __generator(this, function (_a) {\n        correlationId = this.getRequestCorrelationId(logoutRequest);\n        this.preflightBrowserEnvironmentCheck(InteractionType.Redirect);\n        redirectClient = this.createRedirectClient(correlationId);\n        return [2\n        /*return*/\n        , redirectClient.logout(logoutRequest)];\n      });\n    });\n  };\n  /**\r\n   * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server\r\n   * @param logoutRequest\r\n   */\n\n\n  ClientApplication.prototype.logoutPopup = function (logoutRequest) {\n    try {\n      var correlationId = this.getRequestCorrelationId(logoutRequest);\n      this.preflightBrowserEnvironmentCheck(InteractionType.Popup);\n      var popupClient = this.createPopupClient(correlationId);\n      return popupClient.logout(logoutRequest);\n    } catch (e) {\n      // Since this function is syncronous we need to reject\n      return Promise.reject(e);\n    }\n  }; // #endregion\n  // #region Account APIs\n\n  /**\r\n   * Returns all accounts that MSAL currently has data for.\r\n   * (the account object is created at the time of successful login)\r\n   * or empty array when no accounts are found\r\n   * @returns Array of account objects in cache\r\n   */\n\n\n  ClientApplication.prototype.getAllAccounts = function () {\n    this.logger.verbose(\"getAllAccounts called\");\n    return this.isBrowserEnvironment ? this.browserStorage.getAllAccounts() : [];\n  };\n  /**\r\n   * Returns the signed in account matching username.\r\n   * (the account object is created at the time of successful login)\r\n   * or null when no matching account is found.\r\n   * This API is provided for convenience but getAccountById should be used for best reliability\r\n   * @param userName\r\n   * @returns The account object stored in MSAL\r\n   */\n\n\n  ClientApplication.prototype.getAccountByUsername = function (userName) {\n    var allAccounts = this.getAllAccounts();\n\n    if (!StringUtils.isEmpty(userName) && allAccounts && allAccounts.length) {\n      this.logger.verbose(\"Account matching username found, returning\");\n      this.logger.verbosePii(\"Returning signed-in accounts matching username: \" + userName);\n      return allAccounts.filter(function (accountObj) {\n        return accountObj.username.toLowerCase() === userName.toLowerCase();\n      })[0] || null;\n    } else {\n      this.logger.verbose(\"getAccountByUsername: No matching account found, returning null\");\n      return null;\n    }\n  };\n  /**\r\n   * Returns the signed in account matching homeAccountId.\r\n   * (the account object is created at the time of successful login)\r\n   * or null when no matching account is found\r\n   * @param homeAccountId\r\n   * @returns The account object stored in MSAL\r\n   */\n\n\n  ClientApplication.prototype.getAccountByHomeId = function (homeAccountId) {\n    var allAccounts = this.getAllAccounts();\n\n    if (!StringUtils.isEmpty(homeAccountId) && allAccounts && allAccounts.length) {\n      this.logger.verbose(\"Account matching homeAccountId found, returning\");\n      this.logger.verbosePii(\"Returning signed-in accounts matching homeAccountId: \" + homeAccountId);\n      return allAccounts.filter(function (accountObj) {\n        return accountObj.homeAccountId === homeAccountId;\n      })[0] || null;\n    } else {\n      this.logger.verbose(\"getAccountByHomeId: No matching account found, returning null\");\n      return null;\n    }\n  };\n  /**\r\n   * Returns the signed in account matching localAccountId.\r\n   * (the account object is created at the time of successful login)\r\n   * or null when no matching account is found\r\n   * @param localAccountId\r\n   * @returns The account object stored in MSAL\r\n   */\n\n\n  ClientApplication.prototype.getAccountByLocalId = function (localAccountId) {\n    var allAccounts = this.getAllAccounts();\n\n    if (!StringUtils.isEmpty(localAccountId) && allAccounts && allAccounts.length) {\n      this.logger.verbose(\"Account matching localAccountId found, returning\");\n      this.logger.verbosePii(\"Returning signed-in accounts matching localAccountId: \" + localAccountId);\n      return allAccounts.filter(function (accountObj) {\n        return accountObj.localAccountId === localAccountId;\n      })[0] || null;\n    } else {\n      this.logger.verbose(\"getAccountByLocalId: No matching account found, returning null\");\n      return null;\n    }\n  };\n  /**\r\n   * Sets the account to use as the active account. If no account is passed to the acquireToken APIs, then MSAL will use this active account.\r\n   * @param account\r\n   */\n\n\n  ClientApplication.prototype.setActiveAccount = function (account) {\n    this.browserStorage.setActiveAccount(account);\n  };\n  /**\r\n   * Gets the currently active account\r\n   */\n\n\n  ClientApplication.prototype.getActiveAccount = function () {\n    return this.browserStorage.getActiveAccount();\n  }; // #endregion\n  // #region Helpers\n\n  /**\r\n   * Helper to validate app environment before making an auth request\r\n   *\r\n   * @protected\r\n   * @param {InteractionType} interactionType What kind of interaction is being used\r\n   * @param {boolean} [setInteractionInProgress=true] Whether to set interaction in progress temp cache flag\r\n   */\n\n\n  ClientApplication.prototype.preflightBrowserEnvironmentCheck = function (interactionType, setInteractionInProgress) {\n    if (setInteractionInProgress === void 0) {\n      setInteractionInProgress = true;\n    }\n\n    this.logger.verbose(\"preflightBrowserEnvironmentCheck started\"); // Block request if not in browser environment\n\n    BrowserUtils.blockNonBrowserEnvironment(this.isBrowserEnvironment); // Block redirects if in an iframe\n\n    BrowserUtils.blockRedirectInIframe(interactionType, this.config.system.allowRedirectInIframe); // Block auth requests inside a hidden iframe\n\n    BrowserUtils.blockReloadInHiddenIframes(); // Block redirectUri opened in a popup from calling MSAL APIs\n\n    BrowserUtils.blockAcquireTokenInPopups(); // Block token acquisition before initialize has been called if native brokering is enabled\n\n    BrowserUtils.blockNativeBrokerCalledBeforeInitialized(this.config.system.allowNativeBroker, this.initialized); // Block redirects if memory storage is enabled but storeAuthStateInCookie is not\n\n    if (interactionType === InteractionType.Redirect && this.config.cache.cacheLocation === BrowserCacheLocation.MemoryStorage && !this.config.cache.storeAuthStateInCookie) {\n      throw BrowserConfigurationAuthError.createInMemoryRedirectUnavailableError();\n    }\n\n    if (interactionType === InteractionType.Redirect || interactionType === InteractionType.Popup) {\n      this.preflightInteractiveRequest(setInteractionInProgress);\n    }\n  };\n  /**\r\n   * Preflight check for interactive requests\r\n   *\r\n   * @protected\r\n   * @param {boolean} setInteractionInProgress Whether to set interaction in progress temp cache flag\r\n   */\n\n\n  ClientApplication.prototype.preflightInteractiveRequest = function (setInteractionInProgress) {\n    this.logger.verbose(\"preflightInteractiveRequest called, validating app environment\"); // block the reload if it occurred inside a hidden iframe\n\n    BrowserUtils.blockReloadInHiddenIframes(); // Set interaction in progress temporary cache or throw if alread set.\n\n    if (setInteractionInProgress) {\n      this.browserStorage.setInteractionInProgress(true);\n    }\n  };\n  /**\r\n   * Acquire a token from native device (e.g. WAM)\r\n   * @param request\r\n   */\n\n\n  ClientApplication.prototype.acquireTokenNative = function (request, apiId, accountId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var nativeClient;\n      return __generator(this, function (_a) {\n        this.logger.trace(\"acquireTokenNative called\");\n\n        if (!this.nativeExtensionProvider) {\n          throw BrowserAuthError.createNativeConnectionNotEstablishedError();\n        }\n\n        nativeClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, apiId, this.performanceClient, this.nativeExtensionProvider, accountId || this.getNativeAccountId(request), this.nativeInternalStorage, request.correlationId);\n        return [2\n        /*return*/\n        , nativeClient.acquireToken(request)];\n      });\n    });\n  };\n  /**\r\n   * Returns boolean indicating if this request can use the native broker\r\n   * @param request\r\n   */\n\n\n  ClientApplication.prototype.canUseNative = function (request, accountId) {\n    this.logger.trace(\"canUseNative called\");\n\n    if (!NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeExtensionProvider, request.authenticationScheme)) {\n      this.logger.trace(\"canUseNative: isNativeAvailable returned false, returning false\");\n      return false;\n    }\n\n    if (request.prompt) {\n      switch (request.prompt) {\n        case PromptValue.NONE:\n        case PromptValue.CONSENT:\n        case PromptValue.LOGIN:\n          this.logger.trace(\"canUseNative: prompt is compatible with native flow\");\n          break;\n\n        default:\n          this.logger.trace(\"canUseNative: prompt = \" + request.prompt + \" is not compatible with native flow, returning false\");\n          return false;\n      }\n    }\n\n    if (!accountId && !this.getNativeAccountId(request)) {\n      this.logger.trace(\"canUseNative: nativeAccountId is not available, returning false\");\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Get the native accountId from the account\r\n   * @param request\r\n   * @returns\r\n   */\n\n\n  ClientApplication.prototype.getNativeAccountId = function (request) {\n    var account = request.account || this.browserStorage.getAccountInfoByHints(request.loginHint, request.sid) || this.getActiveAccount();\n    return account && account.nativeAccountId || \"\";\n  };\n  /**\r\n   * Returns new instance of the Popup Interaction Client\r\n   * @param correlationId\r\n   */\n\n\n  ClientApplication.prototype.createPopupClient = function (correlationId) {\n    return new PopupClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, correlationId);\n  };\n  /**\r\n   * Returns new instance of the Redirect Interaction Client\r\n   * @param correlationId\r\n   */\n\n\n  ClientApplication.prototype.createRedirectClient = function (correlationId) {\n    return new RedirectClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, correlationId);\n  };\n  /**\r\n   * Returns new instance of the Silent Iframe Interaction Client\r\n   * @param correlationId\r\n   */\n\n\n  ClientApplication.prototype.createSilentIframeClient = function (correlationId) {\n    return new SilentIframeClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.ssoSilent, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, correlationId);\n  };\n  /**\r\n   * Returns new instance of the Silent Cache Interaction Client\r\n   */\n\n\n  ClientApplication.prototype.createSilentCacheClient = function (correlationId) {\n    return new SilentCacheClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeExtensionProvider, correlationId);\n  };\n  /**\r\n   * Returns new instance of the Silent Refresh Interaction Client\r\n   */\n\n\n  ClientApplication.prototype.createSilentRefreshClient = function (correlationId) {\n    return new SilentRefreshClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeExtensionProvider, correlationId);\n  };\n  /**\r\n   * Returns new instance of the Silent AuthCode Interaction Client\r\n   */\n\n\n  ClientApplication.prototype.createSilentAuthCodeClient = function (correlationId) {\n    return new SilentAuthCodeClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenByCode, this.performanceClient, this.nativeExtensionProvider, correlationId);\n  };\n  /**\r\n   * Adds event callbacks to array\r\n   * @param callback\r\n   */\n\n\n  ClientApplication.prototype.addEventCallback = function (callback) {\n    return this.eventHandler.addEventCallback(callback);\n  };\n  /**\r\n   * Removes callback with provided id from callback array\r\n   * @param callbackId\r\n   */\n\n\n  ClientApplication.prototype.removeEventCallback = function (callbackId) {\n    this.eventHandler.removeEventCallback(callbackId);\n  };\n  /**\r\n   * Registers a callback to receive performance events.\r\n   *\r\n   * @param {PerformanceCallbackFunction} callback\r\n   * @returns {string}\r\n   */\n\n\n  ClientApplication.prototype.addPerformanceCallback = function (callback) {\n    return this.performanceClient.addPerformanceCallback(callback);\n  };\n  /**\r\n   * Removes a callback registered with addPerformanceCallback.\r\n   *\r\n   * @param {string} callbackId\r\n   * @returns {boolean}\r\n   */\n\n\n  ClientApplication.prototype.removePerformanceCallback = function (callbackId) {\n    return this.performanceClient.removePerformanceCallback(callbackId);\n  };\n  /**\r\n   * Adds event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window\r\n   */\n\n\n  ClientApplication.prototype.enableAccountStorageEvents = function () {\n    this.eventHandler.enableAccountStorageEvents();\n  };\n  /**\r\n   * Removes event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window\r\n   */\n\n\n  ClientApplication.prototype.disableAccountStorageEvents = function () {\n    this.eventHandler.disableAccountStorageEvents();\n  };\n  /**\r\n   * Gets the token cache for the application.\r\n   */\n\n\n  ClientApplication.prototype.getTokenCache = function () {\n    return this.tokenCache;\n  };\n  /**\r\n   * Returns the logger instance\r\n   */\n\n\n  ClientApplication.prototype.getLogger = function () {\n    return this.logger;\n  };\n  /**\r\n   * Replaces the default logger set in configurations with new Logger with new configurations\r\n   * @param logger Logger instance\r\n   */\n\n\n  ClientApplication.prototype.setLogger = function (logger) {\n    this.logger = logger;\n  };\n  /**\r\n   * Called by wrapper libraries (Angular & React) to set SKU and Version passed down to telemetry, logger, etc.\r\n   * @param sku\r\n   * @param version\r\n   */\n\n\n  ClientApplication.prototype.initializeWrapperLibrary = function (sku, version) {\n    // Validate the SKU passed in is one we expect\n    this.browserStorage.setWrapperMetadata(sku, version);\n  };\n  /**\r\n   * Sets navigation client\r\n   * @param navigationClient\r\n   */\n\n\n  ClientApplication.prototype.setNavigationClient = function (navigationClient) {\n    this.navigationClient = navigationClient;\n  };\n  /**\r\n   * Returns the configuration object\r\n   */\n\n\n  ClientApplication.prototype.getConfiguration = function () {\n    return this.config;\n  };\n  /**\r\n   * Generates a correlation id for a request if none is provided.\r\n   *\r\n   * @protected\r\n   * @param {?Partial<BaseAuthRequest>} [request]\r\n   * @returns {string}\r\n   */\n\n\n  ClientApplication.prototype.getRequestCorrelationId = function (request) {\n    if (request === null || request === void 0 ? void 0 : request.correlationId) {\n      return request.correlationId;\n    }\n\n    if (this.isBrowserEnvironment) {\n      return this.browserCrypto.createNewGuid();\n    }\n    /*\r\n     * Included for fallback for non-browser environments,\r\n     * and to ensure this method always returns a string.\r\n     */\n\n\n    return Constants.EMPTY_STRING;\n  };\n\n  return ClientApplication;\n}();\n\nexport { ClientApplication };","map":{"version":3,"mappings":"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","names":["configuration","isBrowserEnvironment","window","config","buildConfiguration","initialized","logger","Logger","system","loggerOptions","name","version","networkClient","navigationClient","redirectResponse","Map","hybridAuthCodeResponses","performanceClient","BrowserPerformanceClient","auth","clientId","authority","telemetry","application","cryptoOptions","StubPerformanceClient","browserCrypto","CryptoOps","DEFAULT_CRYPTO_IMPLEMENTATION","eventHandler","EventHandler","browserStorage","BrowserCacheManager","cache","DEFAULT_BROWSER_CACHE_MANAGER","nativeCacheOptions","cacheLocation","BrowserCacheLocation","MemoryStorage","storeAuthStateInCookie","secureCookies","nativeInternalStorage","tokenCache","TokenCache","ClientApplication","trace","info","emitEvent","EventType","INITIALIZE_START","allowNativeBroker","_a","NativeMessageHandler","createProvider","nativeBrokerHandshakeTimeout","nativeExtensionProvider","_b","verbose","e_1","INITIALIZE_END","hash","BrowserUtils","blockNativeBrokerCalledBeforeInitialized","loggedInAccounts","getAllAccounts","redirectResponseKey","Constants","EMPTY_STRING","response","get","HANDLE_REDIRECT_START","InteractionType","Redirect","request","getCachedNativeRequest","isNativeAvailable","nativeClient","NativeInteractionClient","ApiId","handleRedirectPromise","accountId","correlationId","getTemporaryCache","TemporaryCacheKeys","CORRELATION_ID","redirectClient","createRedirectClient","then","result","isLoggingIn","length","_this","LOGIN_SUCCESS","ACQUIRE_TOKEN_SUCCESS","HANDLE_REDIRECT_END","catch","e","ACQUIRE_TOKEN_FAILURE","LOGIN_FAILURE","set","getRequestCorrelationId","preflightBrowserEnvironmentCheck","isLoggedIn","ACQUIRE_TOKEN_START","LOGIN_START","canUseNative","acquireTokenRedirect","getNativeAccountId","NativeAuthError","isFatal","undefined","acquireToken","InteractionRequiredAuthError","setInteractionInProgress","atPopupMeasurement","startMeasurement","PerformanceEvents","AcquireTokenPopup","Popup","Promise","reject","acquireTokenNative","acquireTokenPopup","endMeasurement","success","isNativeBroker","accessTokenSize","accessToken","idTokenSize","idToken","requestId","flushMeasurement","popupClient","createPopupClient","errorCode","subErrorCode","subError","validRequest","prompt","Silent","ssoSilentMeasurement","SsoSilent","SSO_SILENT_START","ssoSilent","silentIframeClient","createSilentIframeClient","SSO_SILENT_SUCCESS","fromNativeBroker","SSO_SILENT_FAILURE","ACQUIRE_TOKEN_BY_CODE_START","atbcMeasurement","AcquireTokenByCode","code","hybridAuthCode_1","acquireTokenByCodeAsync","__assign","ACQUIRE_TOKEN_BY_CODE_SUCCESS","delete","error","ACQUIRE_TOKEN_BY_CODE_FAILURE","discardMeasurement","nativeAccountId","acquireTokenByCode","BrowserAuthError","createUnableToAcquireTokenFromNativePlatformError","createAuthCodeOrNativeAccountIdRequiredError","AuthError","silentAuthCodeClient","createSilentAuthCodeClient","silentTokenResult","silentCacheClient","commonRequest","silentRequest","cacheLookupPolicy","CacheLookupPolicy","Default","AccessToken","AccessTokenAndRefreshToken","ClientAuthError","createRefreshRequiredError","RefreshToken","RefreshTokenAndNetwork","silentRefreshClient","createSilentRefreshClient","logoutRequest","warning","logoutRedirect","logout","userName","allAccounts","StringUtils","isEmpty","verbosePii","filter","username","toLowerCase","homeAccountId","localAccountId","account","setActiveAccount","getActiveAccount","interactionType","blockNonBrowserEnvironment","blockRedirectInIframe","allowRedirectInIframe","blockReloadInHiddenIframes","blockAcquireTokenInPopups","BrowserConfigurationAuthError","createInMemoryRedirectUnavailableError","preflightInteractiveRequest","apiId","createNativeConnectionNotEstablishedError","authenticationScheme","PromptValue","NONE","CONSENT","LOGIN","getAccountInfoByHints","loginHint","sid","PopupClient","RedirectClient","SilentIframeClient","SilentCacheClient","SilentRefreshClient","SilentAuthCodeClient","callback","addEventCallback","callbackId","removeEventCallback","addPerformanceCallback","removePerformanceCallback","enableAccountStorageEvents","disableAccountStorageEvents","sku","setWrapperMetadata","createNewGuid"],"sources":["../../src/app/ClientApplication.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { CryptoOps } from \"../crypto/CryptoOps\";\nimport { StringUtils, InteractionRequiredAuthError, AccountInfo, Constants, INetworkModule, AuthenticationResult, Logger, CommonSilentFlowRequest, ICrypto, DEFAULT_CRYPTO_IMPLEMENTATION, AuthError, PerformanceEvents, PerformanceCallbackFunction, StubPerformanceClient, IPerformanceClient, BaseAuthRequest, PromptValue, ClientAuthError } from \"@azure/msal-common\";\nimport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER } from \"../cache/BrowserCacheManager\";\nimport { BrowserConfiguration, buildConfiguration, CacheOptions, Configuration } from \"../config/Configuration\";\nimport { InteractionType, ApiId, BrowserCacheLocation, WrapperSKU, TemporaryCacheKeys, CacheLookupPolicy } from \"../utils/BrowserConstants\";\nimport { BrowserUtils } from \"../utils/BrowserUtils\";\nimport { RedirectRequest } from \"../request/RedirectRequest\";\nimport { PopupRequest } from \"../request/PopupRequest\";\nimport { SsoSilentRequest } from \"../request/SsoSilentRequest\";\nimport { version, name } from \"../packageMetadata\";\nimport { EventCallbackFunction } from \"../event/EventMessage\";\nimport { EventType } from \"../event/EventType\";\nimport { EndSessionRequest } from \"../request/EndSessionRequest\";\nimport { BrowserConfigurationAuthError } from \"../error/BrowserConfigurationAuthError\";\nimport { EndSessionPopupRequest } from \"../request/EndSessionPopupRequest\";\nimport { INavigationClient } from \"../navigation/INavigationClient\";\nimport { EventHandler } from \"../event/EventHandler\";\nimport { PopupClient } from \"../interaction_client/PopupClient\";\nimport { RedirectClient } from \"../interaction_client/RedirectClient\";\nimport { SilentIframeClient } from \"../interaction_client/SilentIframeClient\";\nimport { SilentRefreshClient } from \"../interaction_client/SilentRefreshClient\";\nimport { TokenCache } from \"../cache/TokenCache\";\nimport { ITokenCache } from \"../cache/ITokenCache\";\nimport { NativeInteractionClient } from \"../interaction_client/NativeInteractionClient\";\nimport { NativeMessageHandler } from \"../broker/nativeBroker/NativeMessageHandler\";\nimport { SilentRequest } from \"../request/SilentRequest\";\nimport { NativeAuthError } from \"../error/NativeAuthError\";\nimport { SilentCacheClient } from \"../interaction_client/SilentCacheClient\";\nimport { SilentAuthCodeClient } from \"../interaction_client/SilentAuthCodeClient\";\nimport { BrowserAuthError } from \"../error/BrowserAuthError\";\nimport { AuthorizationCodeRequest } from \"../request/AuthorizationCodeRequest\";\nimport { NativeTokenRequest } from \"../broker/nativeBroker/NativeRequest\";\nimport { BrowserPerformanceClient } from \"../telemetry/BrowserPerformanceClient\";\n\nexport abstract class ClientApplication {\n\n    // Crypto interface implementation\n    protected readonly browserCrypto: ICrypto;\n\n    // Storage interface implementation\n    protected readonly browserStorage: BrowserCacheManager;\n\n    // Native Cache in memory storage implementation\n    protected readonly nativeInternalStorage: BrowserCacheManager;\n\n    // Network interface implementation\n    protected readonly networkClient: INetworkModule;\n\n    // Navigation interface implementation\n    protected navigationClient: INavigationClient;\n\n    // Input configuration by developer/user\n    protected config: BrowserConfiguration;\n\n    // Token cache implementation\n    private tokenCache: TokenCache;\n\n    // Logger\n    protected logger: Logger;\n\n    // Flag to indicate if in browser environment\n    protected isBrowserEnvironment: boolean;\n\n    protected eventHandler: EventHandler;\n\n    // Redirect Response Object\n    protected redirectResponse: Map<string, Promise<AuthenticationResult | null>>;\n\n    // Native Extension Provider\n    protected nativeExtensionProvider: NativeMessageHandler | undefined;\n\n    // Hybrid auth code responses\n    private hybridAuthCodeResponses: Map<string, Promise<AuthenticationResult>>;\n\n    // Performance telemetry client\n    protected performanceClient: IPerformanceClient;\n\n    // Flag representing whether or not the initialize API has been called and completed\n    protected initialized: boolean;\n\n    /**\n     * @constructor\n     * Constructor for the PublicClientApplication used to instantiate the PublicClientApplication object\n     *\n     * Important attributes in the Configuration object for auth are:\n     * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview\n     * - authority: the authority URL for your application.\n     * - redirect_uri: the uri of your application registered in the portal.\n     *\n     * In Azure AD, authority is a URL indicating the Azure active directory that MSAL uses to obtain tokens.\n     * It is of the form https://login.microsoftonline.com/{Enter_the_Tenant_Info_Here}\n     * If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\n     * If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\n     * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\n     * To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\n     *\n     * In Azure B2C, authority is of the form https://{instance}/tfp/{tenant}/{policyName}/\n     * Full B2C functionality will be available in this library in future versions.\n     *\n     * @param configuration Object for the MSAL PublicClientApplication instance\n     */\n    constructor(configuration: Configuration) {\n        /*\n         * If loaded in an environment where window is not available,\n         * set internal flag to false so that further requests fail.\n         * This is to support server-side rendering environments.\n         */\n        this.isBrowserEnvironment = typeof window !== \"undefined\";\n        // Set the configuration.\n        this.config = buildConfiguration(configuration, this.isBrowserEnvironment);\n        this.initialized = false;\n\n        // Initialize logger\n        this.logger = new Logger(this.config.system.loggerOptions, name, version);\n\n        // Initialize the network module class.\n        this.networkClient = this.config.system.networkClient;\n\n        // Initialize the navigation client class.\n        this.navigationClient = this.config.system.navigationClient;\n\n        // Initialize redirectResponse Map\n        this.redirectResponse = new Map();\n\n        // Initial hybrid spa map\n        this.hybridAuthCodeResponses = new Map();\n\n        // Initialize performance client\n        this.performanceClient = this.isBrowserEnvironment ?\n            new BrowserPerformanceClient(this.config.auth.clientId, this.config.auth.authority, this.logger, name, version, this.config.telemetry.application, this.config.system.cryptoOptions) :\n            new StubPerformanceClient(this.config.auth.clientId, this.config.auth.authority, this.logger, name, version, this.config.telemetry.application);\n\n        // Initialize the crypto class.\n        this.browserCrypto = this.isBrowserEnvironment ? new CryptoOps(this.logger, this.performanceClient, this.config.system.cryptoOptions) : DEFAULT_CRYPTO_IMPLEMENTATION;\n\n        this.eventHandler = new EventHandler(this.logger, this.browserCrypto);\n\n        // Initialize the browser storage class.\n        this.browserStorage = this.isBrowserEnvironment ?\n            new BrowserCacheManager(this.config.auth.clientId, this.config.cache, this.browserCrypto, this.logger) :\n            DEFAULT_BROWSER_CACHE_MANAGER(this.config.auth.clientId, this.logger);\n\n        // initialize in memory storage for native flows\n        const nativeCacheOptions: Required<CacheOptions> = {\n            cacheLocation: BrowserCacheLocation.MemoryStorage,\n            storeAuthStateInCookie: false,\n            secureCookies: false\n        };\n        this.nativeInternalStorage = new BrowserCacheManager(this.config.auth.clientId, nativeCacheOptions, this.browserCrypto, this.logger);\n\n        // Initialize the token cache\n        this.tokenCache = new TokenCache(this.config, this.browserStorage, this.logger, this.browserCrypto);\n    }\n\n    /**\n     * Initializer function to perform async startup tasks such as connecting to WAM extension\n     */\n    async initialize(): Promise<void> {\n        this.logger.trace(\"initialize called\");\n        if (this.initialized) {\n            this.logger.info(\"initialize has already been called, exiting early.\");\n            return;\n        }\n        this.eventHandler.emitEvent(EventType.INITIALIZE_START);\n        if (this.config.system.allowNativeBroker) {\n            try {\n                this.nativeExtensionProvider = await NativeMessageHandler.createProvider(this.logger, this.config.system.nativeBrokerHandshakeTimeout);\n            } catch (e) {\n                this.logger.verbose(e);\n            }\n        }\n        this.initialized = true;\n        this.eventHandler.emitEvent(EventType.INITIALIZE_END);\n    }\n\n    // #region Redirect Flow\n\n    /**\n     * Event handler function which allows users to fire events after the PublicClientApplication object\n     * has loaded during redirect flows. This should be invoked on all page loads involved in redirect\n     * auth flows.\n     * @param hash Hash to process. Defaults to the current value of window.location.hash. Only needs to be provided explicitly if the response to be handled is not contained in the current value.\n     * @returns Token response or null. If the return value is null, then no auth redirect was detected.\n     */\n    async handleRedirectPromise(hash?: string): Promise<AuthenticationResult | null> {\n        this.logger.verbose(\"handleRedirectPromise called\");\n        // Block token acquisition before initialize has been called if native brokering is enabled\n        BrowserUtils.blockNativeBrokerCalledBeforeInitialized(this.config.system.allowNativeBroker, this.initialized);\n\n        const loggedInAccounts = this.getAllAccounts();\n        if (this.isBrowserEnvironment) {\n            /**\n             * Store the promise on the PublicClientApplication instance if this is the first invocation of handleRedirectPromise,\n             * otherwise return the promise from the first invocation. Prevents race conditions when handleRedirectPromise is called\n             * several times concurrently.\n             */\n            const redirectResponseKey = hash || Constants.EMPTY_STRING;\n            let response = this.redirectResponse.get(redirectResponseKey);\n            if (typeof response === \"undefined\") {\n                this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_START, InteractionType.Redirect);\n                this.logger.verbose(\"handleRedirectPromise has been called for the first time, storing the promise\");\n\n                const request: NativeTokenRequest | null = this.browserStorage.getCachedNativeRequest();\n                let redirectResponse: Promise<AuthenticationResult | null>;\n                if (request && NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeExtensionProvider) && this.nativeExtensionProvider && !hash) {\n                    this.logger.trace(\"handleRedirectPromise - acquiring token from native platform\");\n                    const nativeClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.handleRedirectPromise, this.performanceClient, this.nativeExtensionProvider, request.accountId, this.nativeInternalStorage, request.correlationId);\n                    redirectResponse = nativeClient.handleRedirectPromise();\n                } else {\n                    this.logger.trace(\"handleRedirectPromise - acquiring token from web flow\");\n                    const correlationId = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.CORRELATION_ID, true) || Constants.EMPTY_STRING;\n                    const redirectClient = this.createRedirectClient(correlationId);\n                    redirectResponse = redirectClient.handleRedirectPromise(hash);\n                }\n\n                response = redirectResponse.then((result: AuthenticationResult | null) => {\n                    if (result) {\n                        // Emit login event if number of accounts change\n\n                        const isLoggingIn = loggedInAccounts.length < this.getAllAccounts().length;\n                        if (isLoggingIn) {\n                            this.eventHandler.emitEvent(EventType.LOGIN_SUCCESS, InteractionType.Redirect, result);\n                            this.logger.verbose(\"handleRedirectResponse returned result, login success\");\n                        } else {\n                            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Redirect, result);\n                            this.logger.verbose(\"handleRedirectResponse returned result, acquire token success\");\n                        }\n                    }\n                    this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_END, InteractionType.Redirect);\n\n                    return result;\n                }).catch((e) => {\n                    // Emit login event if there is an account\n                    if (loggedInAccounts.length > 0) {\n                        this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Redirect, null, e);\n                    } else {\n                        this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Redirect, null, e);\n                    }\n                    this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_END, InteractionType.Redirect);\n\n                    throw e;\n                });\n                this.redirectResponse.set(redirectResponseKey, response);\n            } else {\n                this.logger.verbose(\"handleRedirectPromise has been called previously, returning the result from the first call\");\n            }\n\n            return response;\n        }\n        this.logger.verbose(\"handleRedirectPromise returns null, not browser environment\");\n        return null;\n    }\n\n    /**\n     * Use when you want to obtain an access_token for your API by redirecting the user's browser window to the authorization endpoint. This function redirects\n     * the page, so any code that follows this function will not execute.\n     *\n     * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current\n     * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.\n     *\n     * @param request\n     */\n    async acquireTokenRedirect(request: RedirectRequest): Promise<void> {\n        // Preflight request\n        const correlationId = this.getRequestCorrelationId(request);\n        this.logger.verbose(\"acquireTokenRedirect called\", correlationId);\n        this.preflightBrowserEnvironmentCheck(InteractionType.Redirect);\n\n        // If logged in, emit acquire token events\n        const isLoggedIn = this.getAllAccounts().length > 0;\n        if (isLoggedIn) {\n            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Redirect, request);\n        } else {\n            this.eventHandler.emitEvent(EventType.LOGIN_START, InteractionType.Redirect, request);\n        }\n\n        let result: Promise<void>;\n\n        if (this.nativeExtensionProvider && this.canUseNative(request)) {\n            const nativeClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenRedirect, this.performanceClient, this.nativeExtensionProvider, this.getNativeAccountId(request), this.nativeInternalStorage, request.correlationId);\n            result = nativeClient.acquireTokenRedirect(request).catch((e: AuthError) => {\n                if (e instanceof NativeAuthError && e.isFatal()) {\n                    this.nativeExtensionProvider = undefined; // If extension gets uninstalled during session prevent future requests from continuing to attempt\n                    const redirectClient = this.createRedirectClient(request.correlationId);\n                    return redirectClient.acquireToken(request);\n                } else if (e instanceof InteractionRequiredAuthError) {\n                    this.logger.verbose(\"acquireTokenRedirect - Resolving interaction required error thrown by native broker by falling back to web flow\");\n                    const redirectClient = this.createRedirectClient(request.correlationId);\n                    return redirectClient.acquireToken(request);\n                }\n                this.browserStorage.setInteractionInProgress(false);\n                throw e;\n            });\n        } else {\n            const redirectClient = this.createRedirectClient(request.correlationId);\n            result = redirectClient.acquireToken(request);\n        }\n\n        return result.catch((e) => {\n            // If logged in, emit acquire token events\n            if (isLoggedIn) {\n                this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Redirect, null, e);\n            } else {\n                this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Redirect, null, e);\n            }\n            throw e;\n        });\n    }\n\n    // #endregion\n\n    // #region Popup Flow\n\n    /**\n     * Use when you want to obtain an access_token for your API via opening a popup window in the user's browser\n     *\n     * @param request\n     *\n     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\n     */\n    acquireTokenPopup(request: PopupRequest): Promise<AuthenticationResult> {\n        const correlationId = this.getRequestCorrelationId(request);\n        const atPopupMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenPopup, correlationId);\n\n        try {\n            this.logger.verbose(\"acquireTokenPopup called\", correlationId);\n            this.preflightBrowserEnvironmentCheck(InteractionType.Popup);\n        } catch (e) {\n            // Since this function is syncronous we need to reject\n            return Promise.reject(e);\n        }\n\n        // If logged in, emit acquire token events\n        const loggedInAccounts = this.getAllAccounts();\n        if (loggedInAccounts.length > 0) {\n            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Popup, request);\n        } else {\n            this.eventHandler.emitEvent(EventType.LOGIN_START, InteractionType.Popup, request);\n        }\n\n        let result: Promise<AuthenticationResult>;\n\n        if (this.canUseNative(request)) {\n            result = this.acquireTokenNative(request, ApiId.acquireTokenPopup).then((response) => {\n                this.browserStorage.setInteractionInProgress(false);\n                atPopupMeasurement.endMeasurement({\n                    success: true,\n                    isNativeBroker: true,\n                    accessTokenSize: response.accessToken.length,\n                    idTokenSize: response.idToken.length,\n                    requestId: response.requestId\n                });\n                atPopupMeasurement.flushMeasurement();\n                return response;\n            }).catch((e: AuthError) => {\n                if (e instanceof NativeAuthError && e.isFatal()) {\n                    this.nativeExtensionProvider = undefined; // If extension gets uninstalled during session prevent future requests from continuing to attempt\n                    const popupClient = this.createPopupClient(request.correlationId);\n                    return popupClient.acquireToken(request);\n                } else if (e instanceof InteractionRequiredAuthError) {\n                    this.logger.verbose(\"acquireTokenPopup - Resolving interaction required error thrown by native broker by falling back to web flow\");\n                    const popupClient = this.createPopupClient(request.correlationId);\n                    return popupClient.acquireToken(request);\n                }\n                this.browserStorage.setInteractionInProgress(false);\n                throw e;\n            });\n        } else {\n            const popupClient = this.createPopupClient(request.correlationId);\n            result = popupClient.acquireToken(request);\n        }\n\n        return result.then((result) => {\n\n            /*\n             *  If logged in, emit acquire token events\n             */\n            const isLoggingIn = loggedInAccounts.length < this.getAllAccounts().length;\n            if (isLoggingIn) {\n                this.eventHandler.emitEvent(EventType.LOGIN_SUCCESS, InteractionType.Popup, result);\n            } else {\n                this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Popup, result);\n            }\n\n            atPopupMeasurement.endMeasurement({\n                success: true,\n                accessTokenSize: result.accessToken.length,\n                idTokenSize: result.idToken.length,\n                requestId: result.requestId\n            });\n\n            atPopupMeasurement.flushMeasurement();\n            return result;\n        }).catch((e: AuthError) => {\n            if (loggedInAccounts.length > 0) {\n                this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Popup, null, e);\n            } else {\n                this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Popup, null, e);\n            }\n\n            atPopupMeasurement.endMeasurement({\n                errorCode: e.errorCode,\n                subErrorCode: e.subError,\n                success: false\n            });\n            atPopupMeasurement.flushMeasurement();\n\n            // Since this function is syncronous we need to reject\n            return Promise.reject(e);\n        });\n    }\n\n    // #endregion\n\n    // #region Silent Flow\n\n    /**\n     * This function uses a hidden iframe to fetch an authorization code from the eSTS. There are cases where this may not work:\n     * - Any browser using a form of Intelligent Tracking Prevention\n     * - If there is not an established session with the service\n     *\n     * In these cases, the request must be done inside a popup or full frame redirect.\n     *\n     * For the cases where interaction is required, you cannot send a request with prompt=none.\n     *\n     * If your refresh token has expired, you can use this function to fetch a new set of tokens silently as long as\n     * you session on the server still exists.\n     * @param request {@link SsoSilentRequest}\n     *\n     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\n     */\n    async ssoSilent(request: SsoSilentRequest): Promise<AuthenticationResult> {\n        const correlationId = this.getRequestCorrelationId(request);\n        const validRequest = {\n            ...request,\n            // will be PromptValue.NONE or PromptValue.NO_SESSION\n            prompt: request.prompt,\n            correlationId: correlationId\n        };\n        this.preflightBrowserEnvironmentCheck(InteractionType.Silent);\n        const ssoSilentMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.SsoSilent, correlationId);\n        this.logger.verbose(\"ssoSilent called\", correlationId);\n        this.eventHandler.emitEvent(EventType.SSO_SILENT_START, InteractionType.Silent, validRequest);\n\n        let result: Promise<AuthenticationResult>;\n\n        if (this.canUseNative(validRequest)) {\n            result = this.acquireTokenNative(validRequest, ApiId.ssoSilent).catch((e: AuthError) => {\n                // If native token acquisition fails for availability reasons fallback to standard flow\n                if (e instanceof NativeAuthError && e.isFatal()) {\n                    this.nativeExtensionProvider = undefined; // If extension gets uninstalled during session prevent future requests from continuing to attempt\n                    const silentIframeClient = this.createSilentIframeClient(validRequest.correlationId);\n                    return silentIframeClient.acquireToken(validRequest);\n                }\n                throw e;\n            });\n        } else {\n            const silentIframeClient = this.createSilentIframeClient(validRequest.correlationId);\n            result = silentIframeClient.acquireToken(validRequest);\n        }\n\n        return result.then((response) => {\n            this.eventHandler.emitEvent(EventType.SSO_SILENT_SUCCESS, InteractionType.Silent, response);\n            ssoSilentMeasurement.endMeasurement({\n                success: true,\n                isNativeBroker: response.fromNativeBroker,\n                accessTokenSize: response.accessToken.length,\n                idTokenSize: response.idToken.length,\n                requestId: response.requestId\n            });\n            ssoSilentMeasurement.flushMeasurement();\n            return response;\n        }).catch((e: AuthError) => {\n            this.eventHandler.emitEvent(EventType.SSO_SILENT_FAILURE, InteractionType.Silent, null, e);\n            ssoSilentMeasurement.endMeasurement({\n                errorCode: e.errorCode,\n                subErrorCode: e.subError,\n                success: false\n            });\n            ssoSilentMeasurement.flushMeasurement();\n            throw e;\n        });\n    }\n\n    /**\n     * This function redeems an authorization code (passed as code) from the eSTS token endpoint.\n     * This authorization code should be acquired server-side using a confidential client to acquire a spa_code.\n     * This API is not indended for normal authorization code acquisition and redemption.\n     *\n     * Redemption of this authorization code will not require PKCE, as it was acquired by a confidential client.\n     *\n     * @param request {@link AuthorizationCodeRequest}\n     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\n     */\n    async acquireTokenByCode(request: AuthorizationCodeRequest): Promise<AuthenticationResult> {\n        const correlationId = this.getRequestCorrelationId(request);\n        this.preflightBrowserEnvironmentCheck(InteractionType.Silent);\n        this.logger.trace(\"acquireTokenByCode called\", correlationId);\n        this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_START, InteractionType.Silent, request);\n        const atbcMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenByCode, request.correlationId);\n\n        try {\n            if (request.code) {\n                const hybridAuthCode = request.code;\n                let response = this.hybridAuthCodeResponses.get(hybridAuthCode);\n                if (!response) {\n                    this.logger.verbose(\"Initiating new acquireTokenByCode request\", correlationId);\n                    response = this.acquireTokenByCodeAsync({\n                        ...request,\n                        correlationId\n                    })\n                        .then((result: AuthenticationResult) => {\n                            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_SUCCESS, InteractionType.Silent, result);\n                            this.hybridAuthCodeResponses.delete(hybridAuthCode);\n                            atbcMeasurement.endMeasurement({\n                                success: true,\n                                accessTokenSize: result.accessToken.length,\n                                idTokenSize: result.idToken.length,\n                                isNativeBroker: result.fromNativeBroker,\n                                requestId: result.requestId\n                            });\n                            atbcMeasurement.flushMeasurement();\n                            return result;\n                        })\n                        .catch((error: AuthError) => {\n                            this.hybridAuthCodeResponses.delete(hybridAuthCode);\n                            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_FAILURE, InteractionType.Silent, null, error);\n                            atbcMeasurement.endMeasurement({\n                                errorCode: error.errorCode,\n                                subErrorCode: error.subError,\n                                success: false\n                            });\n                            atbcMeasurement.flushMeasurement();\n                            throw error;\n                        });\n                    this.hybridAuthCodeResponses.set(hybridAuthCode, response);\n                } else {\n                    this.logger.verbose(\"Existing acquireTokenByCode request found\", request.correlationId);\n                    atbcMeasurement.endMeasurement({\n                        success: true\n                    });\n                    atbcMeasurement.discardMeasurement();\n                }\n                return response;\n            } else if (request.nativeAccountId) {\n                if (this.canUseNative(request, request.nativeAccountId)) {\n                    return this.acquireTokenNative(request, ApiId.acquireTokenByCode, request.nativeAccountId).catch((e: AuthError) => {\n                        // If native token acquisition fails for availability reasons fallback to standard flow\n                        if (e instanceof NativeAuthError && e.isFatal()) {\n                            this.nativeExtensionProvider = undefined; // If extension gets uninstalled during session prevent future requests from continuing to attempt\n                        }\n                        throw e;\n                    });\n                } else {\n                    throw BrowserAuthError.createUnableToAcquireTokenFromNativePlatformError();\n                }\n            } else {\n                throw BrowserAuthError.createAuthCodeOrNativeAccountIdRequiredError();\n            }\n\n        } catch (e) {\n            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_FAILURE, InteractionType.Silent, null, e);\n            atbcMeasurement.endMeasurement({\n                errorCode: e instanceof AuthError && e.errorCode || undefined,\n                subErrorCode: e instanceof AuthError && e.subError || undefined,\n                success: false\n            });\n            throw e;\n        }\n    }\n\n    /**\n     * Creates a SilentAuthCodeClient to redeem an authorization code.\n     * @param request\n     * @returns Result of the operation to redeem the authorization code\n     */\n    private async acquireTokenByCodeAsync(request: AuthorizationCodeRequest): Promise<AuthenticationResult> {\n        this.logger.trace(\"acquireTokenByCodeAsync called\", request.correlationId);\n        const silentAuthCodeClient = this.createSilentAuthCodeClient(request.correlationId);\n        const silentTokenResult = await silentAuthCodeClient.acquireToken(request);\n        return silentTokenResult;\n    }\n\n    /**\n     * Attempt to acquire an access token from the cache\n     * @param silentCacheClient SilentCacheClient\n     * @param commonRequest CommonSilentFlowRequest\n     * @param silentRequest SilentRequest\n     * @returns A promise that, when resolved, returns the access token\n     */\n    protected async acquireTokenFromCache(\n        silentCacheClient: SilentCacheClient,\n        commonRequest: CommonSilentFlowRequest,\n        silentRequest: SilentRequest\n    ): Promise<AuthenticationResult> {\n        switch(silentRequest.cacheLookupPolicy) {\n            case CacheLookupPolicy.Default:\n            case CacheLookupPolicy.AccessToken:\n            case CacheLookupPolicy.AccessTokenAndRefreshToken:\n                return silentCacheClient.acquireToken(commonRequest);\n            default:\n                throw ClientAuthError.createRefreshRequiredError();\n        }\n    }\n\n    /**\n     * Attempt to acquire an access token via a refresh token\n     * @param commonRequest CommonSilentFlowRequest\n     * @param silentRequest SilentRequest\n     * @returns A promise that, when resolved, returns the access token\n     */\n    protected async acquireTokenByRefreshToken(\n        commonRequest: CommonSilentFlowRequest,\n        silentRequest: SilentRequest\n    ): Promise<AuthenticationResult> {\n        switch(silentRequest.cacheLookupPolicy) {\n            case CacheLookupPolicy.Default:\n            case CacheLookupPolicy.AccessTokenAndRefreshToken:\n            case CacheLookupPolicy.RefreshToken:\n            case CacheLookupPolicy.RefreshTokenAndNetwork:\n                const silentRefreshClient = this.createSilentRefreshClient(commonRequest.correlationId);\n                return silentRefreshClient.acquireToken(commonRequest);\n            default:\n                throw ClientAuthError.createRefreshRequiredError();\n        }\n    }\n\n    /**\n     * Attempt to acquire an access token via an iframe\n     * @param request CommonSilentFlowRequest\n     * @returns A promise that, when resolved, returns the access token\n     */\n    protected async acquireTokenBySilentIframe(\n        request: CommonSilentFlowRequest\n    ): Promise<AuthenticationResult> {\n        const silentIframeClient = this.createSilentIframeClient(request.correlationId);\n        return silentIframeClient.acquireToken(request);\n    }\n\n    // #endregion\n\n    // #region Logout\n\n    /**\n     * Deprecated logout function. Use logoutRedirect or logoutPopup instead\n     * @param logoutRequest\n     * @deprecated\n     */\n    async logout(logoutRequest?: EndSessionRequest): Promise<void> {\n        const correlationId = this.getRequestCorrelationId(logoutRequest);\n        this.logger.warning(\"logout API is deprecated and will be removed in msal-browser v3.0.0. Use logoutRedirect instead.\", correlationId);\n        return this.logoutRedirect({\n            correlationId,\n            ...logoutRequest\n        });\n    }\n\n    /**\n     * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\n     * Default behaviour is to redirect the user to `window.location.href`.\n     * @param logoutRequest\n     */\n    async logoutRedirect(logoutRequest?: EndSessionRequest): Promise<void> {\n        const correlationId = this.getRequestCorrelationId(logoutRequest);\n        this.preflightBrowserEnvironmentCheck(InteractionType.Redirect);\n\n        const redirectClient = this.createRedirectClient(correlationId);\n        return redirectClient.logout(logoutRequest);\n    }\n\n    /**\n     * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server\n     * @param logoutRequest\n     */\n    logoutPopup(logoutRequest?: EndSessionPopupRequest): Promise<void> {\n        try {\n            const correlationId = this.getRequestCorrelationId(logoutRequest);\n            this.preflightBrowserEnvironmentCheck(InteractionType.Popup);\n            const popupClient = this.createPopupClient(correlationId);\n            return popupClient.logout(logoutRequest);\n        } catch (e) {\n            // Since this function is syncronous we need to reject\n            return Promise.reject(e);\n        }\n    }\n\n    // #endregion\n\n    // #region Account APIs\n\n    /**\n     * Returns all accounts that MSAL currently has data for.\n     * (the account object is created at the time of successful login)\n     * or empty array when no accounts are found\n     * @returns Array of account objects in cache\n     */\n    getAllAccounts(): AccountInfo[] {\n        this.logger.verbose(\"getAllAccounts called\");\n        return this.isBrowserEnvironment ? this.browserStorage.getAllAccounts() : [];\n    }\n\n    /**\n     * Returns the signed in account matching username.\n     * (the account object is created at the time of successful login)\n     * or null when no matching account is found.\n     * This API is provided for convenience but getAccountById should be used for best reliability\n     * @param userName\n     * @returns The account object stored in MSAL\n     */\n    getAccountByUsername(userName: string): AccountInfo | null {\n        const allAccounts = this.getAllAccounts();\n        if (!StringUtils.isEmpty(userName) && allAccounts && allAccounts.length) {\n            this.logger.verbose(\"Account matching username found, returning\");\n            this.logger.verbosePii(`Returning signed-in accounts matching username: ${userName}`);\n            return allAccounts.filter(accountObj => accountObj.username.toLowerCase() === userName.toLowerCase())[0] || null;\n        } else {\n            this.logger.verbose(\"getAccountByUsername: No matching account found, returning null\");\n            return null;\n        }\n    }\n\n    /**\n     * Returns the signed in account matching homeAccountId.\n     * (the account object is created at the time of successful login)\n     * or null when no matching account is found\n     * @param homeAccountId\n     * @returns The account object stored in MSAL\n     */\n    getAccountByHomeId(homeAccountId: string): AccountInfo | null {\n        const allAccounts = this.getAllAccounts();\n        if (!StringUtils.isEmpty(homeAccountId) && allAccounts && allAccounts.length) {\n            this.logger.verbose(\"Account matching homeAccountId found, returning\");\n            this.logger.verbosePii(`Returning signed-in accounts matching homeAccountId: ${homeAccountId}`);\n            return allAccounts.filter(accountObj => accountObj.homeAccountId === homeAccountId)[0] || null;\n        } else {\n            this.logger.verbose(\"getAccountByHomeId: No matching account found, returning null\");\n            return null;\n        }\n    }\n\n    /**\n     * Returns the signed in account matching localAccountId.\n     * (the account object is created at the time of successful login)\n     * or null when no matching account is found\n     * @param localAccountId\n     * @returns The account object stored in MSAL\n     */\n    getAccountByLocalId(localAccountId: string): AccountInfo | null {\n        const allAccounts = this.getAllAccounts();\n        if (!StringUtils.isEmpty(localAccountId) && allAccounts && allAccounts.length) {\n            this.logger.verbose(\"Account matching localAccountId found, returning\");\n            this.logger.verbosePii(`Returning signed-in accounts matching localAccountId: ${localAccountId}`);\n            return allAccounts.filter(accountObj => accountObj.localAccountId === localAccountId)[0] || null;\n        } else {\n            this.logger.verbose(\"getAccountByLocalId: No matching account found, returning null\");\n            return null;\n        }\n    }\n\n    /**\n     * Sets the account to use as the active account. If no account is passed to the acquireToken APIs, then MSAL will use this active account.\n     * @param account\n     */\n    setActiveAccount(account: AccountInfo | null): void {\n        this.browserStorage.setActiveAccount(account);\n    }\n\n    /**\n     * Gets the currently active account\n     */\n    getActiveAccount(): AccountInfo | null {\n        return this.browserStorage.getActiveAccount();\n    }\n\n    // #endregion\n\n    // #region Helpers\n\n    /**\n     * Helper to validate app environment before making an auth request\n     *\n     * @protected\n     * @param {InteractionType} interactionType What kind of interaction is being used\n     * @param {boolean} [setInteractionInProgress=true] Whether to set interaction in progress temp cache flag\n     */\n    protected preflightBrowserEnvironmentCheck(interactionType: InteractionType, setInteractionInProgress: boolean = true): void {\n        this.logger.verbose(\"preflightBrowserEnvironmentCheck started\");\n        // Block request if not in browser environment\n        BrowserUtils.blockNonBrowserEnvironment(this.isBrowserEnvironment);\n\n        // Block redirects if in an iframe\n        BrowserUtils.blockRedirectInIframe(interactionType, this.config.system.allowRedirectInIframe);\n\n        // Block auth requests inside a hidden iframe\n        BrowserUtils.blockReloadInHiddenIframes();\n\n        // Block redirectUri opened in a popup from calling MSAL APIs\n        BrowserUtils.blockAcquireTokenInPopups();\n\n        // Block token acquisition before initialize has been called if native brokering is enabled\n        BrowserUtils.blockNativeBrokerCalledBeforeInitialized(this.config.system.allowNativeBroker, this.initialized);\n\n        // Block redirects if memory storage is enabled but storeAuthStateInCookie is not\n        if (interactionType === InteractionType.Redirect &&\n            this.config.cache.cacheLocation === BrowserCacheLocation.MemoryStorage &&\n            !this.config.cache.storeAuthStateInCookie) {\n            throw BrowserConfigurationAuthError.createInMemoryRedirectUnavailableError();\n        }\n\n        if (interactionType === InteractionType.Redirect || interactionType === InteractionType.Popup) {\n            this.preflightInteractiveRequest(setInteractionInProgress);\n        }\n    }\n\n    /**\n     * Preflight check for interactive requests\n     *\n     * @protected\n     * @param {boolean} setInteractionInProgress Whether to set interaction in progress temp cache flag\n     */\n    protected preflightInteractiveRequest(setInteractionInProgress: boolean): void {\n        this.logger.verbose(\"preflightInteractiveRequest called, validating app environment\");\n        // block the reload if it occurred inside a hidden iframe\n        BrowserUtils.blockReloadInHiddenIframes();\n\n        // Set interaction in progress temporary cache or throw if alread set.\n        if (setInteractionInProgress) {\n            this.browserStorage.setInteractionInProgress(true);\n        }\n    }\n\n    /**\n     * Acquire a token from native device (e.g. WAM)\n     * @param request\n     */\n    protected async acquireTokenNative(request: PopupRequest | SilentRequest | SsoSilentRequest, apiId: ApiId, accountId?: string): Promise<AuthenticationResult> {\n        this.logger.trace(\"acquireTokenNative called\");\n        if (!this.nativeExtensionProvider) {\n            throw BrowserAuthError.createNativeConnectionNotEstablishedError();\n        }\n\n        const nativeClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, apiId, this.performanceClient, this.nativeExtensionProvider, accountId || this.getNativeAccountId(request), this.nativeInternalStorage, request.correlationId);\n\n        return nativeClient.acquireToken(request);\n    }\n\n    /**\n     * Returns boolean indicating if this request can use the native broker\n     * @param request\n     */\n    protected canUseNative(request: RedirectRequest | PopupRequest | SsoSilentRequest, accountId?: string): boolean {\n        this.logger.trace(\"canUseNative called\");\n        if (!NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeExtensionProvider, request.authenticationScheme)) {\n            this.logger.trace(\"canUseNative: isNativeAvailable returned false, returning false\");\n            return false;\n        }\n\n        if (request.prompt) {\n            switch (request.prompt) {\n                case PromptValue.NONE:\n                case PromptValue.CONSENT:\n                case PromptValue.LOGIN:\n                    this.logger.trace(\"canUseNative: prompt is compatible with native flow\");\n                    break;\n                default:\n                    this.logger.trace(`canUseNative: prompt = ${request.prompt} is not compatible with native flow, returning false`);\n                    return false;\n            }\n        }\n\n        if (!accountId && !this.getNativeAccountId(request)) {\n            this.logger.trace(\"canUseNative: nativeAccountId is not available, returning false\");\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the native accountId from the account\n     * @param request\n     * @returns\n     */\n    protected getNativeAccountId(request: RedirectRequest | PopupRequest | SsoSilentRequest): string {\n        const account = request.account || this.browserStorage.getAccountInfoByHints(request.loginHint, request.sid) || this.getActiveAccount();\n\n        return account && account.nativeAccountId || \"\";\n    }\n\n    /**\n     * Returns new instance of the Popup Interaction Client\n     * @param correlationId\n     */\n    protected createPopupClient(correlationId?: string): PopupClient {\n        return new PopupClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, correlationId);\n    }\n\n    /**\n     * Returns new instance of the Redirect Interaction Client\n     * @param correlationId\n     */\n    protected createRedirectClient(correlationId?: string): RedirectClient {\n        return new RedirectClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, correlationId);\n    }\n\n    /**\n     * Returns new instance of the Silent Iframe Interaction Client\n     * @param correlationId\n     */\n    protected createSilentIframeClient(correlationId?: string): SilentIframeClient {\n        return new SilentIframeClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.ssoSilent, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, correlationId);\n    }\n\n    /**\n     * Returns new instance of the Silent Cache Interaction Client\n     */\n    protected createSilentCacheClient(correlationId?: string): SilentCacheClient {\n        return new SilentCacheClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeExtensionProvider, correlationId);\n    }\n\n    /**\n     * Returns new instance of the Silent Refresh Interaction Client\n     */\n    protected createSilentRefreshClient(correlationId?: string): SilentRefreshClient {\n        return new SilentRefreshClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeExtensionProvider, correlationId);\n    }\n\n    /**\n     * Returns new instance of the Silent AuthCode Interaction Client\n     */\n    protected createSilentAuthCodeClient(correlationId?: string): SilentAuthCodeClient {\n        return new SilentAuthCodeClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenByCode, this.performanceClient, this.nativeExtensionProvider, correlationId);\n    }\n\n    /**\n     * Adds event callbacks to array\n     * @param callback\n     */\n    addEventCallback(callback: EventCallbackFunction): string | null {\n        return this.eventHandler.addEventCallback(callback);\n    }\n\n    /**\n     * Removes callback with provided id from callback array\n     * @param callbackId\n     */\n    removeEventCallback(callbackId: string): void {\n        this.eventHandler.removeEventCallback(callbackId);\n    }\n\n    /**\n     * Registers a callback to receive performance events.\n     *\n     * @param {PerformanceCallbackFunction} callback\n     * @returns {string}\n     */\n    addPerformanceCallback(callback: PerformanceCallbackFunction): string {\n        return this.performanceClient.addPerformanceCallback(callback);\n    }\n\n    /**\n     * Removes a callback registered with addPerformanceCallback.\n     *\n     * @param {string} callbackId\n     * @returns {boolean}\n     */\n    removePerformanceCallback(callbackId: string): boolean {\n        return this.performanceClient.removePerformanceCallback(callbackId);\n    }\n\n    /**\n     * Adds event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window\n     */\n    enableAccountStorageEvents(): void {\n        this.eventHandler.enableAccountStorageEvents();\n    }\n\n    /**\n     * Removes event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window\n     */\n    disableAccountStorageEvents(): void {\n        this.eventHandler.disableAccountStorageEvents();\n    }\n\n    /**\n     * Gets the token cache for the application.\n     */\n    getTokenCache(): ITokenCache {\n        return this.tokenCache;\n    }\n\n    /**\n     * Returns the logger instance\n     */\n    getLogger(): Logger {\n        return this.logger;\n    }\n\n    /**\n     * Replaces the default logger set in configurations with new Logger with new configurations\n     * @param logger Logger instance\n     */\n    setLogger(logger: Logger): void {\n        this.logger = logger;\n    }\n\n    /**\n     * Called by wrapper libraries (Angular & React) to set SKU and Version passed down to telemetry, logger, etc.\n     * @param sku\n     * @param version\n     */\n    initializeWrapperLibrary(sku: WrapperSKU, version: string): void {\n        // Validate the SKU passed in is one we expect\n        this.browserStorage.setWrapperMetadata(sku, version);\n    }\n\n    /**\n     * Sets navigation client\n     * @param navigationClient\n     */\n    setNavigationClient(navigationClient: INavigationClient): void {\n        this.navigationClient = navigationClient;\n    }\n\n    /**\n     * Returns the configuration object\n     */\n    getConfiguration(): BrowserConfiguration {\n        return this.config;\n    }\n\n    /**\n     * Generates a correlation id for a request if none is provided.\n     *\n     * @protected\n     * @param {?Partial<BaseAuthRequest>} [request]\n     * @returns {string}\n     */\n    protected getRequestCorrelationId(request?: Partial<BaseAuthRequest>): string {\n        if (request?.correlationId) {\n            return request.correlationId;\n        }\n\n        if (this.isBrowserEnvironment) {\n            return this.browserCrypto.createNewGuid();\n        }\n\n        /*\n         * Included for fallback for non-browser environments,\n         * and to ensure this method always returns a string.\n         */\n        return Constants.EMPTY_STRING;\n    }\n\n    // #endregion\n}\n"]},"metadata":{},"sourceType":"module"}