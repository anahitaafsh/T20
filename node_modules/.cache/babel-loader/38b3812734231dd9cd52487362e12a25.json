{"ast":null,"code":"/*! @azure/msal-browser v2.16.0 2021-07-22 */\n'use strict';\n\nimport { __extends, __spread } from '../_virtual/_tslib.js';\nimport { DEFAULT_CRYPTO_IMPLEMENTATION, AccountEntity, CacheManager, IdTokenEntity, AccessTokenEntity, RefreshTokenEntity, AppMetadataEntity, ServerTelemetryEntity, AuthorityMetadataEntity, PersistentCacheKeys, ThrottlingEntity, Constants, StringUtils, ProtocolUtils, CcsCredentialType } from '@azure/msal-common';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { BrowserCacheLocation, TemporaryCacheKeys } from '../utils/BrowserConstants.js';\nimport { BrowserStorage } from './BrowserStorage.js';\nimport { MemoryStorage } from './MemoryStorage.js';\nimport { BrowserProtocolUtils } from '../utils/BrowserProtocolUtils.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\n\nvar BrowserCacheManager =\n/** @class */\nfunction (_super) {\n  __extends(BrowserCacheManager, _super);\n\n  function BrowserCacheManager(clientId, cacheConfig, cryptoImpl, logger) {\n    var _this = _super.call(this, clientId, cryptoImpl) || this; // Cookie life calculation (hours * minutes * seconds * ms)\n\n\n    _this.COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\n    _this.cacheConfig = cacheConfig;\n    _this.logger = logger;\n    _this.internalStorage = new MemoryStorage();\n    _this.browserStorage = _this.setupBrowserStorage(_this.cacheConfig.cacheLocation);\n    _this.temporaryCacheStorage = _this.setupTemporaryCacheStorage(_this.cacheConfig.cacheLocation); // Migrate any cache entries from older versions of MSAL.\n\n    _this.migrateCacheEntries();\n\n    return _this;\n  }\n  /**\r\n   * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n   * @param cacheLocation\r\n   */\n\n\n  BrowserCacheManager.prototype.setupBrowserStorage = function (cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\n          return new BrowserStorage(cacheLocation);\n        } catch (e) {\n          this.logger.verbose(e);\n          break;\n        }\n\n    }\n\n    this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\n    return new MemoryStorage();\n  };\n  /**\r\n   *\r\n   * @param cacheLocation\r\n   */\n\n\n  BrowserCacheManager.prototype.setupTemporaryCacheStorage = function (cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\n          return new BrowserStorage(BrowserCacheLocation.SessionStorage);\n        } catch (e) {\n          this.logger.verbose(e);\n          return this.internalStorage;\n        }\n\n      case BrowserCacheLocation.MemoryStorage:\n      default:\n        return this.internalStorage;\n    }\n  };\n  /**\r\n   * Migrate all old cache entries to new schema. No rollback supported.\r\n   * @param storeAuthStateInCookie\r\n   */\n\n\n  BrowserCacheManager.prototype.migrateCacheEntries = function () {\n    var _this = this;\n\n    var idTokenKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ID_TOKEN;\n    var clientInfoKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.CLIENT_INFO;\n    var errorKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR;\n    var errorDescKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR_DESC;\n    var idTokenValue = this.browserStorage.getItem(idTokenKey);\n    var clientInfoValue = this.browserStorage.getItem(clientInfoKey);\n    var errorValue = this.browserStorage.getItem(errorKey);\n    var errorDescValue = this.browserStorage.getItem(errorDescKey);\n    var values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\n    var keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\n    keysToMigrate.forEach(function (cacheKey, index) {\n      return _this.migrateCacheEntry(cacheKey, values[index]);\n    });\n  };\n  /**\r\n   * Utility function to help with migration.\r\n   * @param newKey\r\n   * @param value\r\n   * @param storeAuthStateInCookie\r\n   */\n\n\n  BrowserCacheManager.prototype.migrateCacheEntry = function (newKey, value) {\n    if (value) {\n      this.setTemporaryCache(newKey, value, true);\n    }\n  };\n  /**\r\n   * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n   * @param input\r\n   */\n\n\n  BrowserCacheManager.prototype.validateAndParseJson = function (jsonValue) {\n    try {\n      var parsedJson = JSON.parse(jsonValue);\n      /**\r\n       * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n       * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n       * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n       *\r\n       */\n\n      return parsedJson && typeof parsedJson === \"object\" ? parsedJson : null;\n    } catch (error) {\n      return null;\n    }\n  };\n  /**\r\n   * fetches the entry from the browser storage based off the key\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.getItem = function (key) {\n    return this.browserStorage.getItem(key);\n  };\n  /**\r\n   * sets the entry in the browser storage\r\n   * @param key\r\n   * @param value\r\n   */\n\n\n  BrowserCacheManager.prototype.setItem = function (key, value) {\n    this.browserStorage.setItem(key, value);\n  };\n  /**\r\n   * fetch the account entity from the platform cache\r\n   * @param accountKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccount = function (accountKey) {\n    var account = this.getItem(accountKey);\n\n    if (!account) {\n      return null;\n    }\n\n    var parsedAccount = this.validateAndParseJson(account);\n\n    if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n      return null;\n    }\n\n    return CacheManager.toObject(new AccountEntity(), parsedAccount);\n  };\n  /**\r\n   * set account entity in the platform cache\r\n   * @param key\r\n   * @param value\r\n   */\n\n\n  BrowserCacheManager.prototype.setAccount = function (account) {\n    this.logger.trace(\"BrowserCacheManager.setAccount called\");\n    var key = account.generateAccountKey();\n    this.setItem(key, JSON.stringify(account));\n  };\n  /**\r\n   * generates idToken entity from a string\r\n   * @param idTokenKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getIdTokenCredential = function (idTokenKey) {\n    var value = this.getItem(idTokenKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    var parsedIdToken = this.validateAndParseJson(value);\n\n    if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\n    return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\n  };\n  /**\r\n   * set IdToken credential to the platform cache\r\n   * @param idToken\r\n   */\n\n\n  BrowserCacheManager.prototype.setIdTokenCredential = function (idToken) {\n    this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n    var idTokenKey = idToken.generateCredentialKey();\n    this.setItem(idTokenKey, JSON.stringify(idToken));\n  };\n  /**\r\n   * generates accessToken entity from a string\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccessTokenCredential = function (accessTokenKey) {\n    var value = this.getItem(accessTokenKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    var parsedAccessToken = this.validateAndParseJson(value);\n\n    if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\n    return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);\n  };\n  /**\r\n   * set accessToken credential to the platform cache\r\n   * @param accessToken\r\n   */\n\n\n  BrowserCacheManager.prototype.setAccessTokenCredential = function (accessToken) {\n    this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\n    var accessTokenKey = accessToken.generateCredentialKey();\n    this.setItem(accessTokenKey, JSON.stringify(accessToken));\n  };\n  /**\r\n   * generates refreshToken entity from a string\r\n   * @param refreshTokenKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getRefreshTokenCredential = function (refreshTokenKey) {\n    var value = this.getItem(refreshTokenKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    var parsedRefreshToken = this.validateAndParseJson(value);\n\n    if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\n    return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);\n  };\n  /**\r\n   * set refreshToken credential to the platform cache\r\n   * @param refreshToken\r\n   */\n\n\n  BrowserCacheManager.prototype.setRefreshTokenCredential = function (refreshToken) {\n    this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\n    var refreshTokenKey = refreshToken.generateCredentialKey();\n    this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\n  };\n  /**\r\n   * fetch appMetadata entity from the platform cache\r\n   * @param appMetadataKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getAppMetadata = function (appMetadataKey) {\n    var value = this.getItem(appMetadataKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n\n    var parsedMetadata = this.validateAndParseJson(value);\n\n    if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n    return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\n  };\n  /**\r\n   * set appMetadata entity to the platform cache\r\n   * @param appMetadata\r\n   */\n\n\n  BrowserCacheManager.prototype.setAppMetadata = function (appMetadata) {\n    this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n    var appMetadataKey = appMetadata.generateAppMetadataKey();\n    this.setItem(appMetadataKey, JSON.stringify(appMetadata));\n  };\n  /**\r\n   * fetch server telemetry entity from the platform cache\r\n   * @param serverTelemetryKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getServerTelemetry = function (serverTelemetryKey) {\n    var value = this.getItem(serverTelemetryKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n\n    var parsedMetadata = this.validateAndParseJson(value);\n\n    if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n    return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);\n  };\n  /**\r\n   * set server telemetry entity to the platform cache\r\n   * @param serverTelemetryKey\r\n   * @param serverTelemetry\r\n   */\n\n\n  BrowserCacheManager.prototype.setServerTelemetry = function (serverTelemetryKey, serverTelemetry) {\n    this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n    this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\n  };\n  /**\r\n   *\r\n   */\n\n\n  BrowserCacheManager.prototype.getAuthorityMetadata = function (key) {\n    var value = this.internalStorage.getItem(key);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\n      return null;\n    }\n\n    var parsedMetadata = this.validateAndParseJson(value);\n\n    if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\n      return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);\n    }\n\n    return null;\n  };\n  /**\r\n   *\r\n   */\n\n\n  BrowserCacheManager.prototype.getAuthorityMetadataKeys = function () {\n    var _this = this;\n\n    var allKeys = this.internalStorage.getKeys();\n    return allKeys.filter(function (key) {\n      return _this.isAuthorityMetadata(key);\n    });\n  };\n  /**\r\n   *\r\n   * @param entity\r\n   */\n\n\n  BrowserCacheManager.prototype.setAuthorityMetadata = function (key, entity) {\n    this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n    this.internalStorage.setItem(key, JSON.stringify(entity));\n  };\n  /**\r\n   * Gets the active account\r\n   */\n\n\n  BrowserCacheManager.prototype.getActiveAccount = function () {\n    var activeAccountIdKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n    var activeAccountId = this.browserStorage.getItem(activeAccountIdKey);\n\n    if (!activeAccountId) {\n      return null;\n    }\n\n    return this.getAccountInfoByFilter({\n      localAccountId: activeAccountId\n    })[0] || null;\n  };\n  /**\r\n   * Sets the active account's localAccountId in cache\r\n   * @param account\r\n   */\n\n\n  BrowserCacheManager.prototype.setActiveAccount = function (account) {\n    var activeAccountIdKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n\n    if (account) {\n      this.logger.verbose(\"setActiveAccount: Active account set\");\n      this.browserStorage.setItem(activeAccountIdKey, account.localAccountId);\n    } else {\n      this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\n      this.browserStorage.removeItem(activeAccountIdKey);\n    }\n  };\n  /**\r\n   * Gets a list of accounts that match all of the filters provided\r\n   * @param account\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccountInfoByFilter = function (accountFilter) {\n    var allAccounts = this.getAllAccounts();\n    return allAccounts.filter(function (accountObj) {\n      if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {\n        return false;\n      }\n\n      if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {\n        return false;\n      }\n\n      if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {\n        return false;\n      }\n\n      if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {\n        return false;\n      }\n\n      if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {\n        return false;\n      }\n\n      return true;\n    });\n  };\n  /**\r\n   * fetch throttling entity from the platform cache\r\n   * @param throttlingCacheKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getThrottlingCache = function (throttlingCacheKey) {\n    var value = this.getItem(throttlingCacheKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n\n    var parsedThrottlingCache = this.validateAndParseJson(value);\n\n    if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n    return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);\n  };\n  /**\r\n   * set throttling entity to the platform cache\r\n   * @param throttlingCacheKey\r\n   * @param throttlingCache\r\n   */\n\n\n  BrowserCacheManager.prototype.setThrottlingCache = function (throttlingCacheKey, throttlingCache) {\n    this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n    this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\n  };\n  /**\r\n   * Gets cache item with given key.\r\n   * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.getTemporaryCache = function (cacheKey, generateKey) {\n    var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      var itemCookie = this.getItemCookie(key);\n\n      if (itemCookie) {\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\n        return itemCookie;\n      }\n    }\n\n    var value = this.temporaryCacheStorage.getItem(key);\n\n    if (!value) {\n      // If temp cache item not found in session/memory, check local storage for items set by old versions\n      if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n        var item = this.browserStorage.getItem(key);\n\n        if (item) {\n          this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\n          return item;\n        }\n      }\n\n      this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\n    return value;\n  };\n  /**\r\n   * Sets the cache item with the key and value given.\r\n   * Stores in cookie if storeAuthStateInCookie is set to true.\r\n   * This can cause cookie overflow if used incorrectly.\r\n   * @param key\r\n   * @param value\r\n   */\n\n\n  BrowserCacheManager.prototype.setTemporaryCache = function (cacheKey, value, generateKey) {\n    var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    this.temporaryCacheStorage.setItem(key, value);\n\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\n      this.setItemCookie(key, value);\n    }\n  };\n  /**\r\n   * Removes the cache item with the given key.\r\n   * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.removeItem = function (key) {\n    this.browserStorage.removeItem(key);\n    this.temporaryCacheStorage.removeItem(key);\n\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\n      this.clearItemCookie(key);\n    }\n\n    return true;\n  };\n  /**\r\n   * Checks whether key is in cache.\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.containsKey = function (key) {\n    return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key);\n  };\n  /**\r\n   * Gets all keys in window.\r\n   */\n\n\n  BrowserCacheManager.prototype.getKeys = function () {\n    return __spread(this.browserStorage.getKeys(), this.temporaryCacheStorage.getKeys());\n  };\n  /**\r\n   * Clears all cache entries created by MSAL (except tokens).\r\n   */\n\n\n  BrowserCacheManager.prototype.clear = function () {\n    var _this = this;\n\n    this.removeAllAccounts();\n    this.removeAppMetadata();\n    this.getKeys().forEach(function (cacheKey) {\n      // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\n      if ((_this.browserStorage.containsKey(cacheKey) || _this.temporaryCacheStorage.containsKey(cacheKey)) && (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(_this.clientId) !== -1)) {\n        _this.removeItem(cacheKey);\n      }\n    });\n    this.internalStorage.clear();\n  };\n  /**\r\n   * Add value to cookies\r\n   * @param cookieName\r\n   * @param cookieValue\r\n   * @param expires\r\n   */\n\n\n  BrowserCacheManager.prototype.setItemCookie = function (cookieName, cookieValue, expires) {\n    var cookieStr = encodeURIComponent(cookieName) + \"=\" + encodeURIComponent(cookieValue) + \";path=/;\";\n\n    if (expires) {\n      var expireTime = this.getCookieExpirationTime(expires);\n      cookieStr += \"expires=\" + expireTime + \";\";\n    }\n\n    if (this.cacheConfig.secureCookies) {\n      cookieStr += \"Secure;\";\n    }\n\n    document.cookie = cookieStr;\n  };\n  /**\r\n   * Get one item by key from cookies\r\n   * @param cookieName\r\n   */\n\n\n  BrowserCacheManager.prototype.getItemCookie = function (cookieName) {\n    var name = encodeURIComponent(cookieName) + \"=\";\n    var cookieList = document.cookie.split(\";\");\n\n    for (var i = 0; i < cookieList.length; i++) {\n      var cookie = cookieList[i];\n\n      while (cookie.charAt(0) === \" \") {\n        cookie = cookie.substring(1);\n      }\n\n      if (cookie.indexOf(name) === 0) {\n        return decodeURIComponent(cookie.substring(name.length, cookie.length));\n      }\n    }\n\n    return \"\";\n  };\n  /**\r\n   * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\r\n   */\n\n\n  BrowserCacheManager.prototype.clearMsalCookies = function () {\n    var _this = this;\n\n    var cookiePrefix = Constants.CACHE_PREFIX + \".\" + this.clientId;\n    var cookieList = document.cookie.split(\";\");\n    cookieList.forEach(function (cookie) {\n      while (cookie.charAt(0) === \" \") {\n        // eslint-disable-next-line no-param-reassign\n        cookie = cookie.substring(1);\n      }\n\n      if (cookie.indexOf(cookiePrefix) === 0) {\n        var cookieKey = cookie.split(\"=\")[0];\n\n        _this.clearItemCookie(cookieKey);\n      }\n    });\n  };\n  /**\r\n   * Clear an item in the cookies by key\r\n   * @param cookieName\r\n   */\n\n\n  BrowserCacheManager.prototype.clearItemCookie = function (cookieName) {\n    this.setItemCookie(cookieName, \"\", -1);\n  };\n  /**\r\n   * Get cookie expiration time\r\n   * @param cookieLifeDays\r\n   */\n\n\n  BrowserCacheManager.prototype.getCookieExpirationTime = function (cookieLifeDays) {\n    var today = new Date();\n    var expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);\n    return expr.toUTCString();\n  };\n  /**\r\n   * Gets the cache object referenced by the browser\r\n   */\n\n\n  BrowserCacheManager.prototype.getCache = function () {\n    return this.browserStorage;\n  };\n  /**\r\n   * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\r\n   */\n\n\n  BrowserCacheManager.prototype.setCache = function () {// sets nothing\n  };\n  /**\r\n   * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n   * @param key\r\n   * @param addInstanceId\r\n   */\n\n\n  BrowserCacheManager.prototype.generateCacheKey = function (key) {\n    var generatedKey = this.validateAndParseJson(key);\n\n    if (!generatedKey) {\n      if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\n        return key;\n      }\n\n      return Constants.CACHE_PREFIX + \".\" + this.clientId + \".\" + key;\n    }\n\n    return JSON.stringify(key);\n  };\n  /**\r\n   * Create authorityKey to cache authority\r\n   * @param state\r\n   */\n\n\n  BrowserCacheManager.prototype.generateAuthorityKey = function (stateString) {\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.AUTHORITY + \".\" + stateId);\n  };\n  /**\r\n   * Create Nonce key to cache nonce\r\n   * @param state\r\n   */\n\n\n  BrowserCacheManager.prototype.generateNonceKey = function (stateString) {\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN + \".\" + stateId);\n  };\n  /**\r\n   * Creates full cache key for the request state\r\n   * @param stateString State string for the request\r\n   */\n\n\n  BrowserCacheManager.prototype.generateStateKey = function (stateString) {\n    // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.REQUEST_STATE + \".\" + stateId);\n  };\n  /**\r\n   * Gets the cached authority based on the cached state. Returns empty if no cached state found.\r\n   */\n\n\n  BrowserCacheManager.prototype.getCachedAuthority = function (cachedState) {\n    var stateCacheKey = this.generateStateKey(cachedState);\n    var state = this.getTemporaryCache(stateCacheKey);\n\n    if (!state) {\n      return null;\n    }\n\n    var authorityCacheKey = this.generateAuthorityKey(state);\n    return this.getTemporaryCache(authorityCacheKey);\n  };\n  /**\r\n   * Updates account, authority, and state in cache\r\n   * @param serverAuthenticationRequest\r\n   * @param account\r\n   */\n\n\n  BrowserCacheManager.prototype.updateCacheEntries = function (state, nonce, authorityInstance, loginHint, account) {\n    this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\"); // Cache the request state\n\n    var stateCacheKey = this.generateStateKey(state);\n    this.setTemporaryCache(stateCacheKey, state, false); // Cache the nonce\n\n    var nonceCacheKey = this.generateNonceKey(state);\n    this.setTemporaryCache(nonceCacheKey, nonce, false); // Cache authorityKey\n\n    var authorityCacheKey = this.generateAuthorityKey(state);\n    this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\n\n    if (account) {\n      var ccsCredential = {\n        credential: account.homeAccountId,\n        type: CcsCredentialType.HOME_ACCOUNT_ID\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    } else if (!StringUtils.isEmpty(loginHint)) {\n      var ccsCredential = {\n        credential: loginHint,\n        type: CcsCredentialType.UPN\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    }\n  };\n  /**\r\n   * Reset all temporary cache items\r\n   * @param state\r\n   */\n\n\n  BrowserCacheManager.prototype.resetRequestCache = function (state) {\n    var _this = this;\n\n    this.logger.trace(\"BrowserCacheManager.resetRequestCache called\"); // check state and remove associated cache items\n\n    if (!StringUtils.isEmpty(state)) {\n      this.getKeys().forEach(function (key) {\n        if (key.indexOf(state) !== -1) {\n          _this.removeItem(key);\n        }\n      });\n    } // delete generic interactive request parameters\n\n\n    if (state) {\n      this.removeItem(this.generateStateKey(state));\n      this.removeItem(this.generateNonceKey(state));\n      this.removeItem(this.generateAuthorityKey(state));\n    }\n\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.INTERACTION_STATUS_KEY));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\n  };\n  /**\r\n   * Removes temporary cache for the provided state\r\n   * @param stateString\r\n   */\n\n\n  BrowserCacheManager.prototype.cleanRequestByState = function (stateString) {\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\"); // Interaction is completed - remove interaction status.\n\n    if (stateString) {\n      var stateKey = this.generateStateKey(stateString);\n      var cachedState = this.temporaryCacheStorage.getItem(stateKey);\n      this.logger.infoPii(\"BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: \" + cachedState);\n      this.resetRequestCache(cachedState || \"\");\n    }\n\n    this.clearMsalCookies();\n  };\n  /**\r\n   * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\r\n   * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\r\n   * @param interactionType\r\n   */\n\n\n  BrowserCacheManager.prototype.cleanRequestByInteractionType = function (interactionType) {\n    var _this = this;\n\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\"); // Loop through all keys to find state key\n\n    this.getKeys().forEach(function (key) {\n      // If this key is not the state key, move on\n      if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\n        return;\n      } // Retrieve state value, return if not a valid value\n\n\n      var stateValue = _this.temporaryCacheStorage.getItem(key);\n\n      if (!stateValue) {\n        return;\n      } // Extract state and ensure it matches given InteractionType, then clean request cache\n\n\n      var parsedState = BrowserProtocolUtils.extractBrowserRequestState(_this.cryptoImpl, stateValue);\n\n      if (parsedState && parsedState.interactionType === interactionType) {\n        _this.logger.infoPii(\"BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: \" + stateValue);\n\n        _this.resetRequestCache(stateValue);\n      }\n    });\n    this.clearMsalCookies();\n  };\n\n  BrowserCacheManager.prototype.cacheCodeRequest = function (authCodeRequest, browserCrypto) {\n    this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\n    var encodedValue = browserCrypto.base64Encode(JSON.stringify(authCodeRequest));\n    this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\n  };\n  /**\r\n   * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n   */\n\n\n  BrowserCacheManager.prototype.getCachedRequest = function (state, browserCrypto) {\n    this.logger.trace(\"BrowserCacheManager.getCachedRequest called\"); // Get token request from cache and parse as TokenExchangeParameters.\n\n    var encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\n\n    if (!encodedTokenRequest) {\n      throw BrowserAuthError.createNoTokenRequestCacheError();\n    }\n\n    var parsedRequest = this.validateAndParseJson(browserCrypto.base64Decode(encodedTokenRequest));\n\n    if (!parsedRequest) {\n      throw BrowserAuthError.createUnableToParseTokenRequestCacheError();\n    }\n\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS)); // Get cached authority and use if no authority is cached with request.\n\n    if (StringUtils.isEmpty(parsedRequest.authority)) {\n      var authorityCacheKey = this.generateAuthorityKey(state);\n      var cachedAuthority = this.getTemporaryCache(authorityCacheKey);\n\n      if (!cachedAuthority) {\n        throw BrowserAuthError.createNoCachedAuthorityError();\n      }\n\n      parsedRequest.authority = cachedAuthority;\n    }\n\n    return parsedRequest;\n  };\n\n  return BrowserCacheManager;\n}(CacheManager);\n\nvar DEFAULT_BROWSER_CACHE_MANAGER = function (clientId, logger) {\n  var cacheOptions = {\n    cacheLocation: BrowserCacheLocation.MemoryStorage,\n    storeAuthStateInCookie: false,\n    secureCookies: false\n  };\n  return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\n};\n\nexport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER };","map":{"version":3,"mappings":";;;;;;;;;;AAAA;;;;;AAcA;;;;;;;;;EAKyCA;;EAgBrC,6BAAYC,QAAZ,EAA8BC,WAA9B,EAAmEC,UAAnE,EAAwFC,MAAxF,EAAsG;IAAtG,YACIC,kBAAMJ,QAAN,EAAgBE,UAAhB,KAA2B,IAD/B,CAAsG;;;IAFrFG,+BAAyB,KAAK,EAAL,GAAU,EAAV,GAAe,IAAxC;IAKbA,KAAI,CAACJ,WAAL,GAAmBA,WAAnB;IACAI,KAAI,CAACF,MAAL,GAAcA,MAAd;IAEAE,KAAI,CAACC,eAAL,GAAuB,IAAIC,aAAJ,EAAvB;IACAF,KAAI,CAACG,cAAL,GAAsBH,KAAI,CAACI,mBAAL,CAAyBJ,KAAI,CAACJ,WAAL,CAAiBS,aAA1C,CAAtB;IACAL,KAAI,CAACM,qBAAL,GAA6BN,KAAI,CAACO,0BAAL,CAAgCP,KAAI,CAACJ,WAAL,CAAiBS,aAAjD,CAA7B,CARkG;;IAWlGL,KAAI,CAACQ,mBAAL;;;EACH;;;;;;;EAMOC,oDAAR,UAA4BJ,aAA5B,EAAwE;IACpE,QAAQA,aAAR;MACI,KAAKK,oBAAoB,CAACC,YAA1B;MACA,KAAKD,oBAAoB,CAACE,cAA1B;QACI,IAAI;;UAEA,OAAO,IAAIC,cAAJ,CAAmBR,aAAnB,CAAP;QACH,CAHD,CAGE,OAAOS,CAAP,EAAU;UACR,KAAKhB,MAAL,CAAYiB,OAAZ,CAAoBD,CAApB;UACA;QACH;;IATT;;IAcA,KAAKlB,WAAL,CAAiBS,aAAjB,GAAiCK,oBAAoB,CAACR,aAAtD;IACA,OAAO,IAAIA,aAAJ,EAAP;EACH,CAjBO;;;;;;;EAuBAO,2DAAR,UAAmCJ,aAAnC,EAA+E;IAC3E,QAAQA,aAAR;MACI,KAAKK,oBAAoB,CAACC,YAA1B;MACA,KAAKD,oBAAoB,CAACE,cAA1B;QACI,IAAI;;UAEA,OAAO,IAAIC,cAAJ,CAAmBH,oBAAoB,CAACE,cAAxC,CAAP;QACH,CAHD,CAGE,OAAOE,CAAP,EAAU;UACR,KAAKhB,MAAL,CAAYiB,OAAZ,CAAoBD,CAApB;UACA,OAAO,KAAKb,eAAZ;QACH;;MACL,KAAKS,oBAAoB,CAACR,aAA1B;MACA;QACI,OAAO,KAAKD,eAAZ;IAZR;EAcH,CAfO;;;;;;;EAqBAQ,oDAAR;IAAA;;IACI,IAAMO,UAAU,GAAMC,SAAS,CAACC,YAAV,GAAsB,GAAtB,GAA0BC,mBAAmB,CAACC,QAApE;IACA,IAAMC,aAAa,GAAMJ,SAAS,CAACC,YAAV,GAAsB,GAAtB,GAA0BC,mBAAmB,CAACG,WAAvE;IACA,IAAMC,QAAQ,GAAMN,SAAS,CAACC,YAAV,GAAsB,GAAtB,GAA0BC,mBAAmB,CAACK,KAAlE;IACA,IAAMC,YAAY,GAAMR,SAAS,CAACC,YAAV,GAAsB,GAAtB,GAA0BC,mBAAmB,CAACO,UAAtE;IAEA,IAAMC,YAAY,GAAG,KAAKxB,cAAL,CAAoByB,OAApB,CAA4BZ,UAA5B,CAArB;IACA,IAAMa,eAAe,GAAG,KAAK1B,cAAL,CAAoByB,OAApB,CAA4BP,aAA5B,CAAxB;IACA,IAAMS,UAAU,GAAG,KAAK3B,cAAL,CAAoByB,OAApB,CAA4BL,QAA5B,CAAnB;IACA,IAAMQ,cAAc,GAAG,KAAK5B,cAAL,CAAoByB,OAApB,CAA4BH,YAA5B,CAAvB;IAEA,IAAMO,MAAM,GAAG,CAACL,YAAD,EAAeE,eAAf,EAAgCC,UAAhC,EAA4CC,cAA5C,CAAf;IACA,IAAME,aAAa,GAAG,CAACd,mBAAmB,CAACC,QAArB,EAA+BD,mBAAmB,CAACG,WAAnD,EAAgEH,mBAAmB,CAACK,KAApF,EAA2FL,mBAAmB,CAACO,UAA/G,CAAtB;IAEAO,aAAa,CAACC,OAAd,CAAsB,UAACC,QAAD,EAAkBC,KAAlB,EAA+B;MAAK,YAAI,CAACC,iBAAL,CAAuBF,QAAvB,EAAiCH,MAAM,CAACI,KAAD,CAAvC;IAA+C,CAAzG;EACH,CAfO;;;;;;;;;EAuBA3B,kDAAR,UAA0B6B,MAA1B,EAA0CC,KAA1C,EAA4D;IACxD,IAAIA,KAAJ,EAAW;MACP,KAAKC,iBAAL,CAAuBF,MAAvB,EAA+BC,KAA/B,EAAsC,IAAtC;IACH;EACJ,CAJO;;;;;;;EAUA9B,qDAAR,UAA6BgC,SAA7B,EAA8C;IAC1C,IAAI;MACA,IAAMC,UAAU,GAAGC,IAAI,CAACC,KAAL,CAAWH,SAAX,CAAnB;;;;;;;;MAOA,OAAQC,UAAU,IAAI,OAAOA,UAAP,KAAsB,QAArC,GAAiDA,UAAjD,GAA8D,IAArE;IACH,CATD,CASE,OAAOG,KAAP,EAAc;MACZ,OAAO,IAAP;IACH;EACJ,CAbO;;;;;;;EAmBRpC,kDAAQqC,GAAR,EAAmB;IACf,OAAO,KAAK3C,cAAL,CAAoByB,OAApB,CAA4BkB,GAA5B,CAAP;EACH,CAFD;;;;;;;;EASArC,kDAAQqC,GAAR,EAAqBP,KAArB,EAAkC;IAC9B,KAAKpC,cAAL,CAAoB4C,OAApB,CAA4BD,GAA5B,EAAiCP,KAAjC;EACH,CAFD;;;;;;;EAQA9B,qDAAWuC,UAAX,EAA6B;IACzB,IAAMC,OAAO,GAAG,KAAKrB,OAAL,CAAaoB,UAAb,CAAhB;;IACA,IAAI,CAACC,OAAL,EAAc;MACV,OAAO,IAAP;IACH;;IAED,IAAMC,aAAa,GAAG,KAAKC,oBAAL,CAA0BF,OAA1B,CAAtB;;IACA,IAAI,CAACC,aAAD,IAAkB,CAACE,aAAa,CAACC,eAAd,CAA8BH,aAA9B,CAAvB,EAAqE;MACjE,OAAO,IAAP;IACH;;IAED,OAAOI,YAAY,CAACC,QAAb,CAAqC,IAAIH,aAAJ,EAArC,EAA0DF,aAA1D,CAAP;EACH,CAZD;;;;;;;;EAmBAzC,qDAAWwC,OAAX,EAAiC;IAC7B,KAAKnD,MAAL,CAAY0D,KAAZ,CAAkB,uCAAlB;IACA,IAAMV,GAAG,GAAGG,OAAO,CAACQ,kBAAR,EAAZ;IACA,KAAKV,OAAL,CAAaD,GAAb,EAAkBH,IAAI,CAACe,SAAL,CAAeT,OAAf,CAAlB;EACH,CAJD;;;;;;;EAUAxC,+DAAqBO,UAArB,EAAuC;IACnC,IAAMuB,KAAK,GAAG,KAAKX,OAAL,CAAaZ,UAAb,CAAd;;IACA,IAAI,CAACuB,KAAL,EAAY;MACR,KAAKzC,MAAL,CAAY0D,KAAZ,CAAkB,gEAAlB;MACA,OAAO,IAAP;IACH;;IAED,IAAMG,aAAa,GAAG,KAAKR,oBAAL,CAA0BZ,KAA1B,CAAtB;;IACA,IAAI,CAACoB,aAAD,IAAkB,CAACC,aAAa,CAACC,eAAd,CAA8BF,aAA9B,CAAvB,EAAqE;MACjE,KAAK7D,MAAL,CAAY0D,KAAZ,CAAkB,gEAAlB;MACA,OAAO,IAAP;IACH;;IAED,KAAK1D,MAAL,CAAY0D,KAAZ,CAAkB,qDAAlB;IACA,OAAOF,YAAY,CAACC,QAAb,CAAsB,IAAIK,aAAJ,EAAtB,EAA2CD,aAA3C,CAAP;EACH,CAfD;;;;;;;EAqBAlD,+DAAqBqD,OAArB,EAA2C;IACvC,KAAKhE,MAAL,CAAY0D,KAAZ,CAAkB,iDAAlB;IACA,IAAMxC,UAAU,GAAG8C,OAAO,CAACC,qBAAR,EAAnB;IACA,KAAKhB,OAAL,CAAa/B,UAAb,EAAyB2B,IAAI,CAACe,SAAL,CAAeI,OAAf,CAAzB;EACH,CAJD;;;;;;;EAUArD,mEAAyBuD,cAAzB,EAA+C;IAC3C,IAAMzB,KAAK,GAAG,KAAKX,OAAL,CAAaoC,cAAb,CAAd;;IACA,IAAI,CAACzB,KAAL,EAAY;MACR,KAAKzC,MAAL,CAAY0D,KAAZ,CAAkB,oEAAlB;MACA,OAAO,IAAP;IACH;;IACD,IAAMS,iBAAiB,GAAG,KAAKd,oBAAL,CAA0BZ,KAA1B,CAA1B;;IACA,IAAI,CAAC0B,iBAAD,IAAsB,CAACC,iBAAiB,CAACC,mBAAlB,CAAsCF,iBAAtC,CAA3B,EAAqF;MACjF,KAAKnE,MAAL,CAAY0D,KAAZ,CAAkB,oEAAlB;MACA,OAAO,IAAP;IACH;;IAED,KAAK1D,MAAL,CAAY0D,KAAZ,CAAkB,yDAAlB;IACA,OAAOF,YAAY,CAACC,QAAb,CAAsB,IAAIW,iBAAJ,EAAtB,EAA+CD,iBAA/C,CAAP;EACH,CAdD;;;;;;;EAoBAxD,mEAAyB2D,WAAzB,EAAuD;IACnD,KAAKtE,MAAL,CAAY0D,KAAZ,CAAkB,qDAAlB;IACA,IAAMQ,cAAc,GAAGI,WAAW,CAACL,qBAAZ,EAAvB;IACA,KAAKhB,OAAL,CAAaiB,cAAb,EAA6BrB,IAAI,CAACe,SAAL,CAAeU,WAAf,CAA7B;EACH,CAJD;;;;;;;EAUA3D,oEAA0B4D,eAA1B,EAAiD;IAC7C,IAAM9B,KAAK,GAAG,KAAKX,OAAL,CAAayC,eAAb,CAAd;;IACA,IAAI,CAAC9B,KAAL,EAAY;MACR,KAAKzC,MAAL,CAAY0D,KAAZ,CAAkB,qEAAlB;MACA,OAAO,IAAP;IACH;;IACD,IAAMc,kBAAkB,GAAG,KAAKnB,oBAAL,CAA0BZ,KAA1B,CAA3B;;IACA,IAAI,CAAC+B,kBAAD,IAAuB,CAACC,kBAAkB,CAACC,oBAAnB,CAAwCF,kBAAxC,CAA5B,EAAyF;MACrF,KAAKxE,MAAL,CAAY0D,KAAZ,CAAkB,qEAAlB;MACA,OAAO,IAAP;IACH;;IAED,KAAK1D,MAAL,CAAY0D,KAAZ,CAAkB,0DAAlB;IACA,OAAOF,YAAY,CAACC,QAAb,CAAsB,IAAIgB,kBAAJ,EAAtB,EAAgDD,kBAAhD,CAAP;EACH,CAdD;;;;;;;EAoBA7D,oEAA0BgE,YAA1B,EAA0D;IACtD,KAAK3E,MAAL,CAAY0D,KAAZ,CAAkB,sDAAlB;IACA,IAAMa,eAAe,GAAGI,YAAY,CAACV,qBAAb,EAAxB;IACA,KAAKhB,OAAL,CAAasB,eAAb,EAA8B1B,IAAI,CAACe,SAAL,CAAee,YAAf,CAA9B;EACH,CAJD;;;;;;;EAUAhE,yDAAeiE,cAAf,EAAqC;IACjC,IAAMnC,KAAK,GAAG,KAAKX,OAAL,CAAa8C,cAAb,CAAd;;IACA,IAAI,CAACnC,KAAL,EAAY;MACR,KAAKzC,MAAL,CAAY0D,KAAZ,CAAkB,0DAAlB;MACA,OAAO,IAAP;IACH;;IAED,IAAMmB,cAAc,GAAG,KAAKxB,oBAAL,CAA0BZ,KAA1B,CAAvB;;IACA,IAAI,CAACoC,cAAD,IAAmB,CAACC,iBAAiB,CAACC,mBAAlB,CAAsCH,cAAtC,EAAsDC,cAAtD,CAAxB,EAA+F;MAC3F,KAAK7E,MAAL,CAAY0D,KAAZ,CAAkB,0DAAlB;MACA,OAAO,IAAP;IACH;;IAED,KAAK1D,MAAL,CAAY0D,KAAZ,CAAkB,+CAAlB;IACA,OAAOF,YAAY,CAACC,QAAb,CAAsB,IAAIqB,iBAAJ,EAAtB,EAA+CD,cAA/C,CAAP;EACH,CAfD;;;;;;;EAqBAlE,yDAAeqE,WAAf,EAA6C;IACzC,KAAKhF,MAAL,CAAY0D,KAAZ,CAAkB,2CAAlB;IACA,IAAMkB,cAAc,GAAGI,WAAW,CAACC,sBAAZ,EAAvB;IACA,KAAKhC,OAAL,CAAa2B,cAAb,EAA6B/B,IAAI,CAACe,SAAL,CAAeoB,WAAf,CAA7B;EACH,CAJD;;;;;;;EAUArE,6DAAmBuE,kBAAnB,EAA6C;IACzC,IAAMzC,KAAK,GAAG,KAAKX,OAAL,CAAaoD,kBAAb,CAAd;;IACA,IAAI,CAACzC,KAAL,EAAY;MACR,KAAKzC,MAAL,CAAY0D,KAAZ,CAAkB,8DAAlB;MACA,OAAO,IAAP;IACH;;IACD,IAAMmB,cAAc,GAAG,KAAKxB,oBAAL,CAA0BZ,KAA1B,CAAvB;;IACA,IAAI,CAACoC,cAAD,IAAmB,CAACM,qBAAqB,CAACC,uBAAtB,CAA8CF,kBAA9C,EAAkEL,cAAlE,CAAxB,EAA2G;MACvG,KAAK7E,MAAL,CAAY0D,KAAZ,CAAkB,8DAAlB;MACA,OAAO,IAAP;IACH;;IAED,KAAK1D,MAAL,CAAY0D,KAAZ,CAAkB,mDAAlB;IACA,OAAOF,YAAY,CAACC,QAAb,CAAsB,IAAI0B,qBAAJ,EAAtB,EAAmDN,cAAnD,CAAP;EACH,CAdD;;;;;;;;EAqBAlE,6DAAmBuE,kBAAnB,EAA+CG,eAA/C,EAAqF;IACjF,KAAKrF,MAAL,CAAY0D,KAAZ,CAAkB,+CAAlB;IACA,KAAKT,OAAL,CAAaiC,kBAAb,EAAiCrC,IAAI,CAACe,SAAL,CAAeyB,eAAf,CAAjC;EACH,CAHD;;;;;;EAQA1E,+DAAqBqC,GAArB,EAAgC;IAC5B,IAAMP,KAAK,GAAG,KAAKtC,eAAL,CAAqB2B,OAArB,CAA6BkB,GAA7B,CAAd;;IACA,IAAI,CAACP,KAAL,EAAY;MACR,KAAKzC,MAAL,CAAY0D,KAAZ,CAAkB,gEAAlB;MACA,OAAO,IAAP;IACH;;IACD,IAAMmB,cAAc,GAAG,KAAKxB,oBAAL,CAA0BZ,KAA1B,CAAvB;;IACA,IAAIoC,cAAc,IAAIS,uBAAuB,CAACC,yBAAxB,CAAkDvC,GAAlD,EAAuD6B,cAAvD,CAAtB,EAA8F;MAC1F,KAAK7E,MAAL,CAAY0D,KAAZ,CAAkB,qDAAlB;MACA,OAAOF,YAAY,CAACC,QAAb,CAAsB,IAAI6B,uBAAJ,EAAtB,EAAqDT,cAArD,CAAP;IACH;;IACD,OAAO,IAAP;EACH,CAZD;;;;;;EAiBAlE;IAAA;;IACI,IAAM6E,OAAO,GAAG,KAAKrF,eAAL,CAAqBsF,OAArB,EAAhB;IACA,OAAOD,OAAO,CAACE,MAAR,CAAe,UAAC1C,GAAD,EAAI;MACtB,OAAO9C,KAAI,CAACyF,mBAAL,CAAyB3C,GAAzB,CAAP;IACH,CAFM,CAAP;EAGH,CALD;;;;;;;EAWArC,+DAAqBqC,GAArB,EAAkC4C,MAAlC,EAAiE;IAC7D,KAAK5F,MAAL,CAAY0D,KAAZ,CAAkB,iDAAlB;IACA,KAAKvD,eAAL,CAAqB8C,OAArB,CAA6BD,GAA7B,EAAkCH,IAAI,CAACe,SAAL,CAAegC,MAAf,CAAlC;EACH,CAHD;;;;;;EAQAjF;IACI,IAAMkF,kBAAkB,GAAG,KAAKC,gBAAL,CAAsBzE,mBAAmB,CAAC0E,cAA1C,CAA3B;IACA,IAAMC,eAAe,GAAG,KAAK3F,cAAL,CAAoByB,OAApB,CAA4B+D,kBAA5B,CAAxB;;IACA,IAAI,CAACG,eAAL,EAAsB;MAClB,OAAO,IAAP;IACH;;IACD,OAAO,KAAKC,sBAAL,CAA4B;MAACC,cAAc,EAAEF;IAAjB,CAA5B,EAA+D,CAA/D,KAAqE,IAA5E;EACH,CAPD;;;;;;;EAaArF,2DAAiBwC,OAAjB,EAA4C;IACxC,IAAM0C,kBAAkB,GAAG,KAAKC,gBAAL,CAAsBzE,mBAAmB,CAAC0E,cAA1C,CAA3B;;IACA,IAAI5C,OAAJ,EAAa;MACT,KAAKnD,MAAL,CAAYiB,OAAZ,CAAoB,sCAApB;MACA,KAAKZ,cAAL,CAAoB4C,OAApB,CAA4B4C,kBAA5B,EAAgD1C,OAAO,CAAC+C,cAAxD;IACH,CAHD,MAGO;MACH,KAAKlG,MAAL,CAAYiB,OAAZ,CAAoB,6DAApB;MACA,KAAKZ,cAAL,CAAoB8F,UAApB,CAA+BN,kBAA/B;IACH;EACJ,CATD;;;;;;;EAeAlF,iEAAuByF,aAAvB,EAAwF;IACpF,IAAMC,WAAW,GAAG,KAAKC,cAAL,EAApB;IACA,OAAOD,WAAW,CAACX,MAAZ,CAAmB,UAACa,UAAD,EAAW;MACjC,IAAIH,aAAa,CAACI,QAAd,IAA0BJ,aAAa,CAACI,QAAd,CAAuBC,WAAvB,OAAyCF,UAAU,CAACC,QAAX,CAAoBC,WAApB,EAAvE,EAA0G;QACtG,OAAO,KAAP;MACH;;MAED,IAAIL,aAAa,CAACM,aAAd,IAA+BN,aAAa,CAACM,aAAd,KAAgCH,UAAU,CAACG,aAA9E,EAA6F;QACzF,OAAO,KAAP;MACH;;MAED,IAAIN,aAAa,CAACF,cAAd,IAAgCE,aAAa,CAACF,cAAd,KAAiCK,UAAU,CAACL,cAAhF,EAAgG;QAC5F,OAAO,KAAP;MACH;;MAED,IAAIE,aAAa,CAACO,QAAd,IAA0BP,aAAa,CAACO,QAAd,KAA2BJ,UAAU,CAACI,QAApE,EAA8E;QAC1E,OAAO,KAAP;MACH;;MAED,IAAIP,aAAa,CAACQ,WAAd,IAA6BR,aAAa,CAACQ,WAAd,KAA8BL,UAAU,CAACK,WAA1E,EAAuF;QACnF,OAAO,KAAP;MACH;;MAED,OAAO,IAAP;IACH,CAtBM,CAAP;EAuBH,CAzBD;;;;;;;EA+BAjG,6DAAmBkG,kBAAnB,EAA6C;IACzC,IAAMpE,KAAK,GAAG,KAAKX,OAAL,CAAa+E,kBAAb,CAAd;;IACA,IAAI,CAACpE,KAAL,EAAY;MACR,KAAKzC,MAAL,CAAY0D,KAAZ,CAAkB,8DAAlB;MACA,OAAO,IAAP;IACH;;IAED,IAAMoD,qBAAqB,GAAG,KAAKzD,oBAAL,CAA0BZ,KAA1B,CAA9B;;IACA,IAAI,CAACqE,qBAAD,IAA0B,CAACC,gBAAgB,CAACC,kBAAjB,CAAoCH,kBAApC,EAAwDC,qBAAxD,CAA/B,EAA+G;MAC3G,KAAK9G,MAAL,CAAY0D,KAAZ,CAAkB,8DAAlB;MACA,OAAO,IAAP;IACH;;IAED,KAAK1D,MAAL,CAAY0D,KAAZ,CAAkB,mDAAlB;IACA,OAAOF,YAAY,CAACC,QAAb,CAAsB,IAAIsD,gBAAJ,EAAtB,EAA8CD,qBAA9C,CAAP;EACH,CAfD;;;;;;;;EAsBAnG,6DAAmBkG,kBAAnB,EAA+CI,eAA/C,EAAgF;IAC5E,KAAKjH,MAAL,CAAY0D,KAAZ,CAAkB,+CAAlB;IACA,KAAKT,OAAL,CAAa4D,kBAAb,EAAiChE,IAAI,CAACe,SAAL,CAAeqD,eAAf,CAAjC;EACH,CAHD;;;;;;;;EAUAtG,4DAAkB0B,QAAlB,EAAoC6E,WAApC,EAAyD;IACrD,IAAMlE,GAAG,GAAGkE,WAAW,GAAG,KAAKpB,gBAAL,CAAsBzD,QAAtB,CAAH,GAAqCA,QAA5D;;IACA,IAAI,KAAKvC,WAAL,CAAiBqH,sBAArB,EAA6C;MACzC,IAAMC,UAAU,GAAG,KAAKC,aAAL,CAAmBrE,GAAnB,CAAnB;;MACA,IAAIoE,UAAJ,EAAgB;QACZ,KAAKpH,MAAL,CAAY0D,KAAZ,CAAkB,qGAAlB;QACA,OAAO0D,UAAP;MACH;IACJ;;IAED,IAAM3E,KAAK,GAAG,KAAKjC,qBAAL,CAA2BsB,OAA3B,CAAmCkB,GAAnC,CAAd;;IACA,IAAI,CAACP,KAAL,EAAY;;MAER,IAAI,KAAK3C,WAAL,CAAiBS,aAAjB,KAAmCK,oBAAoB,CAACC,YAA5D,EAA0E;QACtE,IAAMyG,IAAI,GAAG,KAAKjH,cAAL,CAAoByB,OAApB,CAA4BkB,GAA5B,CAAb;;QACA,IAAIsE,IAAJ,EAAU;UACN,KAAKtH,MAAL,CAAY0D,KAAZ,CAAkB,oFAAlB;UACA,OAAO4D,IAAP;QACH;MACJ;;MACD,KAAKtH,MAAL,CAAY0D,KAAZ,CAAkB,6EAAlB;MACA,OAAO,IAAP;IACH;;IACD,KAAK1D,MAAL,CAAY0D,KAAZ,CAAkB,sEAAlB;IACA,OAAOjB,KAAP;EACH,CAzBD;;;;;;;;;;EAkCA9B,4DAAkB0B,QAAlB,EAAoCI,KAApC,EAAmDyE,WAAnD,EAAwE;IACpE,IAAMlE,GAAG,GAAGkE,WAAW,GAAG,KAAKpB,gBAAL,CAAsBzD,QAAtB,CAAH,GAAqCA,QAA5D;IAEA,KAAK7B,qBAAL,CAA2ByC,OAA3B,CAAmCD,GAAnC,EAAwCP,KAAxC;;IACA,IAAI,KAAK3C,WAAL,CAAiBqH,sBAArB,EAA6C;MACzC,KAAKnH,MAAL,CAAY0D,KAAZ,CAAkB,gGAAlB;MACA,KAAK6D,aAAL,CAAmBvE,GAAnB,EAAwBP,KAAxB;IACH;EACJ,CARD;;;;;;;;EAeA9B,qDAAWqC,GAAX,EAAsB;IAClB,KAAK3C,cAAL,CAAoB8F,UAApB,CAA+BnD,GAA/B;IACA,KAAKxC,qBAAL,CAA2B2F,UAA3B,CAAsCnD,GAAtC;;IACA,IAAI,KAAKlD,WAAL,CAAiBqH,sBAArB,EAA6C;MACzC,KAAKnH,MAAL,CAAY0D,KAAZ,CAAkB,sFAAlB;MACA,KAAK8D,eAAL,CAAqBxE,GAArB;IACH;;IACD,OAAO,IAAP;EACH,CARD;;;;;;;EAcArC,sDAAYqC,GAAZ,EAAuB;IACnB,OAAO,KAAK3C,cAAL,CAAoBoH,WAApB,CAAgCzE,GAAhC,KAAwC,KAAKxC,qBAAL,CAA2BiH,WAA3B,CAAuCzE,GAAvC,CAA/C;EACH,CAFD;;;;;;EAOArC;IACI,gBACO,KAAKN,cAAL,CAAoBoF,OAApB,EADP,EAEO,KAAKjF,qBAAL,CAA2BiF,OAA3B,EAFP;EAIH,CALD;;;;;;EAUA9E;IAAA;;IACI,KAAK+G,iBAAL;IACA,KAAKC,iBAAL;IACA,KAAKlC,OAAL,GAAerD,OAAf,CAAuB,UAACC,QAAD,EAAiB;;MAEpC,IAAI,CAACnC,KAAI,CAACG,cAAL,CAAoBoH,WAApB,CAAgCpF,QAAhC,KAA6CnC,KAAI,CAACM,qBAAL,CAA2BiH,WAA3B,CAAuCpF,QAAvC,CAA9C,MAAqGA,QAAQ,CAACuF,OAAT,CAAiBzG,SAAS,CAACC,YAA3B,MAA6C,CAAC,CAA/C,IAAsDiB,QAAQ,CAACuF,OAAT,CAAiB1H,KAAI,CAACL,QAAtB,MAAoC,CAAC,CAA/L,CAAJ,EAAwM;QACpMK,KAAI,CAACiG,UAAL,CAAgB9D,QAAhB;MACH;IACJ,CALD;IAOA,KAAKlC,eAAL,CAAqB0H,KAArB;EACH,CAXD;;;;;;;;;EAmBAlH,wDAAcmH,UAAd,EAAkCC,WAAlC,EAAuDC,OAAvD,EAAuE;IACnE,IAAIC,SAAS,GAAMC,kBAAkB,CAACJ,UAAD,CAAlB,GAA8B,GAA9B,GAAkCI,kBAAkB,CAACH,WAAD,CAApD,GAAiE,UAApF;;IACA,IAAIC,OAAJ,EAAa;MACT,IAAMG,UAAU,GAAG,KAAKC,uBAAL,CAA6BJ,OAA7B,CAAnB;MACAC,SAAS,IAAI,aAAWE,UAAX,GAAqB,GAAlC;IACH;;IAED,IAAI,KAAKrI,WAAL,CAAiBuI,aAArB,EAAoC;MAChCJ,SAAS,IAAI,SAAb;IACH;;IAEDK,QAAQ,CAACC,MAAT,GAAkBN,SAAlB;EACH,CAZD;;;;;;;EAkBAtH,wDAAcmH,UAAd,EAAgC;IAC5B,IAAMU,IAAI,GAAMN,kBAAkB,CAACJ,UAAD,CAAlB,GAA8B,GAA9C;IACA,IAAMW,UAAU,GAAGH,QAAQ,CAACC,MAAT,CAAgBG,KAAhB,CAAsB,GAAtB,CAAnB;;IACA,KAAK,IAAIC,CAAC,GAAW,CAArB,EAAwBA,CAAC,GAAGF,UAAU,CAACG,MAAvC,EAA+CD,CAAC,EAAhD,EAAoD;MAChD,IAAIJ,MAAM,GAAGE,UAAU,CAACE,CAAD,CAAvB;;MACA,OAAOJ,MAAM,CAACM,MAAP,CAAc,CAAd,MAAqB,GAA5B,EAAiC;QAC7BN,MAAM,GAAGA,MAAM,CAACO,SAAP,CAAiB,CAAjB,CAAT;MACH;;MACD,IAAIP,MAAM,CAACX,OAAP,CAAeY,IAAf,MAAyB,CAA7B,EAAgC;QAC5B,OAAOO,kBAAkB,CAACR,MAAM,CAACO,SAAP,CAAiBN,IAAI,CAACI,MAAtB,EAA8BL,MAAM,CAACK,MAArC,CAAD,CAAzB;MACH;IACJ;;IACD,OAAO,EAAP;EACH,CAbD;;;;;;EAkBAjI;IAAA;;IACI,IAAMqI,YAAY,GAAM7H,SAAS,CAACC,YAAV,GAAsB,GAAtB,GAA0B,KAAKvB,QAAvD;IACA,IAAM4I,UAAU,GAAGH,QAAQ,CAACC,MAAT,CAAgBG,KAAhB,CAAsB,GAAtB,CAAnB;IACAD,UAAU,CAACrG,OAAX,CAAmB,UAACmG,MAAD,EAAe;MAC9B,OAAOA,MAAM,CAACM,MAAP,CAAc,CAAd,MAAqB,GAA5B,EAAiC;;QAE7BN,MAAM,GAAGA,MAAM,CAACO,SAAP,CAAiB,CAAjB,CAAT;MACH;;MACD,IAAIP,MAAM,CAACX,OAAP,CAAeoB,YAAf,MAAiC,CAArC,EAAwC;QACpC,IAAMC,SAAS,GAAGV,MAAM,CAACG,KAAP,CAAa,GAAb,EAAkB,CAAlB,CAAlB;;QACAxI,KAAI,CAACsH,eAAL,CAAqByB,SAArB;MACH;IACJ,CATD;EAUH,CAbD;;;;;;;EAmBAtI,0DAAgBmH,UAAhB,EAAkC;IAC9B,KAAKP,aAAL,CAAmBO,UAAnB,EAA+B,EAA/B,EAAmC,CAAC,CAApC;EACH,CAFD;;;;;;;EAQAnH,kEAAwBuI,cAAxB,EAA8C;IAC1C,IAAMC,KAAK,GAAG,IAAIC,IAAJ,EAAd;IACA,IAAMC,IAAI,GAAG,IAAID,IAAJ,CAASD,KAAK,CAACG,OAAN,KAAkBJ,cAAc,GAAG,KAAKK,sBAAjD,CAAb;IACA,OAAOF,IAAI,CAACG,WAAL,EAAP;EACH,CAJD;;;;;;EASA7I;IACI,OAAO,KAAKN,cAAZ;EACH,CAFD;;;;;;EAOAM;EAEC,CAFD;;;;;;;;EASAA,2DAAiBqC,GAAjB,EAA4B;IACxB,IAAMyG,YAAY,GAAG,KAAKpG,oBAAL,CAA0BL,GAA1B,CAArB;;IACA,IAAI,CAACyG,YAAL,EAAmB;MACf,IAAIC,WAAW,CAACC,UAAZ,CAAuB3G,GAAvB,EAA4B7B,SAAS,CAACC,YAAtC,KAAuDsI,WAAW,CAACC,UAAZ,CAAuB3G,GAAvB,EAA4B3B,mBAAmB,CAACuI,aAAhD,CAA3D,EAA2H;QACvH,OAAO5G,GAAP;MACH;;MACD,OAAU7B,SAAS,CAACC,YAAV,GAAsB,GAAtB,GAA0B,KAAKvB,QAA/B,GAAuC,GAAvC,GAA2CmD,GAArD;IACH;;IAED,OAAOH,IAAI,CAACe,SAAL,CAAeZ,GAAf,CAAP;EACH,CAVD;;;;;;;EAgBArC,+DAAqBkJ,WAArB,EAAwC;IAG5B;IAIR,OAAO,KAAK/D,gBAAL,CAAyBgE,kBAAkB,CAACC,SAAnB,GAA4B,GAA5B,GAAgCC,OAAzD,CAAP;EACH,CARD;;;;;;;EAcArJ,2DAAiBkJ,WAAjB,EAAoC;IAGxB;IAIR,OAAO,KAAK/D,gBAAL,CAAyBgE,kBAAkB,CAACG,aAAnB,GAAgC,GAAhC,GAAoCD,OAA7D,CAAP;EACH,CARD;;;;;;;EAcArJ,2DAAiBkJ,WAAjB,EAAoC;;IAIxB;IAGR,OAAO,KAAK/D,gBAAL,CAAyBgE,kBAAkB,CAACI,aAAnB,GAAgC,GAAhC,GAAoCF,OAA7D,CAAP;EACH,CARD;;;;;;EAaArJ,6DAAmBwJ,WAAnB,EAAsC;IAClC,IAAMC,aAAa,GAAG,KAAKC,gBAAL,CAAsBF,WAAtB,CAAtB;IACA,IAAMG,KAAK,GAAG,KAAKC,iBAAL,CAAuBH,aAAvB,CAAd;;IACA,IAAI,CAACE,KAAL,EAAY;MACR,OAAO,IAAP;IACH;;IAED,IAAME,iBAAiB,GAAG,KAAKC,oBAAL,CAA0BH,KAA1B,CAA1B;IACA,OAAO,KAAKC,iBAAL,CAAuBC,iBAAvB,CAAP;EACH,CATD;;;;;;;;EAgBA7J,6DAAmB2J,KAAnB,EAAkCI,KAAlC,EAAiDC,iBAAjD,EAA4EC,SAA5E,EAA+FzH,OAA/F,EAAwH;IACpH,KAAKnD,MAAL,CAAY0D,KAAZ,CAAkB,+CAAlB,EADoH;;IAGpH,IAAM0G,aAAa,GAAG,KAAKC,gBAAL,CAAsBC,KAAtB,CAAtB;IACA,KAAK5H,iBAAL,CAAuB0H,aAAvB,EAAsCE,KAAtC,EAA6C,KAA7C,EAJoH;;IAOpH,IAAMO,aAAa,GAAG,KAAKC,gBAAL,CAAsBR,KAAtB,CAAtB;IACA,KAAK5H,iBAAL,CAAuBmI,aAAvB,EAAsCH,KAAtC,EAA6C,KAA7C,EARoH;;IAWpH,IAAMF,iBAAiB,GAAG,KAAKC,oBAAL,CAA0BH,KAA1B,CAA1B;IACA,KAAK5H,iBAAL,CAAuB8H,iBAAvB,EAA0CG,iBAA1C,EAA6D,KAA7D;;IAEA,IAAIxH,OAAJ,EAAa;MACT,IAAM4H,aAAa,GAAkB;QACjCC,UAAU,EAAE7H,OAAO,CAACuD,aADa;QAEjCuE,IAAI,EAAEC,iBAAiB,CAACC;MAFS,CAArC;MAIA,KAAKzI,iBAAL,CAAuBoH,kBAAkB,CAACsB,cAA1C,EAA0DvI,IAAI,CAACe,SAAL,CAAemH,aAAf,CAA1D,EAAyF,IAAzF;IACH,CAND,MAMO,IAAI,CAACrB,WAAW,CAAC2B,OAAZ,CAAoBT,SAApB,CAAL,EAAqC;MACxC,IAAMG,aAAa,GAAkB;QACjCC,UAAU,EAAEJ,SADqB;QAEjCK,IAAI,EAAEC,iBAAiB,CAACI;MAFS,CAArC;MAIA,KAAK5I,iBAAL,CAAuBoH,kBAAkB,CAACsB,cAA1C,EAA0DvI,IAAI,CAACe,SAAL,CAAemH,aAAf,CAA1D,EAAyF,IAAzF;IACH;EACJ,CA3BD;;;;;;;EAiCApK,4DAAkB2J,KAAlB,EAA+B;IAA/B;;IACI,KAAKtK,MAAL,CAAY0D,KAAZ,CAAkB,8CAAlB,EAD2B;;IAG3B,IAAI,CAACgG,WAAW,CAAC2B,OAAZ,CAAoBf,KAApB,CAAL,EAAiC;MAC7B,KAAK7E,OAAL,GAAerD,OAAf,CAAuB,eAAG;QACtB,IAAIY,GAAG,CAAC4E,OAAJ,CAAY0C,KAAZ,MAAuB,CAAC,CAA5B,EAA+B;UAC3BpK,KAAI,CAACiG,UAAL,CAAgBnD,GAAhB;QACH;MACJ,CAJD;IAKH,CAT0B;;;IAY3B,IAAIsH,KAAJ,EAAW;MACP,KAAKnE,UAAL,CAAgB,KAAKkE,gBAAL,CAAsBC,KAAtB,CAAhB;MACA,KAAKnE,UAAL,CAAgB,KAAK2E,gBAAL,CAAsBR,KAAtB,CAAhB;MACA,KAAKnE,UAAL,CAAgB,KAAKsE,oBAAL,CAA0BH,KAA1B,CAAhB;IACH;;IACD,KAAKnE,UAAL,CAAgB,KAAKL,gBAAL,CAAsBgE,kBAAkB,CAACyB,cAAzC,CAAhB;IACA,KAAKpF,UAAL,CAAgB,KAAKL,gBAAL,CAAsBgE,kBAAkB,CAAC0B,UAAzC,CAAhB;IACA,KAAKrF,UAAL,CAAgB,KAAKL,gBAAL,CAAsBgE,kBAAkB,CAAC2B,QAAzC,CAAhB;IACA,KAAKtF,UAAL,CAAgB,KAAKL,gBAAL,CAAsBgE,kBAAkB,CAAC4B,sBAAzC,CAAhB;IACA,KAAKvF,UAAL,CAAgB,KAAKL,gBAAL,CAAsBgE,kBAAkB,CAACsB,cAAzC,CAAhB;EACH,CAtBD;;;;;;;EA4BAzK,8DAAoBkJ,WAApB,EAAuC;IACnC,KAAK7J,MAAL,CAAY0D,KAAZ,CAAkB,gDAAlB,EADmC;;IAGnC,IAAImG,WAAJ,EAAiB;MACb,IAAM8B,QAAQ,GAAG,KAAKtB,gBAAL,CAAsBR,WAAtB,CAAjB;MACA,IAAMM,WAAW,GAAG,KAAK3J,qBAAL,CAA2BsB,OAA3B,CAAmC6J,QAAnC,CAApB;MACA,KAAK3L,MAAL,CAAY4L,OAAZ,CAAoB,wFAAsFzB,WAA1G;MACA,KAAK0B,iBAAL,CAAuB1B,WAAW,IAAI,EAAtC;IACH;;IACD,KAAK2B,gBAAL;EACH,CAVD;;;;;;;;EAiBAnL,wEAA8BoL,eAA9B,EAA8D;IAA9D;;IACI,KAAK/L,MAAL,CAAY0D,KAAZ,CAAkB,0DAAlB,EAD0D;;IAG1D,KAAK+B,OAAL,GAAerD,OAAf,CAAuB,UAACY,GAAD,EAAI;;MAEvB,IAAIA,GAAG,CAAC4E,OAAJ,CAAYkC,kBAAkB,CAACI,aAA/B,MAAkD,CAAC,CAAvD,EAA0D;QACtD;MACH,CAJsB;;;MAOvB,IAAM8B,UAAU,GAAG9L,KAAI,CAACM,qBAAL,CAA2BsB,OAA3B,CAAmCkB,GAAnC,CAAnB;;MACA,IAAI,CAACgJ,UAAL,EAAiB;QACb;MACH,CAVsB;;;MAYvB,IAAMC,WAAW,GAAGC,oBAAoB,CAACC,0BAArB,CAAgDjM,KAAI,CAACH,UAArD,EAAiEiM,UAAjE,CAApB;;MACA,IAAIC,WAAW,IAAIA,WAAW,CAACF,eAAZ,KAAgCA,eAAnD,EAAoE;QAChE7L,KAAI,CAACF,MAAL,CAAY4L,OAAZ,CAAoB,kGAAgGI,UAApH;;QACA9L,KAAI,CAAC2L,iBAAL,CAAuBG,UAAvB;MACH;IACJ,CAjBD;IAkBA,KAAKF,gBAAL;EACH,CAtBD;;EAwBAnL,2DAAiByL,eAAjB,EAAkEC,aAAlE,EAAwF;IACpF,KAAKrM,MAAL,CAAY0D,KAAZ,CAAkB,6CAAlB;IAEA,IAAM4I,YAAY,GAAGD,aAAa,CAACE,YAAd,CAA2B1J,IAAI,CAACe,SAAL,CAAewI,eAAf,CAA3B,CAArB;IACA,KAAK1J,iBAAL,CAAuBoH,kBAAkB,CAACyB,cAA1C,EAA0De,YAA1D,EAAwE,IAAxE;EACH,CALD;;;;;;EAUA3L,2DAAiB2J,KAAjB,EAAgC+B,aAAhC,EAAsD;IAClD,KAAKrM,MAAL,CAAY0D,KAAZ,CAAkB,6CAAlB,EADkD;;IAGlD,IAAM8I,mBAAmB,GAAG,KAAKjC,iBAAL,CAAuBT,kBAAkB,CAACyB,cAA1C,EAA0D,IAA1D,CAA5B;;IACA,IAAI,CAACiB,mBAAL,EAA0B;MACtB,MAAMC,gBAAgB,CAACC,8BAAjB,EAAN;IACH;;IAED,IAAMC,aAAa,GAAG,KAAKtJ,oBAAL,CAA0BgJ,aAAa,CAACO,YAAd,CAA2BJ,mBAA3B,CAA1B,CAAtB;;IACA,IAAI,CAACG,aAAL,EAAoB;MAChB,MAAMF,gBAAgB,CAACI,yCAAjB,EAAN;IACH;;IACD,KAAK1G,UAAL,CAAgB,KAAKL,gBAAL,CAAsBgE,kBAAkB,CAACyB,cAAzC,CAAhB,EAZkD;;IAelD,IAAI7B,WAAW,CAAC2B,OAAZ,CAAoBsB,aAAa,CAACG,SAAlC,CAAJ,EAAkD;MAC9C,IAAMtC,iBAAiB,GAAW,KAAKC,oBAAL,CAA0BH,KAA1B,CAAlC;MACA,IAAMyC,eAAe,GAAG,KAAKxC,iBAAL,CAAuBC,iBAAvB,CAAxB;;MACA,IAAI,CAACuC,eAAL,EAAsB;QAClB,MAAMN,gBAAgB,CAACO,4BAAjB,EAAN;MACH;;MACDL,aAAa,CAACG,SAAd,GAA0BC,eAA1B;IACH;;IAED,OAAOJ,aAAP;EACH,CAzBD;;EA0BJ;AAp1BA,EAAyCnJ;;IAs1B5ByJ,6BAA6B,GAAG,UAACpN,QAAD,EAAmBG,MAAnB,EAAiC;EAC1E,IAAMkN,YAAY,GAAG;IACjB3M,aAAa,EAAEK,oBAAoB,CAACR,aADnB;IAEjB+G,sBAAsB,EAAE,KAFP;IAGjBkB,aAAa,EAAE;EAHE,CAArB;EAKA,OAAO,IAAI1H,mBAAJ,CAAwBd,QAAxB,EAAkCqN,YAAlC,EAAgDC,6BAAhD,EAA+EnN,MAA/E,CAAP;AACJ","names":["__extends","clientId","cacheConfig","cryptoImpl","logger","_super","_this","internalStorage","MemoryStorage","browserStorage","setupBrowserStorage","cacheLocation","temporaryCacheStorage","setupTemporaryCacheStorage","migrateCacheEntries","BrowserCacheManager","BrowserCacheLocation","LocalStorage","SessionStorage","BrowserStorage","e","verbose","idTokenKey","Constants","CACHE_PREFIX","PersistentCacheKeys","ID_TOKEN","clientInfoKey","CLIENT_INFO","errorKey","ERROR","errorDescKey","ERROR_DESC","idTokenValue","getItem","clientInfoValue","errorValue","errorDescValue","values","keysToMigrate","forEach","cacheKey","index","migrateCacheEntry","newKey","value","setTemporaryCache","jsonValue","parsedJson","JSON","parse","error","key","setItem","accountKey","account","parsedAccount","validateAndParseJson","AccountEntity","isAccountEntity","CacheManager","toObject","trace","generateAccountKey","stringify","parsedIdToken","IdTokenEntity","isIdTokenEntity","idToken","generateCredentialKey","accessTokenKey","parsedAccessToken","AccessTokenEntity","isAccessTokenEntity","accessToken","refreshTokenKey","parsedRefreshToken","RefreshTokenEntity","isRefreshTokenEntity","refreshToken","appMetadataKey","parsedMetadata","AppMetadataEntity","isAppMetadataEntity","appMetadata","generateAppMetadataKey","serverTelemetryKey","ServerTelemetryEntity","isServerTelemetryEntity","serverTelemetry","AuthorityMetadataEntity","isAuthorityMetadataEntity","allKeys","getKeys","filter","isAuthorityMetadata","entity","activeAccountIdKey","generateCacheKey","ACTIVE_ACCOUNT","activeAccountId","getAccountInfoByFilter","localAccountId","removeItem","accountFilter","allAccounts","getAllAccounts","accountObj","username","toLowerCase","homeAccountId","tenantId","environment","throttlingCacheKey","parsedThrottlingCache","ThrottlingEntity","isThrottlingEntity","throttlingCache","generateKey","storeAuthStateInCookie","itemCookie","getItemCookie","item","setItemCookie","clearItemCookie","containsKey","removeAllAccounts","removeAppMetadata","indexOf","clear","cookieName","cookieValue","expires","cookieStr","encodeURIComponent","expireTime","getCookieExpirationTime","secureCookies","document","cookie","name","cookieList","split","i","length","charAt","substring","decodeURIComponent","cookiePrefix","cookieKey","cookieLifeDays","today","Date","expr","getTime","COOKIE_LIFE_MULTIPLIER","toUTCString","generatedKey","StringUtils","startsWith","ADAL_ID_TOKEN","stateString","TemporaryCacheKeys","AUTHORITY","stateId","NONCE_IDTOKEN","REQUEST_STATE","cachedState","stateCacheKey","generateStateKey","state","getTemporaryCache","authorityCacheKey","generateAuthorityKey","nonce","authorityInstance","loginHint","nonceCacheKey","generateNonceKey","ccsCredential","credential","type","CcsCredentialType","HOME_ACCOUNT_ID","CCS_CREDENTIAL","isEmpty","UPN","REQUEST_PARAMS","ORIGIN_URI","URL_HASH","INTERACTION_STATUS_KEY","stateKey","infoPii","resetRequestCache","clearMsalCookies","interactionType","stateValue","parsedState","BrowserProtocolUtils","extractBrowserRequestState","authCodeRequest","browserCrypto","encodedValue","base64Encode","encodedTokenRequest","BrowserAuthError","createNoTokenRequestCacheError","parsedRequest","base64Decode","createUnableToParseTokenRequestCacheError","authority","cachedAuthority","createNoCachedAuthorityError","DEFAULT_BROWSER_CACHE_MANAGER","cacheOptions","DEFAULT_CRYPTO_IMPLEMENTATION"],"sources":["../../src/cache/BrowserCacheManager.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { Constants, PersistentCacheKeys, StringUtils, CommonAuthorizationCodeRequest, ICrypto, AccountEntity, IdTokenEntity, AccessTokenEntity, RefreshTokenEntity, AppMetadataEntity, CacheManager, ServerTelemetryEntity, ThrottlingEntity, ProtocolUtils, Logger, AuthorityMetadataEntity, DEFAULT_CRYPTO_IMPLEMENTATION, AccountInfo, CcsCredential, CcsCredentialType } from \"@azure/msal-common\";\r\nimport { CacheOptions } from \"../config/Configuration\";\r\nimport { BrowserAuthError } from \"../error/BrowserAuthError\";\r\nimport { BrowserCacheLocation, InteractionType, TemporaryCacheKeys } from \"../utils/BrowserConstants\";\r\nimport { BrowserStorage } from \"./BrowserStorage\";\r\nimport { MemoryStorage } from \"./MemoryStorage\";\r\nimport { IWindowStorage } from \"./IWindowStorage\";\r\nimport { BrowserProtocolUtils } from \"../utils/BrowserProtocolUtils\";\r\n\r\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\r\nexport class BrowserCacheManager extends CacheManager {\r\n\r\n    // Cache configuration, either set by user or default values.\r\n    private cacheConfig: Required<CacheOptions>;\r\n    // Window storage object (either local or sessionStorage)\r\n    private browserStorage: IWindowStorage;\r\n    // Internal in-memory storage object used for data used by msal that does not need to persist across page loads\r\n    private internalStorage: MemoryStorage;\r\n    // Temporary cache\r\n    private temporaryCacheStorage: IWindowStorage;\r\n    // Client id of application. Used in cache keys to partition cache correctly in the case of multiple instances of MSAL.\r\n    private logger: Logger;\r\n\r\n    // Cookie life calculation (hours * minutes * seconds * ms)\r\n    private readonly COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\r\n\r\n    constructor(clientId: string, cacheConfig: Required<CacheOptions>, cryptoImpl: ICrypto, logger: Logger) {\r\n        super(clientId, cryptoImpl);\r\n\r\n        this.cacheConfig = cacheConfig;\r\n        this.logger = logger;\r\n\r\n        this.internalStorage = new MemoryStorage();\r\n        this.browserStorage = this.setupBrowserStorage(this.cacheConfig.cacheLocation);\r\n        this.temporaryCacheStorage = this.setupTemporaryCacheStorage(this.cacheConfig.cacheLocation);\r\n\r\n        // Migrate any cache entries from older versions of MSAL.\r\n        this.migrateCacheEntries();\r\n    }\r\n\r\n    /**\r\n     * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n     * @param cacheLocation\r\n     */\r\n    private setupBrowserStorage(cacheLocation: BrowserCacheLocation | string): IWindowStorage {\r\n        switch (cacheLocation) {\r\n            case BrowserCacheLocation.LocalStorage:\r\n            case BrowserCacheLocation.SessionStorage:\r\n                try {\r\n                    // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\r\n                    return new BrowserStorage(cacheLocation);\r\n                } catch (e) {\r\n                    this.logger.verbose(e);\r\n                    break;\r\n                }\r\n            case BrowserCacheLocation.MemoryStorage:\r\n            default:\r\n                break;\r\n        }\r\n        this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\r\n        return new MemoryStorage();\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param cacheLocation\r\n     */\r\n    private setupTemporaryCacheStorage(cacheLocation: BrowserCacheLocation | string): IWindowStorage {\r\n        switch (cacheLocation) {\r\n            case BrowserCacheLocation.LocalStorage:\r\n            case BrowserCacheLocation.SessionStorage:\r\n                try {\r\n                    // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\r\n                    return new BrowserStorage(BrowserCacheLocation.SessionStorage);\r\n                } catch (e) {\r\n                    this.logger.verbose(e);\r\n                    return this.internalStorage;\r\n                }\r\n            case BrowserCacheLocation.MemoryStorage:\r\n            default:\r\n                return this.internalStorage;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Migrate all old cache entries to new schema. No rollback supported.\r\n     * @param storeAuthStateInCookie\r\n     */\r\n    private migrateCacheEntries(): void {\r\n        const idTokenKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ID_TOKEN}`;\r\n        const clientInfoKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.CLIENT_INFO}`;\r\n        const errorKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR}`;\r\n        const errorDescKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR_DESC}`;\r\n\r\n        const idTokenValue = this.browserStorage.getItem(idTokenKey);\r\n        const clientInfoValue = this.browserStorage.getItem(clientInfoKey);\r\n        const errorValue = this.browserStorage.getItem(errorKey);\r\n        const errorDescValue = this.browserStorage.getItem(errorDescKey);\r\n\r\n        const values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\r\n        const keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\r\n\r\n        keysToMigrate.forEach((cacheKey:string, index: number) => this.migrateCacheEntry(cacheKey, values[index]));\r\n    }\r\n\r\n    /**\r\n     * Utility function to help with migration.\r\n     * @param newKey\r\n     * @param value\r\n     * @param storeAuthStateInCookie\r\n     */\r\n    private migrateCacheEntry(newKey: string, value: string|null): void {\r\n        if (value) {\r\n            this.setTemporaryCache(newKey, value, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n     * @param input\r\n     */\r\n    private validateAndParseJson(jsonValue: string): object | null {\r\n        try {\r\n            const parsedJson = JSON.parse(jsonValue);\r\n            /**\r\n             * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n             * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n             * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n             *\r\n             */\r\n            return (parsedJson && typeof parsedJson === \"object\") ? parsedJson : null;\r\n        } catch (error) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * fetches the entry from the browser storage based off the key\r\n     * @param key\r\n     */\r\n    getItem(key: string): string | null {\r\n        return this.browserStorage.getItem(key);\r\n    }\r\n\r\n    /**\r\n     * sets the entry in the browser storage\r\n     * @param key\r\n     * @param value\r\n     */\r\n    setItem(key: string, value: string): void {\r\n        this.browserStorage.setItem(key, value);\r\n    }\r\n\r\n    /**\r\n     * fetch the account entity from the platform cache\r\n     * @param accountKey\r\n     */\r\n    getAccount(accountKey: string): AccountEntity | null {\r\n        const account = this.getItem(accountKey);\r\n        if (!account) {\r\n            return null;\r\n        }\r\n\r\n        const parsedAccount = this.validateAndParseJson(account);\r\n        if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\r\n            return null;\r\n        }\r\n\r\n        return CacheManager.toObject<AccountEntity>(new AccountEntity(), parsedAccount);\r\n    }\r\n\r\n    /**\r\n     * set account entity in the platform cache\r\n     * @param key\r\n     * @param value\r\n     */\r\n    setAccount(account: AccountEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setAccount called\");\r\n        const key = account.generateAccountKey();\r\n        this.setItem(key, JSON.stringify(account));\r\n    }\r\n\r\n    /**\r\n     * generates idToken entity from a string\r\n     * @param idTokenKey\r\n     */\r\n    getIdTokenCredential(idTokenKey: string): IdTokenEntity | null {\r\n        const value = this.getItem(idTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        const parsedIdToken = this.validateAndParseJson(value);\r\n        if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\r\n            this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\r\n        return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\r\n    }\r\n\r\n    /**\r\n     * set IdToken credential to the platform cache\r\n     * @param idToken\r\n     */\r\n    setIdTokenCredential(idToken: IdTokenEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\r\n        const idTokenKey = idToken.generateCredentialKey();\r\n        this.setItem(idTokenKey, JSON.stringify(idToken));\r\n    }\r\n\r\n    /**\r\n     * generates accessToken entity from a string\r\n     * @param key\r\n     */\r\n    getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null {\r\n        const value = this.getItem(accessTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\r\n            return null;\r\n        }\r\n        const parsedAccessToken = this.validateAndParseJson(value);\r\n        if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {\r\n            this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\r\n        return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);\r\n    }\r\n\r\n    /**\r\n     * set accessToken credential to the platform cache\r\n     * @param accessToken\r\n     */\r\n    setAccessTokenCredential(accessToken: AccessTokenEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\r\n        const accessTokenKey = accessToken.generateCredentialKey();\r\n        this.setItem(accessTokenKey, JSON.stringify(accessToken));\r\n    }\r\n\r\n    /**\r\n     * generates refreshToken entity from a string\r\n     * @param refreshTokenKey\r\n     */\r\n    getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null {\r\n        const value = this.getItem(refreshTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\r\n            return null;\r\n        }\r\n        const parsedRefreshToken = this.validateAndParseJson(value);\r\n        if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {\r\n            this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\r\n        return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);\r\n    }\r\n\r\n    /**\r\n     * set refreshToken credential to the platform cache\r\n     * @param refreshToken\r\n     */\r\n    setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\r\n        const refreshTokenKey = refreshToken.generateCredentialKey();\r\n        this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\r\n    }\r\n\r\n    /**\r\n     * fetch appMetadata entity from the platform cache\r\n     * @param appMetadataKey\r\n     */\r\n    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null {\r\n        const value = this.getItem(appMetadataKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        const parsedMetadata = this.validateAndParseJson(value);\r\n        if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\r\n            this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\r\n        return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\r\n    }\r\n\r\n    /**\r\n     * set appMetadata entity to the platform cache\r\n     * @param appMetadata\r\n     */\r\n    setAppMetadata(appMetadata: AppMetadataEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\r\n        const appMetadataKey = appMetadata.generateAppMetadataKey();\r\n        this.setItem(appMetadataKey, JSON.stringify(appMetadata));\r\n    }\r\n\r\n    /**\r\n     * fetch server telemetry entity from the platform cache\r\n     * @param serverTelemetryKey\r\n     */\r\n    getServerTelemetry(serverTelemetryKey: string): ServerTelemetryEntity | null {\r\n        const value = this.getItem(serverTelemetryKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\r\n            return null;\r\n        }\r\n        const parsedMetadata = this.validateAndParseJson(value);\r\n        if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {\r\n            this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\r\n        return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);\r\n    }\r\n\r\n    /**\r\n     * set server telemetry entity to the platform cache\r\n     * @param serverTelemetryKey\r\n     * @param serverTelemetry\r\n     */\r\n    setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\r\n        this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    getAuthorityMetadata(key: string) : AuthorityMetadataEntity | null {\r\n        const value = this.internalStorage.getItem(key);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\r\n            return null;\r\n        }\r\n        const parsedMetadata = this.validateAndParseJson(value);\r\n        if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {\r\n            this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\r\n            return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    getAuthorityMetadataKeys(): Array<string> {\r\n        const allKeys = this.internalStorage.getKeys();\r\n        return allKeys.filter((key) => {\r\n            return this.isAuthorityMetadata(key);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param entity\r\n     */\r\n    setAuthorityMetadata(key: string, entity: AuthorityMetadataEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\r\n        this.internalStorage.setItem(key, JSON.stringify(entity));\r\n    }\r\n\r\n    /**\r\n     * Gets the active account\r\n     */\r\n    getActiveAccount(): AccountInfo | null {\r\n        const activeAccountIdKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\r\n        const activeAccountId = this.browserStorage.getItem(activeAccountIdKey);\r\n        if (!activeAccountId) {\r\n            return null;\r\n        }\r\n        return this.getAccountInfoByFilter({localAccountId: activeAccountId})[0] || null;\r\n    }\r\n\r\n    /**\r\n     * Sets the active account's localAccountId in cache\r\n     * @param account \r\n     */\r\n    setActiveAccount(account: AccountInfo | null): void {\r\n        const activeAccountIdKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\r\n        if (account) {\r\n            this.logger.verbose(\"setActiveAccount: Active account set\");\r\n            this.browserStorage.setItem(activeAccountIdKey, account.localAccountId);\r\n        } else {\r\n            this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\r\n            this.browserStorage.removeItem(activeAccountIdKey);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a list of accounts that match all of the filters provided\r\n     * @param account \r\n     */\r\n    getAccountInfoByFilter(accountFilter: Partial<Omit<AccountInfo, \"idTokenClaims\"|\"name\">>): AccountInfo[] {\r\n        const allAccounts = this.getAllAccounts();\r\n        return allAccounts.filter((accountObj) => {\r\n            if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {\r\n                return false;\r\n            }\r\n\r\n            if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {\r\n                return false;\r\n            }\r\n\r\n            if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {\r\n                return false;\r\n            }\r\n\r\n            if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {\r\n                return false;\r\n            }\r\n\r\n            if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {\r\n                return false;\r\n            }\r\n            \r\n            return true;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * fetch throttling entity from the platform cache\r\n     * @param throttlingCacheKey\r\n     */\r\n    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null {\r\n        const value = this.getItem(throttlingCacheKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        const parsedThrottlingCache = this.validateAndParseJson(value);\r\n        if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\r\n            this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\r\n        return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);\r\n    }\r\n\r\n    /**\r\n     * set throttling entity to the platform cache\r\n     * @param throttlingCacheKey\r\n     * @param throttlingCache\r\n     */\r\n    setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\r\n        this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\r\n    }\r\n\r\n    /**\r\n     * Gets cache item with given key.\r\n     * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n     * @param key\r\n     */\r\n    getTemporaryCache(cacheKey: string, generateKey?: boolean): string | null {\r\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            const itemCookie = this.getItemCookie(key);\r\n            if (itemCookie) {\r\n                this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\r\n                return itemCookie;\r\n            }\r\n        }\r\n\r\n        const value = this.temporaryCacheStorage.getItem(key);\r\n        if (!value) {\r\n            // If temp cache item not found in session/memory, check local storage for items set by old versions\r\n            if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\r\n                const item = this.browserStorage.getItem(key);\r\n                if (item) {\r\n                    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\r\n                    return item;\r\n                }\r\n            }\r\n            this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\r\n            return null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Sets the cache item with the key and value given.\r\n     * Stores in cookie if storeAuthStateInCookie is set to true.\r\n     * This can cause cookie overflow if used incorrectly.\r\n     * @param key\r\n     * @param value\r\n     */\r\n    setTemporaryCache(cacheKey: string, value: string, generateKey?: boolean): void {\r\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\r\n\r\n        this.temporaryCacheStorage.setItem(key, value);\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\r\n            this.setItemCookie(key, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the cache item with the given key.\r\n     * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n     * @param key\r\n     */\r\n    removeItem(key: string): boolean {\r\n        this.browserStorage.removeItem(key);\r\n        this.temporaryCacheStorage.removeItem(key);\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\r\n            this.clearItemCookie(key);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks whether key is in cache.\r\n     * @param key\r\n     */\r\n    containsKey(key: string): boolean {\r\n        return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key);\r\n    }\r\n\r\n    /**\r\n     * Gets all keys in window.\r\n     */\r\n    getKeys(): string[] {\r\n        return [\r\n            ...this.browserStorage.getKeys(),\r\n            ...this.temporaryCacheStorage.getKeys()\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Clears all cache entries created by MSAL (except tokens).\r\n     */\r\n    clear(): void {\r\n        this.removeAllAccounts();\r\n        this.removeAppMetadata();\r\n        this.getKeys().forEach((cacheKey: string) => {\r\n            // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\r\n            if ((this.browserStorage.containsKey(cacheKey) || this.temporaryCacheStorage.containsKey(cacheKey)) && ((cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1) || (cacheKey.indexOf(this.clientId) !== -1))) {\r\n                this.removeItem(cacheKey);\r\n            }\r\n        });\r\n\r\n        this.internalStorage.clear();\r\n    }\r\n\r\n    /**\r\n     * Add value to cookies\r\n     * @param cookieName\r\n     * @param cookieValue\r\n     * @param expires\r\n     */\r\n    setItemCookie(cookieName: string, cookieValue: string, expires?: number): void {\r\n        let cookieStr = `${encodeURIComponent(cookieName)}=${encodeURIComponent(cookieValue)};path=/;`;\r\n        if (expires) {\r\n            const expireTime = this.getCookieExpirationTime(expires);\r\n            cookieStr += `expires=${expireTime};`;\r\n        }\r\n\r\n        if (this.cacheConfig.secureCookies) {\r\n            cookieStr += \"Secure;\";\r\n        }\r\n        \r\n        document.cookie = cookieStr;\r\n    }\r\n\r\n    /**\r\n     * Get one item by key from cookies\r\n     * @param cookieName\r\n     */\r\n    getItemCookie(cookieName: string): string {\r\n        const name = `${encodeURIComponent(cookieName)}=`;\r\n        const cookieList = document.cookie.split(\";\");\r\n        for (let i: number = 0; i < cookieList.length; i++) {\r\n            let cookie = cookieList[i];\r\n            while (cookie.charAt(0) === \" \") {\r\n                cookie = cookie.substring(1);\r\n            }\r\n            if (cookie.indexOf(name) === 0) {\r\n                return decodeURIComponent(cookie.substring(name.length, cookie.length));\r\n            }\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\r\n     */\r\n    clearMsalCookies(): void {\r\n        const cookiePrefix = `${Constants.CACHE_PREFIX}.${this.clientId}`;\r\n        const cookieList = document.cookie.split(\";\");\r\n        cookieList.forEach((cookie: string): void => {\r\n            while (cookie.charAt(0) === \" \") {\r\n                // eslint-disable-next-line no-param-reassign\r\n                cookie = cookie.substring(1);\r\n            }\r\n            if (cookie.indexOf(cookiePrefix) === 0) {\r\n                const cookieKey = cookie.split(\"=\")[0];\r\n                this.clearItemCookie(cookieKey);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Clear an item in the cookies by key\r\n     * @param cookieName\r\n     */\r\n    clearItemCookie(cookieName: string): void {\r\n        this.setItemCookie(cookieName, \"\", -1);\r\n    }\r\n\r\n    /**\r\n     * Get cookie expiration time\r\n     * @param cookieLifeDays\r\n     */\r\n    getCookieExpirationTime(cookieLifeDays: number): string {\r\n        const today = new Date();\r\n        const expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);\r\n        return expr.toUTCString();\r\n    }\r\n\r\n    /**\r\n     * Gets the cache object referenced by the browser\r\n     */\r\n    getCache(): object {\r\n        return this.browserStorage;\r\n    }\r\n\r\n    /**\r\n     * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\r\n     */\r\n    setCache(): void {\r\n        // sets nothing\r\n    }\r\n\r\n    /**\r\n     * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n     * @param key\r\n     * @param addInstanceId\r\n     */\r\n    generateCacheKey(key: string): string {\r\n        const generatedKey = this.validateAndParseJson(key);\r\n        if (!generatedKey) {\r\n            if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\r\n                return key;\r\n            }\r\n            return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;\r\n        }\r\n\r\n        return JSON.stringify(key);\r\n    }\r\n\r\n    /**\r\n     * Create authorityKey to cache authority\r\n     * @param state\r\n     */\r\n    generateAuthorityKey(stateString: string): string {\r\n        const {\r\n            libraryState: {\r\n                id: stateId\r\n            }\r\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\r\n\r\n        return this.generateCacheKey(`${TemporaryCacheKeys.AUTHORITY}.${stateId}`);\r\n    }\r\n\r\n    /**\r\n     * Create Nonce key to cache nonce\r\n     * @param state\r\n     */\r\n    generateNonceKey(stateString: string): string {\r\n        const {\r\n            libraryState: {\r\n                id: stateId\r\n            }\r\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\r\n\r\n        return this.generateCacheKey(`${TemporaryCacheKeys.NONCE_IDTOKEN}.${stateId}`);\r\n    }\r\n\r\n    /**\r\n     * Creates full cache key for the request state\r\n     * @param stateString State string for the request\r\n     */\r\n    generateStateKey(stateString: string): string {\r\n        // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\r\n        const {\r\n            libraryState: {\r\n                id: stateId\r\n            }\r\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\r\n        return this.generateCacheKey(`${TemporaryCacheKeys.REQUEST_STATE}.${stateId}`);\r\n    } \r\n\r\n    /**\r\n     * Gets the cached authority based on the cached state. Returns empty if no cached state found.\r\n     */\r\n    getCachedAuthority(cachedState: string): string | null {\r\n        const stateCacheKey = this.generateStateKey(cachedState);\r\n        const state = this.getTemporaryCache(stateCacheKey);\r\n        if (!state) {\r\n            return null;\r\n        }\r\n\r\n        const authorityCacheKey = this.generateAuthorityKey(state);\r\n        return this.getTemporaryCache(authorityCacheKey);\r\n    }\r\n\r\n    /**\r\n     * Updates account, authority, and state in cache\r\n     * @param serverAuthenticationRequest\r\n     * @param account\r\n     */\r\n    updateCacheEntries(state: string, nonce: string, authorityInstance: string, loginHint: string, account: AccountInfo|null): void {\r\n        this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\");\r\n        // Cache the request state\r\n        const stateCacheKey = this.generateStateKey(state);\r\n        this.setTemporaryCache(stateCacheKey, state, false);\r\n\r\n        // Cache the nonce\r\n        const nonceCacheKey = this.generateNonceKey(state);\r\n        this.setTemporaryCache(nonceCacheKey, nonce, false);\r\n\r\n        // Cache authorityKey\r\n        const authorityCacheKey = this.generateAuthorityKey(state);\r\n        this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\r\n\r\n        if (account) {\r\n            const ccsCredential: CcsCredential = {\r\n                credential: account.homeAccountId,\r\n                type: CcsCredentialType.HOME_ACCOUNT_ID\r\n            };\r\n            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\r\n        } else if (!StringUtils.isEmpty(loginHint)) {\r\n            const ccsCredential: CcsCredential = {\r\n                credential: loginHint,\r\n                type: CcsCredentialType.UPN\r\n            };\r\n            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset all temporary cache items\r\n     * @param state\r\n     */\r\n    resetRequestCache(state: string): void {\r\n        this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\r\n        // check state and remove associated cache items\r\n        if (!StringUtils.isEmpty(state)) {\r\n            this.getKeys().forEach(key => {\r\n                if (key.indexOf(state) !== -1) {\r\n                    this.removeItem(key);\r\n                }\r\n            });\r\n        }\r\n\r\n        // delete generic interactive request parameters\r\n        if (state) {\r\n            this.removeItem(this.generateStateKey(state));\r\n            this.removeItem(this.generateNonceKey(state));\r\n            this.removeItem(this.generateAuthorityKey(state));\r\n        }\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.INTERACTION_STATUS_KEY));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\r\n    }\r\n\r\n    /**\r\n     * Removes temporary cache for the provided state\r\n     * @param stateString \r\n     */\r\n    cleanRequestByState(stateString: string): void {\r\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\");\r\n        // Interaction is completed - remove interaction status.\r\n        if (stateString) {\r\n            const stateKey = this.generateStateKey(stateString);\r\n            const cachedState = this.temporaryCacheStorage.getItem(stateKey);\r\n            this.logger.infoPii(`BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: ${cachedState}`);\r\n            this.resetRequestCache(cachedState || \"\");\r\n        }\r\n        this.clearMsalCookies();\r\n    }\r\n\r\n    /**\r\n     * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\r\n     * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\r\n     * @param interactionType \r\n     */\r\n    cleanRequestByInteractionType(interactionType: InteractionType): void {\r\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\");\r\n        // Loop through all keys to find state key\r\n        this.getKeys().forEach((key) => {\r\n            // If this key is not the state key, move on\r\n            if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\r\n                return;\r\n            }\r\n            \r\n            // Retrieve state value, return if not a valid value\r\n            const stateValue = this.temporaryCacheStorage.getItem(key);\r\n            if (!stateValue) {\r\n                return;\r\n            }\r\n            // Extract state and ensure it matches given InteractionType, then clean request cache\r\n            const parsedState = BrowserProtocolUtils.extractBrowserRequestState(this.cryptoImpl, stateValue);\r\n            if (parsedState && parsedState.interactionType === interactionType) {\r\n                this.logger.infoPii(`BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: ${stateValue}`);\r\n                this.resetRequestCache(stateValue);\r\n            }\r\n        });\r\n        this.clearMsalCookies();\r\n    }\r\n\r\n    cacheCodeRequest(authCodeRequest: CommonAuthorizationCodeRequest, browserCrypto: ICrypto): void {\r\n        this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\r\n\r\n        const encodedValue = browserCrypto.base64Encode(JSON.stringify(authCodeRequest));\r\n        this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\r\n    }\r\n\r\n    /**\r\n     * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n     */\r\n    getCachedRequest(state: string, browserCrypto: ICrypto): CommonAuthorizationCodeRequest {\r\n        this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\r\n        // Get token request from cache and parse as TokenExchangeParameters.\r\n        const encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\r\n        if (!encodedTokenRequest) {\r\n            throw BrowserAuthError.createNoTokenRequestCacheError();\r\n        }\r\n\r\n        const parsedRequest = this.validateAndParseJson(browserCrypto.base64Decode(encodedTokenRequest)) as CommonAuthorizationCodeRequest;\r\n        if (!parsedRequest) {\r\n            throw BrowserAuthError.createUnableToParseTokenRequestCacheError();\r\n        }\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\r\n\r\n        // Get cached authority and use if no authority is cached with request.\r\n        if (StringUtils.isEmpty(parsedRequest.authority)) {\r\n            const authorityCacheKey: string = this.generateAuthorityKey(state);\r\n            const cachedAuthority = this.getTemporaryCache(authorityCacheKey);\r\n            if (!cachedAuthority) {\r\n                throw BrowserAuthError.createNoCachedAuthorityError();\r\n            }\r\n            parsedRequest.authority = cachedAuthority;\r\n        }\r\n\r\n        return parsedRequest;\r\n    }\r\n}\r\n\r\nexport const DEFAULT_BROWSER_CACHE_MANAGER = (clientId: string, logger: Logger): BrowserCacheManager => {\r\n    const cacheOptions = {\r\n        cacheLocation: BrowserCacheLocation.MemoryStorage,\r\n        storeAuthStateInCookie: false,\r\n        secureCookies: false\r\n    };\r\n    return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}