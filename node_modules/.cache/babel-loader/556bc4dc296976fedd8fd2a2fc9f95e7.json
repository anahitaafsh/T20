{"ast":null,"code":"/*! @azure/msal-common v4.5.0 2021-07-22 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { Constants as Constants$1, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.js';\nimport { ClientAuthError as ClientAuthError$1 } from '../error/ClientAuthError.js';\nimport { StringUtils as StringUtils$1 } from '../utils/StringUtils.js';\nimport { ScopeSet as ScopeSet$1 } from '../request/ScopeSet.js';\nimport { buildClientInfo } from '../account/ClientInfo.js';\nimport { AuthorityType as AuthorityType$1 } from '../authority/AuthorityType.js';\nimport { AccountEntity as AccountEntity$1 } from '../cache/entities/AccountEntity.js';\nimport { AuthToken as AuthToken$1 } from '../account/AuthToken.js';\nimport { ServerError as ServerError$1 } from '../error/ServerError.js';\nimport { IdTokenEntity as IdTokenEntity$1 } from '../cache/entities/IdTokenEntity.js';\nimport { AccessTokenEntity as AccessTokenEntity$1 } from '../cache/entities/AccessTokenEntity.js';\nimport { RefreshTokenEntity as RefreshTokenEntity$1 } from '../cache/entities/RefreshTokenEntity.js';\nimport { InteractionRequiredAuthError as InteractionRequiredAuthError$1 } from '../error/InteractionRequiredAuthError.js';\nimport { CacheRecord as CacheRecord$1 } from '../cache/entities/CacheRecord.js';\nimport { ProtocolUtils as ProtocolUtils$1 } from '../utils/ProtocolUtils.js';\nimport { PopTokenGenerator as PopTokenGenerator$1 } from '../crypto/PopTokenGenerator.js';\nimport { AppMetadataEntity as AppMetadataEntity$1 } from '../cache/entities/AppMetadataEntity.js';\nimport { TokenCacheContext as TokenCacheContext$1 } from '../cache/persistence/TokenCacheContext.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Class that handles response parsing.\r\n */\n\nvar ResponseHandler =\n/** @class */\nfunction () {\n  function ResponseHandler(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin) {\n    this.clientId = clientId;\n    this.cacheStorage = cacheStorage;\n    this.cryptoObj = cryptoObj;\n    this.logger = logger;\n    this.serializableCache = serializableCache;\n    this.persistencePlugin = persistencePlugin;\n  }\n  /**\r\n   * Function which validates server authorization code response.\r\n   * @param serverResponseHash\r\n   * @param cachedState\r\n   * @param cryptoObj\r\n   */\n\n\n  ResponseHandler.prototype.validateServerAuthorizationCodeResponse = function (serverResponseHash, cachedState, cryptoObj) {\n    if (!serverResponseHash.state || !cachedState) {\n      throw !serverResponseHash.state ? ClientAuthError$1.createStateNotFoundError(\"Server State\") : ClientAuthError$1.createStateNotFoundError(\"Cached State\");\n    }\n\n    if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {\n      throw ClientAuthError$1.createStateMismatchError();\n    } // Check for error\n\n\n    if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\n      if (InteractionRequiredAuthError$1.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\n        throw new InteractionRequiredAuthError$1(serverResponseHash.error || Constants$1.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\n      }\n\n      throw new ServerError$1(serverResponseHash.error || Constants$1.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\n    }\n\n    if (serverResponseHash.client_info) {\n      buildClientInfo(serverResponseHash.client_info, cryptoObj);\n    }\n  };\n  /**\r\n   * Function which validates server authorization token response.\r\n   * @param serverResponse\r\n   */\n\n\n  ResponseHandler.prototype.validateTokenResponse = function (serverResponse) {\n    // Check for error\n    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\n      if (InteractionRequiredAuthError$1.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n        throw new InteractionRequiredAuthError$1(serverResponse.error, serverResponse.error_description, serverResponse.suberror);\n      }\n\n      var errString = serverResponse.error_codes + \" - [\" + serverResponse.timestamp + \"]: \" + serverResponse.error_description + \" - Correlation ID: \" + serverResponse.correlation_id + \" - Trace ID: \" + serverResponse.trace_id;\n      throw new ServerError$1(serverResponse.error, errString, serverResponse.suberror);\n    }\n  };\n  /**\r\n   * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n   * @param serverTokenResponse\r\n   * @param authority\r\n   */\n\n\n  ResponseHandler.prototype.handleServerTokenResponse = function (serverTokenResponse, authority, reqTimestamp, request, authCodePayload, oboAssertion, handlingRefreshTokenResponse) {\n    return __awaiter(this, void 0, void 0, function () {\n      var idTokenObj, requestStateObj, cacheRecord, cacheContext, key, account;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (serverTokenResponse.id_token) {\n              idTokenObj = new AuthToken$1(serverTokenResponse.id_token || Constants$1.EMPTY_STRING, this.cryptoObj); // token nonce check (TODO: Add a warning if no nonce is given?)\n\n              if (authCodePayload && !StringUtils$1.isEmpty(authCodePayload.nonce)) {\n                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {\n                  throw ClientAuthError$1.createNonceMismatchError();\n                }\n              }\n            } // generate homeAccountId\n\n\n            this.homeAccountIdentifier = AccountEntity$1.generateHomeAccountId(serverTokenResponse.client_info || Constants$1.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);\n\n            if (!!authCodePayload && !!authCodePayload.state) {\n              requestStateObj = ProtocolUtils$1.parseRequestState(this.cryptoObj, authCodePayload.state);\n            }\n\n            cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, idTokenObj, request.scopes, oboAssertion, authCodePayload);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1,, 4, 7]);\n\n            if (!(this.persistencePlugin && this.serializableCache)) return [3\n            /*break*/\n            , 3];\n            this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\n            cacheContext = new TokenCacheContext$1(this.serializableCache, true);\n            return [4\n            /*yield*/\n            , this.persistencePlugin.beforeCacheAccess(cacheContext)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            /*\r\n             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n             * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal.\r\n             */\n            if (handlingRefreshTokenResponse && cacheRecord.account) {\n              key = cacheRecord.account.generateAccountKey();\n              account = this.cacheStorage.getAccount(key);\n\n              if (!account) {\n                this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\n                return [2\n                /*return*/\n                , ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj)];\n              }\n            }\n\n            this.cacheStorage.saveCacheRecord(cacheRecord);\n            return [3\n            /*break*/\n            , 7];\n\n          case 4:\n            if (!(this.persistencePlugin && this.serializableCache && cacheContext)) return [3\n            /*break*/\n            , 6];\n            this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\n            return [4\n            /*yield*/\n            , this.persistencePlugin.afterCacheAccess(cacheContext)];\n\n          case 5:\n            _a.sent();\n\n            _a.label = 6;\n\n          case 6:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 7:\n            return [2\n            /*return*/\n            , ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Generates CacheRecord\r\n   * @param serverTokenResponse\r\n   * @param idTokenObj\r\n   * @param authority\r\n   */\n\n\n  ResponseHandler.prototype.generateCacheRecord = function (serverTokenResponse, authority, reqTimestamp, idTokenObj, requestScopes, oboAssertion, authCodePayload) {\n    var env = authority.getPreferredCache();\n\n    if (StringUtils$1.isEmpty(env)) {\n      throw ClientAuthError$1.createInvalidCacheEnvironmentError();\n    } // IdToken: non AAD scenarios can have empty realm\n\n\n    var cachedIdToken;\n    var cachedAccount;\n\n    if (!StringUtils$1.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {\n      cachedIdToken = IdTokenEntity$1.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants$1.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants$1.EMPTY_STRING, oboAssertion);\n      cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, oboAssertion, authCodePayload);\n    } // AccessToken\n\n\n    var cachedAccessToken = null;\n\n    if (!StringUtils$1.isEmpty(serverTokenResponse.access_token)) {\n      // If scopes not returned in server response, use request scopes\n      var responseScopes = serverTokenResponse.scope ? ScopeSet$1.fromString(serverTokenResponse.scope) : new ScopeSet$1(requestScopes || []);\n      /*\r\n       * Use timestamp calculated before request\r\n       * Server may return timestamps as strings, parse to numbers if so.\r\n       */\n\n      var expiresIn = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\n      var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\n      var refreshIn = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\n      var tokenExpirationSeconds = reqTimestamp + expiresIn;\n      var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\n      var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined; // non AAD scenarios can have empty realm\n\n      cachedAccessToken = AccessTokenEntity$1.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants$1.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants$1.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, oboAssertion);\n    } // refreshToken\n\n\n    var cachedRefreshToken = null;\n\n    if (!StringUtils$1.isEmpty(serverTokenResponse.refresh_token)) {\n      cachedRefreshToken = RefreshTokenEntity$1.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants$1.EMPTY_STRING, this.clientId, serverTokenResponse.foci, oboAssertion);\n    } // appMetadata\n\n\n    var cachedAppMetadata = null;\n\n    if (!StringUtils$1.isEmpty(serverTokenResponse.foci)) {\n      cachedAppMetadata = AppMetadataEntity$1.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\n    }\n\n    return new CacheRecord$1(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\n  };\n  /**\r\n   * Generate Account\r\n   * @param serverTokenResponse\r\n   * @param idToken\r\n   * @param authority\r\n   */\n\n\n  ResponseHandler.prototype.generateAccountEntity = function (serverTokenResponse, idToken, authority, oboAssertion, authCodePayload) {\n    var authorityType = authority.authorityType;\n    var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : \"\";\n    var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : \"\"; // ADFS does not require client_info in the response\n\n    if (authorityType === AuthorityType$1.Adfs) {\n      this.logger.verbose(\"Authority type is ADFS, creating ADFS account\");\n      return AccountEntity$1.createGenericAccount(authority, this.homeAccountIdentifier, idToken, oboAssertion, cloudGraphHostName, msGraphhost);\n    } // This fallback applies to B2C as well as they fall under an AAD account type.\n\n\n    if (StringUtils$1.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === \"AAD\") {\n      throw ClientAuthError$1.createClientInfoEmptyError();\n    }\n\n    return serverTokenResponse.client_info ? AccountEntity$1.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, authority, idToken, oboAssertion, cloudGraphHostName, msGraphhost) : AccountEntity$1.createGenericAccount(authority, this.homeAccountIdentifier, idToken, oboAssertion, cloudGraphHostName, msGraphhost);\n  };\n  /**\r\n   * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n   *\r\n   * Optionally takes a state string that is set as-is in the response.\r\n   *\r\n   * @param cacheRecord\r\n   * @param idTokenObj\r\n   * @param fromTokenCache\r\n   * @param stateString\r\n   */\n\n\n  ResponseHandler.generateAuthenticationResult = function (cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenObj, requestState) {\n    var _a, _b, _c;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, uid, tid;\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            accessToken = \"\";\n            responseScopes = [];\n            expiresOn = null;\n            familyId = Constants$1.EMPTY_STRING;\n            if (!cacheRecord.accessToken) return [3\n            /*break*/\n            , 4];\n            if (!(cacheRecord.accessToken.tokenType === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 2];\n            popTokenGenerator = new PopTokenGenerator$1(cryptoObj);\n            return [4\n            /*yield*/\n            , popTokenGenerator.signPopToken(cacheRecord.accessToken.secret, request)];\n\n          case 1:\n            accessToken = _d.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            accessToken = cacheRecord.accessToken.secret;\n            _d.label = 3;\n\n          case 3:\n            responseScopes = ScopeSet$1.fromString(cacheRecord.accessToken.target).asArray();\n            expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\n            extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\n            _d.label = 4;\n\n          case 4:\n            if (cacheRecord.appMetadata) {\n              familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants$1.EMPTY_STRING;\n            }\n\n            uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants$1.EMPTY_STRING;\n            tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants$1.EMPTY_STRING;\n            return [2\n            /*return*/\n            , {\n              authority: authority.canonicalAuthority,\n              uniqueId: uid,\n              tenantId: tid,\n              scopes: responseScopes,\n              account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\n              idToken: idTokenObj ? idTokenObj.rawToken : Constants$1.EMPTY_STRING,\n              idTokenClaims: idTokenObj ? idTokenObj.claims : {},\n              accessToken: accessToken,\n              fromCache: fromTokenCache,\n              expiresOn: expiresOn,\n              extExpiresOn: extExpiresOn,\n              familyId: familyId,\n              tokenType: ((_a = cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants$1.EMPTY_STRING,\n              state: requestState ? requestState.userRequestState : Constants$1.EMPTY_STRING,\n              cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants$1.EMPTY_STRING,\n              msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants$1.EMPTY_STRING\n            }];\n        }\n      });\n    });\n  };\n\n  return ResponseHandler;\n}();\n\nexport { ResponseHandler };","map":{"version":3,"mappings":"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","names":["clientId","cacheStorage","cryptoObj","logger","serializableCache","persistencePlugin","ResponseHandler","serverResponseHash","cachedState","state","ClientAuthError","createStateNotFoundError","decodeURIComponent","createStateMismatchError","error","error_description","suberror","InteractionRequiredAuthError","isInteractionRequiredError","Constants","EMPTY_STRING","ServerError","client_info","buildClientInfo","serverResponse","errString","error_codes","timestamp","correlation_id","trace_id","serverTokenResponse","authority","reqTimestamp","request","authCodePayload","oboAssertion","handlingRefreshTokenResponse","id_token","idTokenObj","AuthToken","StringUtils","isEmpty","nonce","claims","createNonceMismatchError","homeAccountIdentifier","AccountEntity","generateHomeAccountId","authorityType","requestStateObj","ProtocolUtils","parseRequestState","cacheRecord","generateCacheRecord","scopes","verbose","cacheContext","TokenCacheContext","beforeCacheAccess","_a","account","key","generateAccountKey","getAccount","warning","generateAuthenticationResult","saveCacheRecord","afterCacheAccess","requestScopes","env","getPreferredCache","createInvalidCacheEnvironmentError","cachedIdToken","cachedAccount","IdTokenEntity","createIdTokenEntity","tid","generateAccountEntity","cachedAccessToken","access_token","responseScopes","scope","ScopeSet","fromString","expiresIn","expires_in","parseInt","extExpiresIn","ext_expires_in","refreshIn","refresh_in","undefined","tokenExpirationSeconds","extendedTokenExpirationSeconds","refreshOnSeconds","AccessTokenEntity","createAccessTokenEntity","tenant","printScopes","token_type","cachedRefreshToken","refresh_token","RefreshTokenEntity","createRefreshTokenEntity","foci","cachedAppMetadata","AppMetadataEntity","createAppMetadataEntity","CacheRecord","idToken","cloudGraphHostName","cloud_graph_host_name","msGraphhost","msgraph_host","AuthorityType","Adfs","createGenericAccount","protocolMode","createClientInfoEmptyError","createAccount","fromTokenCache","requestState","accessToken","expiresOn","familyId","tokenType","AuthenticationScheme","POP","popTokenGenerator","PopTokenGenerator","signPopToken","secret","_d","target","asArray","Date","Number","extExpiresOn","extendedExpiresOn","appMetadata","THE_FAMILY_ID","uid","oid","sub","canonicalAuthority","uniqueId","tenantId","getAccountInfo","rawToken","idTokenClaims","fromCache","userRequestState","_b","msGraphHost","_c"],"sources":["../../src/response/ResponseHandler.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ServerAuthorizationTokenResponse } from \"./ServerAuthorizationTokenResponse\";\r\nimport { buildClientInfo} from \"../account/ClientInfo\";\r\nimport { ICrypto } from \"../crypto/ICrypto\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { ServerAuthorizationCodeResponse } from \"./ServerAuthorizationCodeResponse\";\r\nimport { Logger } from \"../logger/Logger\";\r\nimport { ServerError } from \"../error/ServerError\";\r\nimport { AuthToken } from \"../account/AuthToken\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\nimport { AuthenticationResult } from \"./AuthenticationResult\";\r\nimport { AccountEntity } from \"../cache/entities/AccountEntity\";\r\nimport { Authority } from \"../authority/Authority\";\r\nimport { AuthorityType } from \"../authority/AuthorityType\";\r\nimport { IdTokenEntity } from \"../cache/entities/IdTokenEntity\";\r\nimport { AccessTokenEntity } from \"../cache/entities/AccessTokenEntity\";\r\nimport { RefreshTokenEntity } from \"../cache/entities/RefreshTokenEntity\";\r\nimport { InteractionRequiredAuthError } from \"../error/InteractionRequiredAuthError\";\r\nimport { CacheRecord } from \"../cache/entities/CacheRecord\";\r\nimport { CacheManager } from \"../cache/CacheManager\";\r\nimport { ProtocolUtils, RequestStateObject } from \"../utils/ProtocolUtils\";\r\nimport { AuthenticationScheme, Constants, THE_FAMILY_ID } from \"../utils/Constants\";\r\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator\";\r\nimport { AppMetadataEntity } from \"../cache/entities/AppMetadataEntity\";\r\nimport { ICachePlugin } from \"../cache/interface/ICachePlugin\";\r\nimport { TokenCacheContext } from \"../cache/persistence/TokenCacheContext\";\r\nimport { ISerializableTokenCache } from \"../cache/interface/ISerializableTokenCache\";\r\nimport { AuthorizationCodePayload } from \"./AuthorizationCodePayload\";\r\nimport { BaseAuthRequest } from \"../request/BaseAuthRequest\";\r\n\r\n/**\r\n * Class that handles response parsing.\r\n */\r\nexport class ResponseHandler {\r\n    private clientId: string;\r\n    private cacheStorage: CacheManager;\r\n    private cryptoObj: ICrypto;\r\n    private logger: Logger;\r\n    private homeAccountIdentifier: string;\r\n    private serializableCache: ISerializableTokenCache | null;\r\n    private persistencePlugin: ICachePlugin | null;\r\n\r\n    constructor(clientId: string, cacheStorage: CacheManager, cryptoObj: ICrypto, logger: Logger, serializableCache: ISerializableTokenCache | null, persistencePlugin: ICachePlugin | null) {\r\n        this.clientId = clientId;\r\n        this.cacheStorage = cacheStorage;\r\n        this.cryptoObj = cryptoObj;\r\n        this.logger = logger;\r\n        this.serializableCache = serializableCache;\r\n        this.persistencePlugin = persistencePlugin;\r\n    }\r\n\r\n    /**\r\n     * Function which validates server authorization code response.\r\n     * @param serverResponseHash\r\n     * @param cachedState\r\n     * @param cryptoObj\r\n     */\r\n    validateServerAuthorizationCodeResponse(serverResponseHash: ServerAuthorizationCodeResponse, cachedState: string, cryptoObj: ICrypto): void {\r\n\r\n        if (!serverResponseHash.state || !cachedState) {\r\n            throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError(\"Server State\") : ClientAuthError.createStateNotFoundError(\"Cached State\");\r\n        }\r\n\r\n        if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {\r\n            throw ClientAuthError.createStateMismatchError();\r\n        }\r\n\r\n        // Check for error\r\n        if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\r\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\r\n                throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\r\n            }\r\n\r\n            throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\r\n        }\r\n\r\n        if (serverResponseHash.client_info) {\r\n            buildClientInfo(serverResponseHash.client_info, cryptoObj);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function which validates server authorization token response.\r\n     * @param serverResponse\r\n     */\r\n    validateTokenResponse(serverResponse: ServerAuthorizationTokenResponse): void {\r\n        // Check for error\r\n        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\r\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\r\n                throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror);\r\n            }\r\n\r\n            const errString = `${serverResponse.error_codes} - [${serverResponse.timestamp}]: ${serverResponse.error_description} - Correlation ID: ${serverResponse.correlation_id} - Trace ID: ${serverResponse.trace_id}`;\r\n            throw new ServerError(serverResponse.error, errString, serverResponse.suberror);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n     * @param serverTokenResponse\r\n     * @param authority\r\n     */\r\n    async handleServerTokenResponse(\r\n        serverTokenResponse: ServerAuthorizationTokenResponse,\r\n        authority: Authority,\r\n        reqTimestamp: number,\r\n        request: BaseAuthRequest,\r\n        authCodePayload?: AuthorizationCodePayload,\r\n        oboAssertion?: string,\r\n        handlingRefreshTokenResponse?: boolean): Promise<AuthenticationResult> {\r\n\r\n        // create an idToken object (not entity)\r\n        let idTokenObj: AuthToken | undefined;\r\n        if (serverTokenResponse.id_token) {\r\n            idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj);\r\n    \r\n            // token nonce check (TODO: Add a warning if no nonce is given?)\r\n            if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {\r\n                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {\r\n                    throw ClientAuthError.createNonceMismatchError();\r\n                }\r\n            }\r\n        }\r\n\r\n        // generate homeAccountId\r\n        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);\r\n\r\n        // save the response tokens\r\n        let requestStateObj: RequestStateObject | undefined;\r\n        if (!!authCodePayload && !!authCodePayload.state) {\r\n            requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\r\n        }\r\n\r\n        const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, idTokenObj, request.scopes, oboAssertion, authCodePayload);\r\n        let cacheContext;\r\n        try {\r\n            if (this.persistencePlugin && this.serializableCache) {\r\n                this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\r\n                cacheContext = new TokenCacheContext(this.serializableCache, true);\r\n                await this.persistencePlugin.beforeCacheAccess(cacheContext);\r\n            }\r\n            /*\r\n             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n             * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal.\r\n             */\r\n            if (handlingRefreshTokenResponse && cacheRecord.account) {\r\n                const key = cacheRecord.account.generateAccountKey();\r\n                const account = this.cacheStorage.getAccount(key);\r\n                if (!account) {\r\n                    this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\r\n                    return ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj);\r\n                }\r\n            }\r\n            this.cacheStorage.saveCacheRecord(cacheRecord);\r\n        } finally {\r\n            if (this.persistencePlugin && this.serializableCache && cacheContext) {\r\n                this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\r\n                await this.persistencePlugin.afterCacheAccess(cacheContext);\r\n            }\r\n        }\r\n        return ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj);\r\n    }\r\n\r\n    /**\r\n     * Generates CacheRecord\r\n     * @param serverTokenResponse\r\n     * @param idTokenObj\r\n     * @param authority\r\n     */\r\n    private generateCacheRecord(serverTokenResponse: ServerAuthorizationTokenResponse, authority: Authority, reqTimestamp: number, idTokenObj?: AuthToken, requestScopes?: string[], oboAssertion?: string, authCodePayload?: AuthorizationCodePayload): CacheRecord {\r\n        const env = authority.getPreferredCache();\r\n        if (StringUtils.isEmpty(env)) {\r\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\r\n        }\r\n\r\n        // IdToken: non AAD scenarios can have empty realm\r\n        let cachedIdToken: IdTokenEntity | undefined;\r\n        let cachedAccount: AccountEntity | undefined;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {\r\n            cachedIdToken = IdTokenEntity.createIdTokenEntity(\r\n                this.homeAccountIdentifier,\r\n                env,\r\n                serverTokenResponse.id_token || Constants.EMPTY_STRING,\r\n                this.clientId,\r\n                idTokenObj.claims.tid || Constants.EMPTY_STRING,\r\n                oboAssertion\r\n            );\r\n\r\n            cachedAccount = this.generateAccountEntity(\r\n                serverTokenResponse,\r\n                idTokenObj,\r\n                authority,\r\n                oboAssertion,\r\n                authCodePayload\r\n            );\r\n        }\r\n\r\n        // AccessToken\r\n        let cachedAccessToken: AccessTokenEntity | null = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {\r\n\r\n            // If scopes not returned in server response, use request scopes\r\n            const responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(requestScopes || []);\r\n\r\n            /*\r\n             * Use timestamp calculated before request\r\n             * Server may return timestamps as strings, parse to numbers if so.\r\n             */\r\n            const expiresIn: number = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\r\n            const extExpiresIn: number = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\r\n            const refreshIn: number | undefined = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\r\n            const tokenExpirationSeconds = reqTimestamp + expiresIn;\r\n            const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\r\n            const refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;\r\n\r\n            // non AAD scenarios can have empty realm\r\n            cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(\r\n                this.homeAccountIdentifier,\r\n                env,\r\n                serverTokenResponse.access_token || Constants.EMPTY_STRING,\r\n                this.clientId,\r\n                idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant,\r\n                responseScopes.printScopes(),\r\n                tokenExpirationSeconds,\r\n                extendedTokenExpirationSeconds,\r\n                this.cryptoObj,\r\n                refreshOnSeconds,\r\n                serverTokenResponse.token_type,\r\n                oboAssertion\r\n            );\r\n        }\r\n\r\n        // refreshToken\r\n        let cachedRefreshToken: RefreshTokenEntity | null = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {\r\n            cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(\r\n                this.homeAccountIdentifier,\r\n                env,\r\n                serverTokenResponse.refresh_token || Constants.EMPTY_STRING,\r\n                this.clientId,\r\n                serverTokenResponse.foci,\r\n                oboAssertion\r\n            );\r\n        }\r\n\r\n        // appMetadata\r\n        let cachedAppMetadata: AppMetadataEntity | null = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.foci)) {\r\n            cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\r\n        }\r\n\r\n        return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\r\n    }\r\n\r\n    /**\r\n     * Generate Account\r\n     * @param serverTokenResponse\r\n     * @param idToken\r\n     * @param authority\r\n     */\r\n    private generateAccountEntity(serverTokenResponse: ServerAuthorizationTokenResponse, idToken: AuthToken, authority: Authority, oboAssertion?: string, authCodePayload?: AuthorizationCodePayload): AccountEntity {\r\n        const authorityType = authority.authorityType;\r\n        const cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : \"\";\r\n        const msGraphhost = authCodePayload ? authCodePayload.msgraph_host : \"\";\r\n\r\n        // ADFS does not require client_info in the response\r\n        if (authorityType === AuthorityType.Adfs) {\r\n            this.logger.verbose(\"Authority type is ADFS, creating ADFS account\");\r\n            return AccountEntity.createGenericAccount(authority, this.homeAccountIdentifier, idToken, oboAssertion, cloudGraphHostName, msGraphhost);\r\n        }\r\n\r\n        // This fallback applies to B2C as well as they fall under an AAD account type.\r\n        if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === \"AAD\") {\r\n            throw ClientAuthError.createClientInfoEmptyError();\r\n        }\r\n\r\n        return serverTokenResponse.client_info ?\r\n            AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, authority, idToken, oboAssertion, cloudGraphHostName, msGraphhost) :\r\n            AccountEntity.createGenericAccount(authority, this.homeAccountIdentifier, idToken, oboAssertion, cloudGraphHostName, msGraphhost);\r\n    }\r\n\r\n    /**\r\n     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n     *\r\n     * Optionally takes a state string that is set as-is in the response.\r\n     *\r\n     * @param cacheRecord\r\n     * @param idTokenObj\r\n     * @param fromTokenCache\r\n     * @param stateString\r\n     */\r\n    static async generateAuthenticationResult(\r\n        cryptoObj: ICrypto, \r\n        authority: Authority,\r\n        cacheRecord: CacheRecord, \r\n        fromTokenCache: boolean, \r\n        request: BaseAuthRequest,\r\n        idTokenObj?: AuthToken,\r\n        requestState?: RequestStateObject): Promise<AuthenticationResult> {\r\n        let accessToken: string = \"\";\r\n        let responseScopes: Array<string> = [];\r\n        let expiresOn: Date | null = null;\r\n        let extExpiresOn: Date | undefined;\r\n        let familyId: string = Constants.EMPTY_STRING;\r\n\r\n        if (cacheRecord.accessToken) {\r\n            if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP) {\r\n                const popTokenGenerator: PopTokenGenerator = new PopTokenGenerator(cryptoObj);\r\n                accessToken = await popTokenGenerator.signPopToken(cacheRecord.accessToken.secret, request);\r\n            } else {\r\n                accessToken = cacheRecord.accessToken.secret;\r\n            }\r\n            responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\r\n            expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\r\n            extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\r\n        }\r\n\r\n        if (cacheRecord.appMetadata) {\r\n            familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;\r\n        }\r\n        const uid = idTokenObj?.claims.oid || idTokenObj?.claims.sub || Constants.EMPTY_STRING;\r\n        const tid = idTokenObj?.claims.tid || Constants.EMPTY_STRING;\r\n\r\n        return {\r\n            authority: authority.canonicalAuthority,\r\n            uniqueId: uid,\r\n            tenantId: tid,\r\n            scopes: responseScopes,\r\n            account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\r\n            idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,\r\n            idTokenClaims: idTokenObj ? idTokenObj.claims : {},\r\n            accessToken: accessToken,\r\n            fromCache: fromTokenCache,\r\n            expiresOn: expiresOn,\r\n            extExpiresOn: extExpiresOn,\r\n            familyId: familyId,\r\n            tokenType: cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,\r\n            state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\r\n            cloudGraphHostName: cacheRecord.account?.cloudGraphHostName || Constants.EMPTY_STRING,\r\n            msGraphHost: cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING\r\n        };\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}