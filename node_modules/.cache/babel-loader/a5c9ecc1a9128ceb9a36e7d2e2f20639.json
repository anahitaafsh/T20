{"ast":null,"code":"/*! @azure/msal-browser v2.29.0 2022-10-03 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BrowserStringUtils } from '../utils/BrowserStringUtils.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { ModernBrowserCrypto } from './ModernBrowserCrypto.js';\nimport { MsrBrowserCrypto } from './MsrBrowserCrypto.js';\nimport { MsBrowserCrypto } from './MsBrowserCrypto.js';\nimport { BrowserConfigurationAuthError } from '../error/BrowserConfigurationAuthError.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * See here for more info on RsaHashedKeyGenParams: https://developer.mozilla.org/en-US/docs/Web/API/RsaHashedKeyGenParams\r\n */\n// RSA KeyGen Algorithm\n\nvar PKCS1_V15_KEYGEN_ALG = \"RSASSA-PKCS1-v1_5\"; // SHA-256 hashing algorithm\n\nvar S256_HASH_ALG = \"SHA-256\"; // MOD length for PoP tokens\n\nvar MODULUS_LENGTH = 2048; // Public Exponent\n\nvar PUBLIC_EXPONENT = new Uint8Array([0x01, 0x00, 0x01]);\n/**\r\n * This class implements functions used by the browser library to perform cryptography operations such as\r\n * hashing and encoding. It also has helper functions to validate the availability of specific APIs.\r\n */\n\nvar BrowserCrypto =\n/** @class */\nfunction () {\n  function BrowserCrypto(logger, cryptoOptions) {\n    var _a, _b;\n\n    this.logger = logger;\n    this.cryptoOptions = cryptoOptions;\n\n    if (this.hasBrowserCrypto()) {\n      // Use standard modern web crypto if available\n      this.logger.verbose(\"BrowserCrypto: modern crypto interface available\");\n      this.subtleCrypto = new ModernBrowserCrypto();\n    } else if (this.hasIECrypto()) {\n      // For IE11, use msCrypto interface\n      this.logger.verbose(\"BrowserCrypto: MS crypto interface available\");\n      this.subtleCrypto = new MsBrowserCrypto();\n    } else if (this.hasMsrCrypto() && ((_a = this.cryptoOptions) === null || _a === void 0 ? void 0 : _a.useMsrCrypto)) {\n      // For other browsers, use MSR Crypto if found\n      this.logger.verbose(\"BrowserCrypto: MSR crypto interface available\");\n      this.subtleCrypto = new MsrBrowserCrypto();\n    } else {\n      if (this.hasMsrCrypto()) {\n        this.logger.info(\"BrowserCrypto: MSR Crypto interface available but system.cryptoOptions.useMsrCrypto not enabled\");\n      }\n\n      this.logger.error(\"BrowserCrypto: No crypto interfaces available.\");\n      throw BrowserAuthError.createCryptoNotAvailableError(\"Browser crypto, msCrypto, or msrCrypto interfaces not available.\");\n    } // Mainly needed for MSR Crypto: https://github.com/microsoft/MSR-JavaScript-Crypto#random-number-generator-prng\n\n\n    if (this.subtleCrypto.initPrng) {\n      this.logger.verbose(\"BrowserCrypto: Interface requires entropy\");\n\n      if (!((_b = this.cryptoOptions) === null || _b === void 0 ? void 0 : _b.entropy)) {\n        this.logger.error(\"BrowserCrypto: Interface requires entropy but none provided.\");\n        throw BrowserConfigurationAuthError.createEntropyNotProvided();\n      }\n\n      this.logger.verbose(\"BrowserCrypto: Entropy provided\");\n      this.subtleCrypto.initPrng(this.cryptoOptions.entropy);\n    }\n\n    this.keygenAlgorithmOptions = {\n      name: PKCS1_V15_KEYGEN_ALG,\n      hash: S256_HASH_ALG,\n      modulusLength: MODULUS_LENGTH,\n      publicExponent: PUBLIC_EXPONENT\n    };\n  }\n  /**\r\n   * Check whether IE crypto or other browser cryptography is available.\r\n   */\n\n\n  BrowserCrypto.prototype.hasIECrypto = function () {\n    return \"msCrypto\" in window;\n  };\n  /**\r\n   * Check whether browser crypto is available.\r\n   */\n\n\n  BrowserCrypto.prototype.hasBrowserCrypto = function () {\n    return \"crypto\" in window;\n  };\n  /**\r\n   * Check whether MSR crypto polyfill is available\r\n   */\n\n\n  BrowserCrypto.prototype.hasMsrCrypto = function () {\n    return \"msrCrypto\" in window;\n  };\n  /**\r\n   * Returns a sha-256 hash of the given dataString as an ArrayBuffer.\r\n   * @param dataString\r\n   */\n\n\n  BrowserCrypto.prototype.sha256Digest = function (dataString) {\n    return __awaiter(this, void 0, void 0, function () {\n      var data;\n      return __generator(this, function (_a) {\n        data = BrowserStringUtils.stringToUtf8Arr(dataString); // MSR Crypto wants object with name property, instead of string\n\n        return [2\n        /*return*/\n        , this.subtleCrypto.digest({\n          name: S256_HASH_ALG\n        }, data)];\n      });\n    });\n  };\n  /**\r\n   * Populates buffer with cryptographically random values.\r\n   * @param dataBuffer\r\n   */\n\n\n  BrowserCrypto.prototype.getRandomValues = function (dataBuffer) {\n    return this.subtleCrypto.getRandomValues(dataBuffer);\n  };\n  /**\r\n   * Generates a keypair based on current keygen algorithm config.\r\n   * @param extractable\r\n   * @param usages\r\n   */\n\n\n  BrowserCrypto.prototype.generateKeyPair = function (extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.subtleCrypto.generateKey(this.keygenAlgorithmOptions, extractable, usages)];\n      });\n    });\n  };\n  /**\r\n   * Export key as Json Web Key (JWK)\r\n   * @param key\r\n   * @param format\r\n   */\n\n\n  BrowserCrypto.prototype.exportJwk = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.subtleCrypto.exportKey(key)];\n      });\n    });\n  };\n  /**\r\n   * Imports key as Json Web Key (JWK), can set extractable and usages.\r\n   * @param key\r\n   * @param format\r\n   * @param extractable\r\n   * @param usages\r\n   */\n\n\n  BrowserCrypto.prototype.importJwk = function (key, extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.subtleCrypto.importKey(key, this.keygenAlgorithmOptions, extractable, usages)];\n      });\n    });\n  };\n  /**\r\n   * Signs given data with given key\r\n   * @param key\r\n   * @param data\r\n   */\n\n\n  BrowserCrypto.prototype.sign = function (key, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.subtleCrypto.sign(this.keygenAlgorithmOptions, key, data)];\n      });\n    });\n  };\n\n  return BrowserCrypto;\n}();\n\nexport { BrowserCrypto };","map":{"version":3,"mappings":"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","names":["PKCS1_V15_KEYGEN_ALG","S256_HASH_ALG","MODULUS_LENGTH","PUBLIC_EXPONENT","Uint8Array","logger","cryptoOptions","hasBrowserCrypto","verbose","subtleCrypto","ModernBrowserCrypto","hasIECrypto","MsBrowserCrypto","hasMsrCrypto","_a","useMsrCrypto","MsrBrowserCrypto","info","error","BrowserAuthError","createCryptoNotAvailableError","initPrng","_b","entropy","BrowserConfigurationAuthError","createEntropyNotProvided","keygenAlgorithmOptions","name","hash","modulusLength","publicExponent","BrowserCrypto","window","dataString","data","BrowserStringUtils","stringToUtf8Arr","digest","dataBuffer","getRandomValues","extractable","usages","generateKey","key","exportKey","importKey","sign"],"sources":["../../src/crypto/BrowserCrypto.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { BrowserStringUtils } from \"../utils/BrowserStringUtils\";\nimport { BrowserAuthError } from \"../error/BrowserAuthError\";\nimport { ISubtleCrypto } from \"./ISubtleCrypto\";\nimport { ModernBrowserCrypto } from \"./ModernBrowserCrypto\";\nimport { MsrBrowserCrypto } from \"./MsrBrowserCrypto\";\nimport { MsBrowserCrypto } from \"./MsBrowserCrypto\";\nimport { Logger } from \"@azure/msal-common\";\nimport { BrowserConfigurationAuthError } from \"../error/BrowserConfigurationAuthError\";\nimport { CryptoOptions } from \"../config/Configuration\";\n/**\n * See here for more info on RsaHashedKeyGenParams: https://developer.mozilla.org/en-US/docs/Web/API/RsaHashedKeyGenParams\n */\n// RSA KeyGen Algorithm\nconst PKCS1_V15_KEYGEN_ALG = \"RSASSA-PKCS1-v1_5\";\n// SHA-256 hashing algorithm\nconst S256_HASH_ALG = \"SHA-256\";\n// MOD length for PoP tokens\nconst MODULUS_LENGTH = 2048;\n// Public Exponent\nconst PUBLIC_EXPONENT: Uint8Array = new Uint8Array([0x01, 0x00, 0x01]);\n\n/**\n * This class implements functions used by the browser library to perform cryptography operations such as\n * hashing and encoding. It also has helper functions to validate the availability of specific APIs.\n */\nexport class BrowserCrypto {\n\n    private keygenAlgorithmOptions: RsaHashedKeyGenParams;\n    private subtleCrypto: ISubtleCrypto;\n    private logger: Logger;\n    private cryptoOptions?: CryptoOptions;\n\n    constructor(logger: Logger, cryptoOptions?: CryptoOptions) {\n        this.logger = logger;\n        this.cryptoOptions = cryptoOptions;\n\n        if (this.hasBrowserCrypto()) {\n            // Use standard modern web crypto if available\n            this.logger.verbose(\"BrowserCrypto: modern crypto interface available\");\n            this.subtleCrypto = new ModernBrowserCrypto();\n        } else if (this.hasIECrypto()) {\n            // For IE11, use msCrypto interface\n            this.logger.verbose(\"BrowserCrypto: MS crypto interface available\");\n            this.subtleCrypto = new MsBrowserCrypto();\n        } else if (this.hasMsrCrypto() && this.cryptoOptions?.useMsrCrypto) {\n            // For other browsers, use MSR Crypto if found\n            this.logger.verbose(\"BrowserCrypto: MSR crypto interface available\");\n            this.subtleCrypto = new MsrBrowserCrypto();\n        } else {\n            if (this.hasMsrCrypto()) {\n                this.logger.info(\"BrowserCrypto: MSR Crypto interface available but system.cryptoOptions.useMsrCrypto not enabled\");\n            }\n            this.logger.error(\"BrowserCrypto: No crypto interfaces available.\");\n            throw BrowserAuthError.createCryptoNotAvailableError(\"Browser crypto, msCrypto, or msrCrypto interfaces not available.\");\n        }\n\n        // Mainly needed for MSR Crypto: https://github.com/microsoft/MSR-JavaScript-Crypto#random-number-generator-prng\n        if (this.subtleCrypto.initPrng) {\n            this.logger.verbose(\"BrowserCrypto: Interface requires entropy\");\n\n            if (!this.cryptoOptions?.entropy) {\n                this.logger.error(\"BrowserCrypto: Interface requires entropy but none provided.\");\n                throw BrowserConfigurationAuthError.createEntropyNotProvided();\n            }\n\n            this.logger.verbose(\"BrowserCrypto: Entropy provided\");\n            this.subtleCrypto.initPrng(this.cryptoOptions.entropy);\n        }\n\n        this.keygenAlgorithmOptions = {\n            name: PKCS1_V15_KEYGEN_ALG,\n            hash: S256_HASH_ALG,\n            modulusLength: MODULUS_LENGTH,\n            publicExponent: PUBLIC_EXPONENT\n        };\n    }\n\n    /**\n     * Check whether IE crypto or other browser cryptography is available.\n     */\n    private hasIECrypto(): boolean {\n        return \"msCrypto\" in window;\n    }\n\n    /**\n     * Check whether browser crypto is available.\n     */\n    private hasBrowserCrypto(): boolean {\n        return \"crypto\" in window;\n    }\n\n    /**\n     * Check whether MSR crypto polyfill is available\n     */\n    private hasMsrCrypto(): boolean {\n        return \"msrCrypto\" in window;\n    }\n\n    /**\n     * Returns a sha-256 hash of the given dataString as an ArrayBuffer.\n     * @param dataString \n     */\n    async sha256Digest(dataString: string): Promise<ArrayBuffer> {\n        const data = BrowserStringUtils.stringToUtf8Arr(dataString);\n        // MSR Crypto wants object with name property, instead of string\n        return this.subtleCrypto.digest({ name: S256_HASH_ALG }, data);\n    }\n\n    /**\n     * Populates buffer with cryptographically random values.\n     * @param dataBuffer \n     */\n    getRandomValues(dataBuffer: Uint8Array): Uint8Array {\n        return this.subtleCrypto.getRandomValues(dataBuffer);\n    }\n\n    /**\n     * Generates a keypair based on current keygen algorithm config.\n     * @param extractable \n     * @param usages \n     */\n    async generateKeyPair(extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKeyPair> {\n        return this.subtleCrypto.generateKey(this.keygenAlgorithmOptions, extractable, usages);\n    }\n\n    /**\n     * Export key as Json Web Key (JWK)\n     * @param key \n     * @param format \n     */\n    async exportJwk(key: CryptoKey): Promise<JsonWebKey> {\n        return this.subtleCrypto.exportKey(key);\n    }\n\n    /**\n     * Imports key as Json Web Key (JWK), can set extractable and usages.\n     * @param key \n     * @param format \n     * @param extractable \n     * @param usages \n     */\n    async importJwk(key: JsonWebKey, extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKey> {\n        return this.subtleCrypto.importKey(key, this.keygenAlgorithmOptions, extractable, usages);\n    }\n\n    /**\n     * Signs given data with given key\n     * @param key \n     * @param data \n     */\n    async sign(key: CryptoKey, data: ArrayBuffer): Promise<ArrayBuffer> {\n        return this.subtleCrypto.sign(this.keygenAlgorithmOptions, key, data);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}