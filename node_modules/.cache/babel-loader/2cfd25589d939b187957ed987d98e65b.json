{"ast":null,"code":"/*! @azure/msal-common v4.5.0 2021-07-22 */\n'use strict';\n\nimport { __extends, __awaiter, __generator, __assign } from '../_virtual/_tslib.js';\nimport { AuthenticationScheme, GrantType, Errors } from '../utils/Constants.js';\nimport { ClientAuthError as ClientAuthError$1, ClientAuthErrorMessage } from '../error/ClientAuthError.js';\nimport { StringUtils as StringUtils$1 } from '../utils/StringUtils.js';\nimport { ClientConfigurationError as ClientConfigurationError$1 } from '../error/ClientConfigurationError.js';\nimport { buildClientInfoFromHomeAccountId } from '../account/ClientInfo.js';\nimport { ServerError as ServerError$1 } from '../error/ServerError.js';\nimport { CcsCredentialType } from '../account/CcsCredential.js';\nimport { BaseClient as BaseClient$1 } from './BaseClient.js';\nimport { RequestParameterBuilder as RequestParameterBuilder$1 } from '../request/RequestParameterBuilder.js';\nimport { TimeUtils as TimeUtils$1 } from '../utils/TimeUtils.js';\nimport { UrlString as UrlString$1 } from '../url/UrlString.js';\nimport { PopTokenGenerator as PopTokenGenerator$1 } from '../crypto/PopTokenGenerator.js';\nimport { ResponseHandler as ResponseHandler$1 } from '../response/ResponseHandler.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * OAuth2.0 refresh token client\r\n */\n\nvar RefreshTokenClient =\n/** @class */\nfunction (_super) {\n  __extends(RefreshTokenClient, _super);\n\n  function RefreshTokenClient(configuration) {\n    return _super.call(this, configuration) || this;\n  }\n\n  RefreshTokenClient.prototype.acquireToken = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var reqTimestamp, response, responseHandler;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            reqTimestamp = TimeUtils$1.nowSeconds();\n            return [4\n            /*yield*/\n            , this.executeTokenRequest(request, this.authority)];\n\n          case 1:\n            response = _a.sent();\n            responseHandler = new ResponseHandler$1(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);\n            responseHandler.validateTokenResponse(response.body);\n            return [2\n            /*return*/\n            , responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, undefined, undefined, true)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Gets cached refresh token and attaches to request, then calls acquireToken API\r\n   * @param request\r\n   */\n\n\n  RefreshTokenClient.prototype.acquireTokenByRefreshToken = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var isFOCI, noFamilyRTInCache, clientMismatchErrorWithFamilyRT;\n      return __generator(this, function (_a) {\n        // Cannot renew token if no request object is given.\n        if (!request) {\n          throw ClientConfigurationError$1.createEmptyTokenRequestError();\n        } // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n\n\n        if (!request.account) {\n          throw ClientAuthError$1.createNoAccountInSilentRequestError();\n        }\n\n        isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment, this.config.authOptions.clientId); // if the app is part of the family, retrive a Family refresh token if present and make a refreshTokenRequest\n\n        if (isFOCI) {\n          try {\n            return [2\n            /*return*/\n            , this.acquireTokenWithCachedRefreshToken(request, true)];\n          } catch (e) {\n            noFamilyRTInCache = e instanceof ClientAuthError$1 && e.errorCode === ClientAuthErrorMessage.noTokensFoundError.code;\n            clientMismatchErrorWithFamilyRT = e instanceof ServerError$1 && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR; // if family Refresh Token (FRT) cache acquisition fails or if client_mismatch error is seen with FRT, reattempt with application Refresh Token (ART)\n\n            if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {\n              return [2\n              /*return*/\n              , this.acquireTokenWithCachedRefreshToken(request, false)]; // throw in all other cases\n            } else {\n              throw e;\n            }\n          }\n        } // fall back to application refresh token acquisition\n\n\n        return [2\n        /*return*/\n        , this.acquireTokenWithCachedRefreshToken(request, false)];\n      });\n    });\n  };\n  /**\r\n   * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached\r\n   * @param request\r\n   */\n\n\n  RefreshTokenClient.prototype.acquireTokenWithCachedRefreshToken = function (request, foci) {\n    return __awaiter(this, void 0, void 0, function () {\n      var refreshToken, refreshTokenRequest;\n      return __generator(this, function (_a) {\n        refreshToken = this.cacheManager.readRefreshTokenFromCache(this.config.authOptions.clientId, request.account, foci); // no refresh Token\n\n        if (!refreshToken) {\n          throw ClientAuthError$1.createNoTokensFoundError();\n        }\n\n        refreshTokenRequest = __assign(__assign({}, request), {\n          refreshToken: refreshToken.secret,\n          authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,\n          ccsCredential: {\n            credential: request.account.homeAccountId,\n            type: CcsCredentialType.HOME_ACCOUNT_ID\n          }\n        });\n        return [2\n        /*return*/\n        , this.acquireToken(refreshTokenRequest)];\n      });\n    });\n  };\n  /**\r\n   * Constructs the network message and makes a NW call to the underlying secure token service\r\n   * @param request\r\n   * @param authority\r\n   */\n\n\n  RefreshTokenClient.prototype.executeTokenRequest = function (request, authority) {\n    return __awaiter(this, void 0, void 0, function () {\n      var requestBody, queryParameters, headers, thumbprint, endpoint;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.createTokenRequestBody(request)];\n\n          case 1:\n            requestBody = _a.sent();\n            queryParameters = this.createTokenQueryParameters(request);\n            headers = this.createTokenRequestHeaders(request.ccsCredential);\n            thumbprint = {\n              clientId: this.config.authOptions.clientId,\n              authority: authority.canonicalAuthority,\n              scopes: request.scopes\n            };\n            endpoint = UrlString$1.appendQueryString(authority.tokenEndpoint, queryParameters);\n            return [2\n            /*return*/\n            , this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Creates query string for the /token request\r\n   * @param request\r\n   */\n\n\n  RefreshTokenClient.prototype.createTokenQueryParameters = function (request) {\n    var parameterBuilder = new RequestParameterBuilder$1();\n\n    if (request.tokenQueryParameters) {\n      parameterBuilder.addExtraQueryParameters(request.tokenQueryParameters);\n    }\n\n    return parameterBuilder.createQueryString();\n  };\n  /**\r\n   * Helper function to create the token request body\r\n   * @param request\r\n   */\n\n\n  RefreshTokenClient.prototype.createTokenRequestBody = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var parameterBuilder, correlationId, clientAssertion, popTokenGenerator, _a, _b, clientInfo;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            parameterBuilder = new RequestParameterBuilder$1();\n            parameterBuilder.addClientId(this.config.authOptions.clientId);\n            parameterBuilder.addScopes(request.scopes);\n            parameterBuilder.addGrantType(GrantType.REFRESH_TOKEN_GRANT);\n            parameterBuilder.addClientInfo();\n            parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n            parameterBuilder.addThrottling();\n\n            if (this.serverTelemetryManager) {\n              parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n            }\n\n            correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n            parameterBuilder.addCorrelationId(correlationId);\n            parameterBuilder.addRefreshToken(request.refreshToken);\n\n            if (this.config.clientCredentials.clientSecret) {\n              parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\n            }\n\n            if (this.config.clientCredentials.clientAssertion) {\n              clientAssertion = this.config.clientCredentials.clientAssertion;\n              parameterBuilder.addClientAssertion(clientAssertion.assertion);\n              parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\n            }\n\n            if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 2];\n            popTokenGenerator = new PopTokenGenerator$1(this.cryptoUtils);\n            _b = (_a = parameterBuilder).addPopToken;\n            return [4\n            /*yield*/\n            , popTokenGenerator.generateCnf(request)];\n\n          case 1:\n            _b.apply(_a, [_c.sent()]);\n\n            _c.label = 2;\n\n          case 2:\n            if (!StringUtils$1.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n              parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n            }\n\n            if (this.config.systemOptions.preventCorsPreflight && request.ccsCredential) {\n              switch (request.ccsCredential.type) {\n                case CcsCredentialType.HOME_ACCOUNT_ID:\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n                  }\n\n                  break;\n\n                case CcsCredentialType.UPN:\n                  parameterBuilder.addCcsUpn(request.ccsCredential.credential);\n                  break;\n              }\n            }\n\n            return [2\n            /*return*/\n            , parameterBuilder.createQueryString()];\n        }\n      });\n    });\n  };\n\n  return RefreshTokenClient;\n}(BaseClient$1);\n\nexport { RefreshTokenClient };","map":{"version":3,"mappings":"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","names":["__extends","configuration","_super","RefreshTokenClient","request","reqTimestamp","TimeUtils","nowSeconds","executeTokenRequest","authority","response","_a","responseHandler","ResponseHandler","config","authOptions","clientId","cacheManager","cryptoUtils","logger","serializableCache","persistencePlugin","validateTokenResponse","body","handleServerTokenResponse","undefined","ClientConfigurationError","createEmptyTokenRequestError","account","ClientAuthError","createNoAccountInSilentRequestError","isFOCI","isAppMetadataFOCI","environment","acquireTokenWithCachedRefreshToken","e","noFamilyRTInCache","errorCode","ClientAuthErrorMessage","noTokensFoundError","code","clientMismatchErrorWithFamilyRT","ServerError","Errors","INVALID_GRANT_ERROR","subError","CLIENT_MISMATCH_ERROR","foci","refreshToken","readRefreshTokenFromCache","createNoTokensFoundError","refreshTokenRequest","secret","authenticationScheme","AuthenticationScheme","BEARER","ccsCredential","credential","homeAccountId","type","CcsCredentialType","HOME_ACCOUNT_ID","acquireToken","createTokenRequestBody","requestBody","queryParameters","createTokenQueryParameters","headers","createTokenRequestHeaders","thumbprint","canonicalAuthority","scopes","endpoint","UrlString","appendQueryString","tokenEndpoint","executePostToTokenEndpoint","parameterBuilder","RequestParameterBuilder","tokenQueryParameters","addExtraQueryParameters","createQueryString","addClientId","addScopes","addGrantType","GrantType","REFRESH_TOKEN_GRANT","addClientInfo","addLibraryInfo","libraryInfo","addThrottling","serverTelemetryManager","addServerTelemetry","correlationId","cryptoInterface","createNewGuid","addCorrelationId","addRefreshToken","clientCredentials","clientSecret","addClientSecret","clientAssertion","addClientAssertion","assertion","addClientAssertionType","assertionType","POP","popTokenGenerator","PopTokenGenerator","_b","addPopToken","generateCnf","_c","StringUtils","isEmptyObj","claims","clientCapabilities","length","addClaims","systemOptions","preventCorsPreflight","clientInfo","buildClientInfoFromHomeAccountId","addCcsOid","verbose","UPN","addCcsUpn","BaseClient"],"sources":["../../src/client/RefreshTokenClient.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\r\nimport { BaseClient } from \"./BaseClient\";\r\nimport { CommonRefreshTokenRequest } from \"../request/CommonRefreshTokenRequest\";\r\nimport { Authority } from \"../authority/Authority\";\r\nimport { ServerAuthorizationTokenResponse } from \"../response/ServerAuthorizationTokenResponse\";\r\nimport { RequestParameterBuilder } from \"../request/RequestParameterBuilder\";\r\nimport { GrantType, AuthenticationScheme, Errors  } from \"../utils/Constants\";\r\nimport { ResponseHandler } from \"../response/ResponseHandler\";\r\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\r\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { RequestThumbprint } from \"../network/RequestThumbprint\";\r\nimport { NetworkResponse } from \"../network/NetworkManager\";\r\nimport { CommonSilentFlowRequest } from \"../request/CommonSilentFlowRequest\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\nimport { ClientAuthError, ClientAuthErrorMessage } from \"../error/ClientAuthError\";\r\nimport { ServerError } from \"../error/ServerError\";\r\nimport { TimeUtils } from \"../utils/TimeUtils\";\r\nimport { UrlString } from \"../url/UrlString\";\r\nimport { CcsCredentialType } from \"../account/CcsCredential\";\r\nimport { buildClientInfoFromHomeAccountId } from \"../account/ClientInfo\";\r\n\r\n/**\r\n * OAuth2.0 refresh token client\r\n */\r\nexport class RefreshTokenClient extends BaseClient {\r\n\r\n    constructor(configuration: ClientConfiguration) {\r\n        super(configuration);\r\n    }\r\n\r\n    public async acquireToken(request: CommonRefreshTokenRequest): Promise<AuthenticationResult>{\r\n        const reqTimestamp = TimeUtils.nowSeconds();\r\n        const response = await this.executeTokenRequest(request, this.authority);\r\n\r\n        const responseHandler = new ResponseHandler(\r\n            this.config.authOptions.clientId,\r\n            this.cacheManager,\r\n            this.cryptoUtils,\r\n            this.logger,\r\n            this.config.serializableCache,\r\n            this.config.persistencePlugin\r\n        );\r\n\r\n        responseHandler.validateTokenResponse(response.body);\r\n        return responseHandler.handleServerTokenResponse(\r\n            response.body,\r\n            this.authority,\r\n            reqTimestamp,\r\n            request,\r\n            undefined,\r\n            undefined,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets cached refresh token and attaches to request, then calls acquireToken API\r\n     * @param request\r\n     */\r\n    public async acquireTokenByRefreshToken(request: CommonSilentFlowRequest): Promise<AuthenticationResult> {\r\n        // Cannot renew token if no request object is given.\r\n        if (!request) {\r\n            throw ClientConfigurationError.createEmptyTokenRequestError();\r\n        }\r\n\r\n        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\r\n        if (!request.account) {\r\n            throw ClientAuthError.createNoAccountInSilentRequestError();\r\n        }\r\n\r\n        // try checking if FOCI is enabled for the given application\r\n        const isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment, this.config.authOptions.clientId);\r\n\r\n        // if the app is part of the family, retrive a Family refresh token if present and make a refreshTokenRequest\r\n        if (isFOCI) {\r\n            try {\r\n                return this.acquireTokenWithCachedRefreshToken(request, true);\r\n            } catch (e) {\r\n                const noFamilyRTInCache = e instanceof ClientAuthError && e.errorCode === ClientAuthErrorMessage.noTokensFoundError.code;\r\n                const clientMismatchErrorWithFamilyRT = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR;\r\n\r\n                // if family Refresh Token (FRT) cache acquisition fails or if client_mismatch error is seen with FRT, reattempt with application Refresh Token (ART)\r\n                if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {\r\n                    return this.acquireTokenWithCachedRefreshToken(request, false);\r\n                // throw in all other cases\r\n                } else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n\r\n        // fall back to application refresh token acquisition\r\n        return this.acquireTokenWithCachedRefreshToken(request, false);\r\n    }\r\n\r\n    /**\r\n     * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached\r\n     * @param request\r\n     */\r\n    private async acquireTokenWithCachedRefreshToken(request: CommonSilentFlowRequest, foci: boolean) {\r\n        // fetches family RT or application RT based on FOCI value\r\n        const refreshToken = this.cacheManager.readRefreshTokenFromCache(this.config.authOptions.clientId, request.account, foci);\r\n\r\n        // no refresh Token\r\n        if (!refreshToken) {\r\n            throw ClientAuthError.createNoTokensFoundError();\r\n        }\r\n\r\n        const refreshTokenRequest: CommonRefreshTokenRequest = {\r\n            ...request,\r\n            refreshToken: refreshToken.secret,\r\n            authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,\r\n            ccsCredential: {\r\n                credential: request.account.homeAccountId,\r\n                type: CcsCredentialType.HOME_ACCOUNT_ID\r\n            }\r\n        };\r\n\r\n        return this.acquireToken(refreshTokenRequest);\r\n    }\r\n\r\n    /**\r\n     * Constructs the network message and makes a NW call to the underlying secure token service\r\n     * @param request\r\n     * @param authority\r\n     */\r\n    private async executeTokenRequest(request: CommonRefreshTokenRequest, authority: Authority)\r\n        : Promise<NetworkResponse<ServerAuthorizationTokenResponse>> {\r\n\r\n        const requestBody = await this.createTokenRequestBody(request);\r\n        const queryParameters = this.createTokenQueryParameters(request);\r\n        const headers: Record<string, string> = this.createTokenRequestHeaders(request.ccsCredential);\r\n        const thumbprint: RequestThumbprint = {\r\n            clientId: this.config.authOptions.clientId,\r\n            authority: authority.canonicalAuthority,\r\n            scopes: request.scopes\r\n        };\r\n\r\n        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParameters);\r\n        return this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint);\r\n    }\r\n\r\n    /**\r\n     * Creates query string for the /token request\r\n     * @param request \r\n     */\r\n    private createTokenQueryParameters(request: CommonRefreshTokenRequest): string {\r\n        const parameterBuilder = new RequestParameterBuilder();\r\n\r\n        if (request.tokenQueryParameters) {\r\n            parameterBuilder.addExtraQueryParameters(request.tokenQueryParameters);\r\n        }\r\n\r\n        return parameterBuilder.createQueryString();\r\n    }\r\n\r\n    /**\r\n     * Helper function to create the token request body\r\n     * @param request\r\n     */\r\n    private async createTokenRequestBody(request: CommonRefreshTokenRequest): Promise<string> {\r\n        const parameterBuilder = new RequestParameterBuilder();\r\n\r\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\r\n\r\n        parameterBuilder.addScopes(request.scopes);\r\n\r\n        parameterBuilder.addGrantType(GrantType.REFRESH_TOKEN_GRANT);\r\n\r\n        parameterBuilder.addClientInfo();\r\n\r\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\r\n\r\n        parameterBuilder.addThrottling();\r\n        \r\n        if (this.serverTelemetryManager) {\r\n            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\r\n        }\r\n\r\n        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\r\n        parameterBuilder.addCorrelationId(correlationId);\r\n\r\n        parameterBuilder.addRefreshToken(request.refreshToken);\r\n\r\n        if (this.config.clientCredentials.clientSecret) {\r\n            parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\r\n        }\r\n\r\n        if (this.config.clientCredentials.clientAssertion) {\r\n            const clientAssertion = this.config.clientCredentials.clientAssertion;\r\n            parameterBuilder.addClientAssertion(clientAssertion.assertion);\r\n            parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\r\n        }\r\n\r\n        if (request.authenticationScheme === AuthenticationScheme.POP) {\r\n            const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);\r\n\r\n            parameterBuilder.addPopToken(await popTokenGenerator.generateCnf(request));\r\n        }\r\n\r\n        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\r\n            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\r\n        }\r\n\r\n        if (this.config.systemOptions.preventCorsPreflight && request.ccsCredential) {\r\n            switch (request.ccsCredential.type) {\r\n                case CcsCredentialType.HOME_ACCOUNT_ID:\r\n                    try {\r\n                        const clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);\r\n                        parameterBuilder.addCcsOid(clientInfo);\r\n                    } catch (e) {\r\n                        this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\r\n                    }\r\n                    break;\r\n                case CcsCredentialType.UPN:\r\n                    parameterBuilder.addCcsUpn(request.ccsCredential.credential);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return parameterBuilder.createQueryString();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}